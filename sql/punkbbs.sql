# Host: 127.0.0.1  (Version: 5.7.20)
# Date: 2020-08-11 12:15:19
# Generator: MySQL-Front 5.3  (Build 4.269)

/*!40101 SET NAMES utf8 */;

#
# Structure for table "bannedinfo"
#

DROP TABLE IF EXISTS `bannedinfo`;
CREATE TABLE `bannedinfo` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `reason` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4;

#
# Data for table "bannedinfo"
#

INSERT INTO `bannedinfo` VALUES (2,'淫秽色情'),(3,'其他原因'),(4,'ff');

#
# Structure for table "friendly_link"
#

DROP TABLE IF EXISTS `friendly_link`;
CREATE TABLE `friendly_link` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `link` varchar(255) DEFAULT NULL,
  `allowed` bit(1) DEFAULT b'0',
  `email` varchar(255) NOT NULL,
  `updateTime` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  `createTime` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=45 DEFAULT CHARSET=utf8;

#
# Data for table "friendly_link"
#

INSERT INTO `friendly_link` VALUES (44,'西瓜酸奶','https://www.yuanyi2000.top',b'1','yuanyi2000@aliyun.com',NULL,'2020-08-05 15:59:17');

#
# Structure for table "log"
#

DROP TABLE IF EXISTS `log`;
CREATE TABLE `log` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `createTime` date DEFAULT NULL,
  `visit` bigint(20) DEFAULT '0',
  `updateTime` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `visit_date` (`createTime`)
) ENGINE=InnoDB AUTO_INCREMENT=52 DEFAULT CHARSET=utf8;

#
# Data for table "log"
#

INSERT INTO `log` VALUES (1,'2020-06-02',56,NULL),(2,'2020-06-03',26,NULL),(3,'2020-06-04',76,NULL),(4,'2020-06-05',62,NULL),(5,'2020-06-06',64,NULL),(6,'2020-06-07',65,NULL),(7,'2020-06-08',73,NULL),(8,'2020-06-09',51,NULL),(9,'2020-06-10',33,NULL),(10,'2020-06-11',35,NULL),(11,'2020-06-12',57,NULL),(12,'2020-06-13',66,NULL),(13,'2020-06-14',72,NULL),(14,'2020-06-15',48,NULL),(15,'2020-06-16',63,NULL),(16,'2020-06-17',57,NULL),(17,'2020-06-18',43,NULL),(18,'2020-06-19',68,NULL),(19,'2020-06-20',67,NULL),(20,'2020-06-21',67,NULL),(21,'2020-06-22',56,NULL),(22,'2020-06-23',60,NULL),(23,'2020-06-24',60,NULL),(24,'2020-06-25',63,NULL),(25,'2020-06-26',52,NULL),(26,'2020-06-27',44,NULL),(27,'2020-06-28',50,NULL),(28,'2020-06-29',23,NULL),(29,'2020-06-30',61,NULL),(30,'2020-07-01',64,NULL),(31,'2020-07-02',49,NULL),(32,'2020-07-03',49,NULL),(33,'2020-07-04',55,NULL),(34,'2020-07-05',31,NULL),(35,'2020-07-06',50,NULL),(36,'2020-07-07',51,NULL),(37,'2020-07-08',43,NULL),(38,'2020-07-09',47,NULL),(39,'2020-07-10',43,NULL),(40,'2020-07-11',34,NULL),(41,'2020-07-12',47,NULL),(42,'2020-07-13',32,NULL),(43,'2020-07-14',53,NULL),(44,'2020-07-15',12,NULL),(45,'2020-07-16',60,NULL),(46,'2020-07-23',78,NULL),(48,'2020-07-24',45,NULL),(49,'2020-07-25',48,NULL),(50,'2020-07-26',53,NULL),(51,'2020-07-27',46,NULL);

#
# Structure for table "message"
#

DROP TABLE IF EXISTS `message`;
CREATE TABLE `message` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `content` text,
  `createTime` datetime DEFAULT CURRENT_TIMESTAMP,
  `updateTime` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=81 DEFAULT CHARSET=utf8mb4;

#
# Data for table "message"
#

INSERT INTO `message` VALUES (58,'界面很丑','2020-04-11 00:00:00',NULL),(62,'页码也可以改一下','2020-04-26 00:00:00',NULL),(63,'页面太白了   费眼睛啊','2020-04-29 00:00:00',NULL),(68,'哇哦','2020-05-11 19:56:15',NULL),(72,'好看一点啊','2020-05-15 17:40:24',NULL),(79,'眼睛 看 偷看','2020-07-30 09:20:33',NULL),(80,'asdff','2020-08-01 19:46:55',NULL);

#
# Structure for table "picture"
#

DROP TABLE IF EXISTS `picture`;
CREATE TABLE `picture` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `filekey` varchar(255) NOT NULL,
  `url` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=174 DEFAULT CHARSET=utf8;

#
# Data for table "picture"
#

INSERT INTO `picture` VALUES (10,'10','http://q7xlyvqgm.bkt.clouddn.com/10'),(11,'11','http://q7xlyvqgm.bkt.clouddn.com/11'),(14,'14','http://q7xlyvqgm.bkt.clouddn.com/14'),(15,'15','http://q7xlyvqgm.bkt.clouddn.com/15'),(16,'16','http://q7xlyvqgm.bkt.clouddn.com/16'),(17,'17','http://q7xlyvqgm.bkt.clouddn.com/17'),(18,'18','http://q7xlyvqgm.bkt.clouddn.com/18'),(19,'19','http://q7xlyvqgm.bkt.clouddn.com/19'),(20,'20','http://q7xlyvqgm.bkt.clouddn.com/20'),(21,'21','http://q7xlyvqgm.bkt.clouddn.com/21'),(22,'22','http://q7xlyvqgm.bkt.clouddn.com/22'),(23,'23','http://q7xlyvqgm.bkt.clouddn.com/23'),(24,'24','http://q7xlyvqgm.bkt.clouddn.com/24'),(25,'25','http://q7xlyvqgm.bkt.clouddn.com/25'),(26,'26','http://q7xlyvqgm.bkt.clouddn.com/26'),(27,'27','http://q7xlyvqgm.bkt.clouddn.com/27'),(73,'73','http://img.xuhaobo.site/73'),(74,'74','http://img.xuhaobo.site/74'),(75,'75','http://img.xuhaobo.site/75'),(76,'76','http://img.xuhaobo.site/76'),(77,'77','http://img.xuhaobo.site/77'),(78,'78','http://img.xuhaobo.site/78'),(79,'79','http://img.xuhaobo.site/79'),(80,'80','http://img.xuhaobo.site/80'),(81,'81','http://img.xuhaobo.site/81'),(82,'82','http://img.xuhaobo.site/82'),(83,'83','http://img.xuhaobo.site/83'),(84,'84','http://img.xuhaobo.site/84'),(85,'85','http://img.xuhaobo.site/85'),(86,'86','http://img.xuhaobo.site/86'),(87,'87','http://img.xuhaobo.site/87'),(88,'88','http://img.xuhaobo.site/88'),(89,'89','http://img.xuhaobo.site/89'),(97,'97','http://img.xuhaobo.site/97'),(98,'98','http://img.xuhaobo.site/98'),(99,'99','http://img.xuhaobo.site/99'),(100,'100','http://img.xuhaobo.site/100'),(101,'101','http://img.xuhaobo.site/101'),(102,'102','http://img.xuhaobo.site/102'),(103,'103','http://img.xuhaobo.site/103'),(104,'104','http://img.xuhaobo.site/104'),(105,'105','http://img.xuhaobo.site/105'),(106,'106','http://img.xuhaobo.site/106'),(107,'107','http://img.xuhaobo.site/107'),(108,'108','http://img.xuhaobo.site/108'),(109,'109','http://img.xuhaobo.site/109'),(110,'110','http://img.xuhaobo.site/110'),(111,'111','http://img.xuhaobo.site/111'),(112,'112','http://img.xuhaobo.site/112'),(113,'113','http://img.xuhaobo.site/113'),(114,'114','http://img.xuhaobo.site/114'),(115,'115','http://img.xuhaobo.site/115'),(116,'116','http://img.xuhaobo.site/116'),(117,'117','http://img.xuhaobo.site/117'),(118,'118','http://img.xuhaobo.site/118'),(119,'119','http://img.xuhaobo.site/119'),(120,'120','http://img.xuhaobo.site/120'),(121,'121','http://img.xuhaobo.site/121'),(122,'122','http://img.xuhaobo.site/122'),(123,'123','http://img.xuhaobo.site/123'),(124,'124','http://img.xuhaobo.site/124'),(125,'125','http://img.xuhaobo.site/125'),(126,'126','http://img.xuhaobo.site/126'),(127,'127','http://img.xuhaobo.site/127'),(128,'128','http://img.xuhaobo.site/128'),(129,'129','http://img.xuhaobo.site/129'),(130,'130','http://img.xuhaobo.site/130'),(131,'131','http://img.xuhaobo.site/131'),(132,'132','http://img.xuhaobo.site/132'),(133,'133','http://img.xuhaobo.site/133'),(134,'134','http://img.xuhaobo.site/134'),(135,'135','http://img.xuhaobo.site/135'),(136,'136','http://img.xuhaobo.site/136'),(137,'137','http://img.xuhaobo.site/137'),(138,'138','http://img.xuhaobo.site/138'),(139,'139','http://img.xuhaobo.site/139'),(140,'140','http://img.xuhaobo.site/140'),(141,'141','http://img.xuhaobo.site/141'),(142,'142','http://img.xuhaobo.site/142'),(143,'143','http://img.xuhaobo.site/143'),(144,'144','http://img.xuhaobo.site/144'),(145,'145','http://img.xuhaobo.site/145'),(146,'146','http://img.xuhaobo.site/146'),(147,'147','http://img.xuhaobo.site/147'),(148,'148','http://img.xuhaobo.site/148'),(149,'149','http://img.xuhaobo.site/149'),(150,'150','http://img.xuhaobo.site/150'),(151,'151','http://img.xuhaobo.site/151'),(152,'152','http://img.xuhaobo.site/152'),(153,'153','http://img.xuhaobo.site/153'),(154,'154','http://img.xuhaobo.site/154'),(155,'155','http://img.xuhaobo.site/155'),(156,'156','http://img.xuhaobo.site/156'),(157,'157','http://img.xuhaobo.site/157'),(158,'158','http://img.xuhaobo.site/158'),(159,'159','http://img.xuhaobo.site/159'),(160,'160','http://img.xuhaobo.site/160'),(161,'161','http://img.xuhaobo.site/161'),(162,'162','http://img.xuhaobo.site/162'),(163,'163','http://img.xuhaobo.site/163'),(164,'164','http://img.xuhaobo.site/164'),(165,'165','http://img.xuhaobo.site/165'),(166,'166','http://img.xuhaobo.site/166'),(167,'167','http://img.xuhaobo.site/167'),(168,'168','http://img.xuhaobo.site/168'),(169,'169','http://img.xuhaobo.site/169'),(170,'170','http://img.xuhaobo.site/170'),(171,'171','http://img.xuhaobo.site/171'),(172,'172','http://img.xuhaobo.site/172'),(173,'173','http://img.xuhaobo.site/173');

#
# Structure for table "tag"
#

DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `updateTime` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  `createTime` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8;

#
# Data for table "tag"
#

INSERT INTO `tag` VALUES (2,'数据结构与算法',NULL,'2020-08-05 16:02:53'),(3,'CS:APP',NULL,'2020-08-05 16:02:53'),(8,'JAVA后端开发',NULL,'2020-08-05 16:02:53'),(15,'python数据挖掘',NULL,'2020-08-05 16:02:53'),(20,'汇编语言',NULL,'2020-08-05 16:02:53'),(22,'操作系统',NULL,'2020-08-05 16:02:53'),(23,'杂记',NULL,'2020-08-05 16:02:53'),(26,'生活吐槽',NULL,'2020-08-05 16:02:53');

#
# Structure for table "article"
#

DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `tid` int(11) NOT NULL,
  `createTime` datetime DEFAULT CURRENT_TIMESTAMP,
  `title` varchar(255) DEFAULT NULL,
  `firstPicture` varchar(255) DEFAULT NULL,
  `visit` bigint(20) DEFAULT '0',
  `content` mediumtext,
  `published` bit(1) DEFAULT b'0',
  `info` mediumtext,
  `top` bit(1) DEFAULT b'0',
  `uid` int(11) NOT NULL,
  `updateTime` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  `bid` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `fk_article_tag` (`tid`),
  KEY `uid_user` (`uid`),
  KEY `is_pub` (`published`),
  CONSTRAINT `fk_article_tag` FOREIGN KEY (`tid`) REFERENCES `tag` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=170 DEFAULT CHARSET=utf8mb4;

#
# Data for table "article"
#

INSERT INTO `article` VALUES (3,3,'2020-04-07 00:00:00','<<深入理解计算机系统>>之动态链接','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3020495497,2923874859&fm=26&gp=0.jpg',10,':pouting_cat: :pouting_cat: :pouting_cat: :tw-1f4a9: :tw-1f4a9: :tw-1f4a9:1.对static以及模块内的变量定义的区分:\r\n\r\n\tstatic:本地链接器符号---在模块中任何位置都可见,但是不能被其他模块所引用\r\n\t本地定义的变量: .symtab符号表并不包含本地变量定义的符号,这些符号由栈进行管理\r\n\r\n2.bss节与COMMON节的区分:\r\n    \r\n\tbss:局部未初始化||局部为0||全局为0(static为局部)\r\n\tCOMMON:全局为初始化\r\n\r\n3.未初始化的变量(如上说的.bss,COMMON)在重定向目标文件以及可执行目标文件中没有实际分配空间,但是在实际运行过程中按照符号表中的类型分配',b'1',':pouting_cat: :pouting_cat: :pouting_cat: :tw-1f4a9: :tw-1f4a9: :tw-1f4a9:1.对static以及模块内的变量定义的区分:\r\n\r\n\tstatic:本地链接器符号---在模块中任何位置都可见,但是不能被其他模块所引用\r\n\t本地定义的变量: .symtab符号表并不包含本地变量定义的符号,这些符号由栈进行管理\r\n\r\n2.bss节与COMMON节的区分:\r\n    \r\n\tbss:局部未初始化||局部为0||全局为0(static为局部)\r\n\tCOMMON:全局为初始化\r\n\r\n3.未初始化的变量(如上说的.bss,COMMON)在重定向目标文件以及可执行目标文件中没有实际分配空间,但是在实际运行过程中按照符号表中的类型分配',b'0',2,NULL,NULL),(6,3,'2020-04-01 00:00:00','<<深入理解计算机系统>>第七章易错点总结','https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3394611025,2062792490&fm=26&gp=0.jpg',21,'1.对static以及模块内的变量定义的区分:\r\n\r\n\tstatic:本地链接器符号---在模块中任何位置都可见,但是不能被其他模块所引用\r\n\t本地定义的变量: .symtab符号表并不包含本地变量定义的符号,这些符号由栈进行管理\r\n\r\n2.bss节与COMMON节的区分:\r\n    \r\n\tbss:局部未初始化||局部为0||全局为0(static为局部)\r\n\tCOMMON:全局为初始化\r\n\r\n3.未初始化的变量(如上说的.bss,COMMON)在重定向目标文件以及可执行目标文件中没有实际分配空间,但是在实际运行过程中按照符号表中的类型分配',b'1','1.对static以及模块内的变量定义的区分:\r\n\r\n\tstatic:本地链接器符号---在模块中任何位置都可见,但是不能被其他模块所引用\r\n\t本地定义的变量: .symtab符号表并不包含本地变量定义的符号,这些符号由栈进行管理\r\n\r\n2.bss节与COMMON节的区分:\r\n    \r\n\tbss:局部未初始化||局部为0||全局为0(static为局部)\r\n\tCOMMON:全局为初始化\r\n\r\n3.未初始化的变量(如上说的.bss,COMMON)在重定向目标文件以及可执行目标文件中没有实际分配空间,但是在实际运行过程中按照符号表中的类型分配',b'0',2,NULL,NULL),(7,15,'2020-04-02 00:00:00','pandas库的相关文件IO操作','https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3506000979,3290554988&fm=11&gp=0.jpg',13,'pandas库的文件最常用的是csv,hdf以及json,下面介绍下他们\r\n各自的api\r\n\r\n\r\n\r\n\r\n\tcsv:\r\n```python\r\n#从路径中读取csv文件,usecols代表其所读取的字段\r\ndata_csv=pd.read_csv(\"C:/Users/user/Desktop/教程文档/Python数据挖掘基础教程资料/day3资料/02-代码/stock_day/stock_day.csv\",usecols=data.columns[0:4])\r\n#数据写入,index控制是否传入索引,columns控制要写入那几个字段的数据\r\ndata_csv.to_csv(\"C:/Users/user/Desktop/教程文档/Python数据挖掘基础教程资料/day3资料/02-代码/stock_day/tostock_day3.csv\",columns=data.columns[0:2],index=False)      \r\n\r\n\r\n```\r\n\r\n\tHDF5：hdf5数据可以通过key来获取相应的二维数据,本质上可以看作是三维数据\r\n```python\r\n#从路径中读取HDF5文件,注意HDF5为二进制文件,hdf5数据可以通过key来获取相应的二维数据,本质上可以看作是三维数据\r\n\r\ndata_hdf=pd.read_hdf(\"D:/totest.h5\",key=\'first\')        #当只有一个key时可以读取\r\ndata_csv.to_hdf(\"D:/totest.h5\",key=\'third\')            #这里必须要存入相应的key\r\n\r\n```\r\n\r\n\tjson:学java web,spring boot时的老朋友了,又在这遇见了哈哈哈\r\n```python\r\n#读取json文件\r\njson=pd.read_json(\'C:/Users/user/Desktop/教程文档/Python数据挖掘基础教程资料/day3资料/02-代码/test.json\',orient=\"records\",lines=True)  \r\n#(path,orient,lines)    orient默认设成\"records\"格式, line表示按照行一行一行读取json数据\r\nprint(json)\r\njson.to_json(\'C:/Users/user/Desktop/教程文档/Python数据挖掘基础教程资料/day3资料/02-代码/testto.json\',orient=\"records\",lines=True) \r\n#这里的常用属性设置与之前相同,lines的意思是一行一行读进json文件中去\r\n```',b'1','pandas库的文件最常用的是csv,hdf以及json,下面介绍下他们\r\n各自的api。',b'0',2,NULL,NULL),(8,15,'2020-04-06 00:00:00','[python]第一天数据挖掘','https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3890848816,3171555074&fm=26&gp=0.jpg',26,'#python数据挖掘之matplotlab的使用\r\n*最近为了开学的大创,在学习一点python数据挖掘相关的内容,简单地看黑马\r\n的视频学了一点点的matplotlab.....感觉这一块还是不难的,大概就是调ap\r\ni吧,具体使用还是要多用得好\r\n至于什么是matplotlab,为什么要使用matplotlab这里就不细说了....*\r\n##1.容器层(画布)\r\n&emsp;&emsp;这个没什么好说的,就是要在画布上画画的道理,如果要生成一组统计图就只建立一个画布而不需要坐标系：\r\n```python\r\nfig = plt.figure(figsize=(a, b), dpi=dpi)\r\n#figsize a,b指定画布长宽,dpi指定清晰度\r\n```\r\n&emsp;&emsp;如果要建立多个图像则需要建立坐标系\r\n```python\r\nﬁgure, axes = plt.subplots(nrows=, ncols=, ﬁgsize=, dpi=)\r\n#nrows代表行数,ncols代表列数,控制划分区域,而后的、figsize和dpi用法则与之前相同\r\n\r\n```\r\n两者间使用的api略有不同,这里我举例折线图把建立坐标系所使用的的api如下\r\n```python\r\nimport matplotlib.pyplot as plt\r\nimport random\r\n%matplotlib inline\r\n\r\nx=[i for i in range(60)]\r\nx_label=[\"值为{}\".format(i) for i in x]\r\n\r\ny=[int(random.uniform(10,18)) for i in range(60)]\r\ny_label=[\"值为{}\".format(i) for i in y]\r\n\r\nx2=[i for i in range(60)]\r\nx2_label=[\"值为{}\".format(i) for i in x]         \r\n\r\ny2=[int(random.uniform(10,18)) for i in range(60)]  //这里通过列表生成式不断生成随机数\r\ny2_label=[\"值为{}\".format(i) for i in y]\r\n\r\nfigure,axes=plt.subplots(nrows=1,ncols=2)\r\n\r\n#plt.figure(figsize=(20,8),dpi=80)    画布 plt.figure()\r\n\r\n#画图 plot函数先传x轴上的再传y轴上的\r\n\r\naxes[0].plot(x,y,color=\"r\",label=\"第一个图像\",linestyle=\"--\")     #linestyle控制线条的粗细(忽然感觉)\r\naxes[1].plot(x2,y2,color=\"g\",label=\"第二个图像\",alpha=0.8)       #实际的画的动作,alpha控制透明度\r\n\r\n\r\n#辅助显示\r\naxes[0].grid(alpha=0.5,linestyle=\"--\")      #grid设置表格\r\naxes[1].legend()              #选择图例位置(默认为best) ,之前给设置的plot时的 图像时显示\r\naxes[0].legend()\r\n\r\naxes[0].set_xticks(x[::5])     #设置辅助显示x轴,增加标注刻度\r\naxes[0].set_xticklabels(x_label[::5])\r\naxes[0].set_yticks(y[::5])     #设置辅助显示y轴,增加标注刻度\r\naxes[0].set_yticklabels(y_label[::5])\r\n\r\naxes[1].set_xticks(x2[::5])     #设置辅助显示x轴,增加标注刻度\r\naxes[1].set_xticklabels(x2_label[::5])\r\naxes[1].set_yticks(y2[::5])     #设置辅助显示y轴,增加标注刻度\r\naxes[1].set_yticklabels(y2_label[::5])\r\n\r\naxes[0].set_xlabel(\"x轴。。。。\")\r\naxes[0].set_ylabel(\"y轴。。。。\")\r\n\r\nplt.show()\r\n```\r\n&emsp;&emsp;当然里面也有图像层的对应用法,可以把这种思路的不同理解成不建立坐标系时是面向过程的,而建立坐标系后则是面向对象的。\r\n\r\n##2.辅助显示层\r\n\t同样地,辅助显示层也是大同小异,常用地可以控制x,y轴刻度,以及描述信息,添加网格,显示图例等,这里只描述下单个图像的api\r\n```python\r\nplt.xticks([i for i in range(10)][::5],[\"i的值为{}\".format(i) for i in range(10)][::5])   #前面的是实际的x轴数据,后面是所修改的x,y刻度\r\nplt.xlabel(\"x轴上所加的标签\")          #用字符串指代x轴所加标签\r\nplt.grid()       #添加网格,这个没什么可说的\r\n\r\nplt.legend()       #这个要与绘制图像的Api一起使用,之后会提到\r\n```\r\n\r\n##3.图像层\r\n\r\n\t图像层就有很多的不同了,需要我们根据不同的数据选取合适的图像\r\n\t都有的属性:linestyle:线条类型  alpha:透明度 color:色彩\r\n####1.折线图--变化趋势:\r\n```python\r\nplt.plot([i for i in range(10)],[j for j in range(10)],label=\"直线\") #(x,y,图例说明)\r\n```\r\n####2.散点图--是否存在关系:\r\nplt.scatter(x,y,...)\r\n\r\n####3.柱状图:\r\nplt.bar(x,y,...)\r\n柱状图在进行比较时通常会有多个一组一起比,这里需要考虑一下偏移量的问题\r\n例如:\r\n```python\r\nimport matplotlib.pyplot as plt\r\nimport random\r\n%matplotlib inline\r\n\r\nplt.figure(figsize=(10,10),dpi=80)\r\n# plt.bar([i for i in range(10)],[j for j in range(10)],x_label=\"x轴\")\r\n\r\nplt.bar([i for i in range(10)],[j for j in range(10)],color=\'b\',width=0.2) #(x,y,图例说明)\r\nplt.bar([i+0.2 for i in range(10)],[j for j in range(10)],color=\'r\',width=0.2)\r\n\r\n\r\nplt.xticks([i+0.1 for i in range(10)],[\"i的值为{}\".format(i) for i in range(10)])   #前面的是实际的x轴数据,后面是所修改的x,y刻度,这里向右平移0.1使其恰好居中\r\nplt.xlabel(\"x轴上所加的标签\")          #用字符串指代x轴所加标签\r\nplt.grid()       #添加网格,这个没什么可说的\r\n\r\n#plt.legend()       #这个要与绘制图像的Api一起使用,之后会提到\r\n\r\nplt.show()\r\n```\r\n####直方图:一段连续范围内各数所占的比例\r\n```python\r\nplt.hist(x,bin)  #normed==true为显示频率\r\n# bin为所分的组数,可以以下形式求\r\nl=[i for i in range(10)]\r\ndistance=1   #设置组距\r\nbin=(max(l)-min(l))/distance\r\nplt.xticks(x[::distance])\r\n```\r\n####饼图---占比\r\n函数格式:```python\r\ndef pie(x, explode=None, labels=None, colors=None, autopct=None,\r\n        pctdistance=0.6, shadow=False, labeldistance=1.1, startangle=None,\r\n        radius=None, counterclock=True, wedgeprops=None, textprops=None,\r\n        center=(0, 0), frame=False, rotatelabels=False, hold=None, data=None)\r\n```\r\nx为x轴(自动生成占比)\r\nlabels为每部分的标签\r\ncolors为颜色\r\nautopct为保留的位数%1.2ff%%\r\n```python\r\nplt.pie(x,labels=[i for i in x],autopct=\'%1.2f%%\')\r\n```\r\n\r\n![](http://q7xlyvqgm.bkt.clouddn.com/9)',b'1','最近为了开学的大创,在学习一点python数据挖掘相关的内容,简单地看黑马\r\n的视频学了一点点的matplotlab.....感觉这一块还是不难的,大概就是调ap\r\ni吧,具体使用还是要多用得好\r\n至于什么是matplotlab,为什么要使用matplotlab这里就不细说了....',b'0',2,NULL,NULL),(105,2,'2020-04-02 00:00:00','leetcode 57插入区间','http://img.xuhaobo.site/88',9,'>*好久没刷算法题了......\r\n乍一刷有点自闭........\r\n虽说代码写出来了吧但是感觉还是不太好*\r\n\r\n题意如下:给出一个无重叠的 ，按照区间起始端点排序的区间列表。\r\n\r\n在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。\r\n![](http://img.xuhaobo.site/88)\r\n\r\n```java\r\nclass Solution {\r\n    public static boolean contains(int []insert,int []tocheck)\r\n    {\r\n        if((insert[0]<=tocheck[0]&&insert[1]<=tocheck[1]&&insert[1]>=tocheck[0])||\r\n        (insert[1]>=tocheck[1]&&insert[0]>=tocheck[0]&&insert[0]<=tocheck[1])||(insert[1]>=tocheck[1]&&insert[0]<=tocheck[0]))\r\n        {\r\n            return true;\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }\r\n```\r\n\r\n```java\r\npublic int[][] insert(int[][] intervals, int[] newInterval) {\r\n        if(intervals==null||intervals.length==0)\r\n        {\r\n            System.out.println(1);\r\n            int [][] b=new int[1][2];\r\n            b[0]=newInterval;\r\n            return b;\r\n        }\r\n        else if(intervals.length!=0){\r\n            List<int[]> anw=new ArrayList<>();   //存储最终结果\r\n            int[] tochange=new int[2];       //中间由于插入数组发生变化的数组\r\n            boolean flag=false;                //记录重叠状态\r\n            boolean hasContain=false;   //判断是否重叠过\r\n            for(int i=0;i<intervals.length;i++)\r\n            {\r\n                if(contains(newInterval,intervals[i])==true)       //若判断包含关系则开始更新\r\n                {\r\n                    System.out.println(flag);\r\n                    hasContain=true;   //证明有重叠过\r\n                    if(flag==true)\r\n                    {\r\n                        if(tochange[1]<=intervals[i][1])\r\n                        {\r\n                            tochange[1]=intervals[i][1];\r\n                        }\r\n                    }\r\n                    else if(flag==false)\r\n                    {\r\n                        tochange=intervals[i];\r\n                        if(tochange[0]>=newInterval[0])\r\n                    {\r\n                        tochange[0]=newInterval[0];\r\n                    }\r\n                    if(tochange[1]<=newInterval[1])\r\n                    {\r\n                        System.out.println(tochange[1]);\r\n                        tochange[1]=newInterval[1];\r\n                    }\r\n\r\n                        flag=true;         //进入检验重叠的模式中\r\n                    }\r\n                }\r\n                else{\r\n                    if(flag==true)   //之前有在重叠模式里的元素就先加进去,不重叠的元素一定加进去\r\n                    {\r\n                        anw.add(tochange);\r\n                        flag=false;\r\n                    }\r\n                    anw.add(intervals[i]);\r\n                }\r\n            }\r\n                    if(flag==true)   //之前有在重叠模式里的元素就先加进去,不重叠的元素一定加进去\r\n                    {\r\n                        anw.add(tochange);\r\n                        flag=false;\r\n                    }\r\n            if(hasContain==false)       //从未发生过重叠则要根据之前的结果进行插入\r\n            {\r\n                for(int i=0;i<anw.size();i++)\r\n                {\r\n                    if(i==0&&anw.get(i)[0]>newInterval[1])\r\n                    {\r\n                       anw.add(0,newInterval);\r\n                        break;\r\n                    }\r\n                    if(i==anw.size()-1&&anw.get(i)[1]<newInterval[0])\r\n                    {\r\n                        anw.add(newInterval);\r\n                        break;\r\n                    }\r\n                    else if(anw.get(i)[1]<newInterval[0]&&anw.get(i+1)[0]>newInterval[1])\r\n                    {\r\n                        anw.add(i+1,newInterval);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            int [][]retArray=new int[anw.size()][2];\r\n            for(int i=0;i<anw.size();i++)\r\n            {\r\n                retArray[i]=anw.get(i);   //移入一个二维数组中去\r\n            }\r\n            return retArray;\r\n        }\r\n        return null;\r\n    }\r\n    \r\n}\r\n```\r\n\r\n........\r\n```',b'1','好久没刷算法题了......\r\n乍一刷有点自闭........\r\n虽说代码写出来了吧但是感觉还是不太好',b'0',2,NULL,NULL),(106,8,'2020-04-02 00:00:00','spring boot解决文件存储的虚拟路径问题','http://img.xuhaobo.site/89',12,'*我们都知道,有些大文件我们无法放入数据库中,需要在数据库中存储存储路径而在本机中去获取,很多企业有自己的文件服务器,我在新血来潮想开发音乐网站的过程中就遇到了相关的问题.......y1s1,有点酸爽......找了半天csdn....也算是终于找到相关的地址了....项目还在接着开发,目前也只是找到了windows的解决方案....linux等部署的时候更新吧23333*\r\n\r\n我参考的csdn文章是:\r\n\r\n&emsp;&emsp;首先说一下需求:就是从前端传文件到后端,之后后端通过输入输出流存储文件到指定路径,之后存储到本地,随后访问前端时后端把本地地址给前端,(这里看着是tm挺简单的),这里可能有的网站说前端src可以用file://获取本地文件,但事实上很多浏览器现在已经开始不支持访问本地文件了,我们如果想要访问本地文件,所以我们需要配置一个类能够建立本地文件与前端uri的映射,这样虽然看似套上了uri的壳,但我们依然可以获取本地文件了\r\n\r\n核心的java配置类代码如下:\r\n```java\r\n    @Configuration\r\n    public class FileConfig extends WebMvcConfigurerAdapter {\r\n    \r\n        public static String filePath=\"D:\\\\music\\\\\"; //配置的本地物理保存地址\r\n    \r\n    \r\n        //核心的配置方法,实现映射,我们可以理解成:/file/文件名请求路径   实质指的是 file:///D:/music/文件名\r\n        @Override\r\n        public void addResourceHandlers(ResourceHandlerRegistry registry) {\r\n           registry.addResourceHandler(\"/file/**\").addResourceLocations(\"file:///\"+filePath);\r\n           super.addResourceHandlers(registry);\r\n        }\r\n    \r\n    \r\n        //自己写的将文件名转化为uri的方法\r\n        public static String getURI(String str)\r\n        {\r\n            return \"/file/\"+str;\r\n        }\r\n    \r\n    \r\n    }\r\n```\r\n\r\n这样我们就可以通过请求路径来实现访问本地数据了\r\n实际存储到数据库,前端的src都是转化后的请求路径即可\r\n\r\n这里也贴一下前端的代码\r\n前端用的是thymeleaf模板渲染的技术\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\" xmlns:th=\"http://www.w3.org/1999/xhtml\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n</head>\r\n<body>\r\n\r\n<!--html5 audio 从后端取src-->\r\n\r\n<audio th:if=\"${musics}\" th:each=\"music:${musics}\" controls=\"controls\" th:src=\"@{${music.uri}}\">\r\n    Your browser does not support the audio element.\r\n</audio>\r\n\r\n<!--文件上传表单,注意这里一定要加 enctype=\"multipart/form-data\"属性-->\r\n\r\n<form method=\"post\" action=\"upload\" enctype=\"multipart/form-data\">\r\n    <input type=\"file\" name=\"file\" accept=\"music/*\"/><br>\r\n    <input name=\"name\" placeholder=\"请输入歌曲名\"/><br>\r\n    <input name=\"style\" placeholder=\"请输入歌曲风格\"/><br>\r\n    <input name=\"singer\" placeholder=\"请输入歌手名\"/><br>\r\n    <input type=\"submit\">\r\n</form>\r\n\r\n\r\n</body>\r\n</html>\r\n```',b'1','我们都知道,有些大文件我们无法放入数据库中,需要在数据库中存储存储路径而在本机中去获取,很多企业有自己的文件服务器,我在新血来潮想开发音乐网站的过程中就遇到了相关的问题.......y1s1,有点酸爽......找了半天csdn....也算是终于找到相关的地址了....项目还在接着开发,目前也只是找到了windows的解决方案....linux等部署的时候更新吧23333',b'0',2,NULL,NULL),(107,15,'2020-04-02 00:00:00','Numpy ndarray数组的生成以及相关修改操作','https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3890848816,3171555074&fm=26&gp=0.jpg',18,'*大概可以分为四类:\r\n1.生成指定数字的数组\r\n2.从原有数组中生成数组(分深拷贝和浅拷贝两类)\r\n3.生成成正态分布和均匀分布的随机数数组\r\n4.生成一定范围的等差数列*\r\n\r\n\r\n```python\r\nimport matplotlib.pyplot as plt\r\nimport random\r\nimport numpy as np\r\n%matplotlib inline\r\n#生成数组(指定0和1)\r\narray1=np.zeros(20)         \r\nprint(array1)\r\narray2=np.ones((10,10))  #传入shape元组\r\nprint(array2)\r\n#生成数组(均匀分布和正态分布)\r\nnp.random.uniform(0,1,size=(100,100))                #(low,hign,size)\r\nprint(np.random.normal(1,2,size=(100,100)))          #正态分布(平均值,标准差,)\r\n\r\n#生成数组(从现有拷贝中生成)\r\narray2=np.array([[1,2,3],[4,5,6]])    #深拷贝\r\narray1=np.asarray(array2)             #浅拷贝\r\nprint(array2==array1)\r\n\r\n#从固定范围内生成数组\r\nprint(np.linspace(0,1,5))               #生成一个数到另一个数的等差数列(start,end,等差数列中的数字个数)\r\nprint(np.arange(0,5,2))                 #同样还是生成一个数到另一个数的等差数列(start,end,等差数列的步长值)\r\n\r\n```\r\n\r\n\t数组的相关修改操作,由于修改后修改的是对象,所以采用 对象.方法()的形式进行修改\r\n```python\r\nimport matplotlib.pyplot as plt\r\nimport random\r\nimport numpy as np\r\n%matplotlib inline\r\n#修改数组形状(因为是修改一个对象,所以这里都直接采用对象.方法而非np.函数的方式进行操作)\r\narray1=np.array([[1,2,3],[1,1,1]])\r\narray2=array1.reshape((3,-1))     #reshape不能改变其本身在内存中的大小,因此形状的乘积,面积不同\r\nprint(array2)\r\nprint(array2.T)\r\n#修改数组的类型\r\nprint(array2.dtype)\r\nprint(array2.astype(\"float32\").dtype)\r\nprint(array2.tostring())   #序列化(哪天专门再写个文章说一下序列化吧哈哈哈)\r\nprint(np.unique(array2))\r\n```',b'1','大概可以分为四类:\r\n1.生成指定数字的数组\r\n2.从原有数组中生成数组(分深拷贝和浅拷贝两类)\r\n3.生成成正态分布和均匀分布的随机数数组\r\n4.生成一定范围的等差数列',b'0',2,NULL,NULL),(108,20,'2020-04-04 00:00:00','王爽<<汇编语言>>实验一','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',0,'>看完csapp后(其实自己太菜太渣lab做不下去了之后)自己打算开始学习操作系统方面的知识,自己本身对于操作系统算是比较感兴趣吧,但是自己在上哈工大李治军老师的OS课时发现了8086汇编代码.....(我TM只能看懂x86-64的皮毛),于是便展开了王爽这本书的学习......\r\n\r\n前几章和实验一的内容个人觉得其实东西并不多,大概和x86-64的区别就在于着重说了段寄存器cs和指令寄存器ip\r\n我们可以姑且理解为:地址=cs左移一位+ip的值\r\n好了步入正题我们来说**实验**:\r\n\r\n\t(1)(2)其实都是在考关于dos的使用,这里比较坑的地方就是win10去掉了貌似xp和win7都用的DOS debug,不过我们可以通过安装实验环境来进行\r\n\r\n（3）第三问要求在ROM区寻找一个生产日期,我大概认为我找到的是这个地址所存\r\n的内存块的值:\r\n\r\n(或许是看着像吧.....)\r\n可以分析出第一个图这里存储的**\"30\",\"31\"**就是后面所实际acsii码对应的01而\"/\"则是哪个2F\r\n\r\n随后我试图修改了一下这个地址的数据值\r\n这里可以看出我把那个01应该修改成了\"12\"\r\n接下来我再查询地址\r\n发现与之前的内存单元所存值相等.后来注意到了题干的**\"ROM\"**\r\nROM是只读访问存储器不可更改(我又懂了)\r\n补充:ROM所对应的虚拟内存地址为A000H~FFFFH\r\n\r\n（4)\r\n首先依据题干向指定内存写入值:\r\n\r\n发现居然出现了这么个小图案\r\n\r\n修改一下输入试试~~~\r\n\r\n图案颜色也在发生变化\r\n\r\n所运用的知识:在8086pc机的内存地址空间分配中\r\n规定了A0000~BFFFF为显存\r\n向显存中写数据会直接被显示卡输出到显示器上\r\n![](http://img1.imgtn.bdimg.com/it/u=580104775,186890874&fm=15&gp=0.jpg)',b'1','看完csapp后(其实自己太菜太渣lab做不下去了之后)自己打算开始学习操作系统方面的知识,自己本身对于操作系统算是比较感兴趣吧,但是自己在上哈工大李治军老师的OS课时发现了8086汇编代码.....(我TM只能看懂x86-64的皮毛),于是便展开了王爽这本书的学习......',b'0',2,NULL,NULL),(109,2,'2020-04-04 00:00:00','[leetcode]42. 接雨水','http://img.xuhaobo.site/21',9,'*leetcode新出的每日一题这个栏目快给我强迫症都梭出来了.....\r\n今天的每日一题所考察的的算法是单调栈,也是每日一题里目前少数的几个\"困难\"*\r\n\r\n参考了雪姨的题解\r\nhttps://leetcode-cn.com/problems/trapping-rain-water/solution/dan-diao-zhan-jie-jue-jie-yu-shui-wen-ti-by-sweeti/\r\n接下来先分析一下问题:![](http://img.xuhaobo.site/19)\r\n可以看到它接雨水的轮廓大概就是向向下再往上升的过程\r\n所以.....好吧我没接触过单调栈看题解才今天勉强学会了一点....\r\n我们可以根据栈的特点,将水的不规则体积(好像也挺规则)化成一个个规则矩形\r\n大概就是去维护一个降序的栈一旦有升序的情况我们可以理解成这里就可以分出了一个\r\n![](http://img.xuhaobo.site/20)\r\n的思路\r\n\r\n对于面积高的运算:\r\n一旦遍历到一个不符合降序的值随后\r\n开始外层遍历直到遍历到符合栈顶大于height[i]\r\n出栈(这个值最终被减去)\r\n同时也将维护的递减栈里和它相等的数一律出栈(我们只需要求一个值用于求高)\r\n通过比较它左边的值与该不符合降序的值(也就是height[i])比较出比较小的一个\r\n求出高(能留下雨水的取小的),随后用这个高减去那个被出栈的之前留下的height值\r\n\r\n对于底的运算:右边下标-被搜寻到的小的数左下标-1\r\n\r\n随后累加\r\n```java\r\nclass Solution {\r\n    public int trap(int[] height) {\r\n        Stack<Integer> s=new Stack<>();\r\n        int anw=0;\r\n        for(int i=0;i<height.length;i++)\r\n        {\r\n            while(!s.isEmpty()&&height[i]>height[s.peek()])\r\n            {\r\n                int index=s.pop();\r\n                while(!s.isEmpty()&&height[s.peek()]==height[index])      \r\n                {\r\n                    s.pop();              //后面相等的全都出栈\r\n                }\r\n                if(!s.isEmpty())\r\n                {\r\n                    anw+=(i-s.peek()-1)*(Math.min(height[s.peek()],height[i])-height[index]);\r\n                }\r\n            }\r\n            s.push(i);\r\n        }\r\n        return anw;\r\n    }\r\n}\r\n```',b'1','leetcode新出的每日一题这个栏目快给我强迫症都梭出来了.....\r\n今天的每日一题所考察的的算法是单调栈,也是每日一题里目前少数的几个\"困难\"',b'0',2,NULL,NULL),(110,20,'2020-04-05 00:00:00','王爽<<汇编语言>>实验二&&第三章总结','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',7,'``*第三章依然是寄存器的内容,不过涉及了内存的部分，个人对于关于栈满后究竟是覆盖栈段内容还是栈以外的内存部分还是有点懵逼 。。。。:tw-1f436:*\r\n\r\n检测点3.1:\r\n 1.这里大概注意一下段寄存器里是一不是零就好了,所以数据是从第二行开始读起\r\n 的而并非第一行,这个算是要着力重视的一个点,另外就是第三问\"add al,bl\"要看清楚寄存器的种类,比方说是AX,AH还是AL\r\n2.其实也没什么好说的,我之前理解错了过程:tw-1f637: :tw-1f637:,做完体会就是在8086中指令按顺序执行时,改变的是ip的值(ip+=指令段长度)\r\n实验部分:\r\n(1)比较简单,就是熟悉下程序出栈入栈的过程,敲一遍就完事了~~~\r\n![](http://img.xuhaobo.site/22)\r\n(2)\r\n![](http://img.xuhaobo.site/23)\r\n 第二问我自己每一步都在Debug中看了一下2000:0的变化,得出了如下图的分析:\r\n ![](http://img.xuhaobo.site/24)\r\n ![](http://img.xuhaobo.site/25)\r\n ![](http://img.xuhaobo.site/26)\r\n 我们可以理解着在栈中不仅保存着我们所存储的数据,还有当前指令的CS,IP值以及其段地址所对应寄存器的值\r\n 个人目前只能理解到这一步了哈哈哈哈',b'1','第三章依然是寄存器的内容,不过涉及了内存的部分，个人对于关于栈满后究竟是覆盖栈段内容还是栈以外的内存部分还是有点懵逼 。。。。',b'0',2,NULL,NULL),(111,2,'2020-04-05 00:00:00','[leetcode]460. LFU缓存','http://img.xuhaobo.site/120',2,'*wdnmd太难了,写了个性能极差的算法,以及一个代码层面完全看不懂的实现，我是个菜鸡*\r\n提供个自己或许只能这么写能写出来的java辣眼睛烂代码版本\r\n```java\r\nclass LFUCache {\r\n\r\n    int minKey=-1;\r\n    int minValue=Integer.MAX_VALUE;\r\n    int size;\r\n    TreeMap<Integer,LinkedList<Integer>>m=new TreeMap<>();    //key为使用次数\r\n    Map<Integer,Integer>count=new HashMap<>();           //实际次数\r\n    Map<Integer,Integer>cache=new HashMap<>();           //实际缓存\r\n\r\n    void checkAndchange(int last,int key)                                //根据访问数的修改对TreeMap进行操作\r\n    {\r\n        LinkedList<Integer>list=m.get(last);\r\n        for(int i=0;i<list.size();i++)\r\n        {\r\n            if(list.get(i)==key)\r\n            {\r\n                list.remove(i);\r\n                break;\r\n            }\r\n        }\r\n        int count=last+1;\r\n        if(m.get(count)!=null)              //本身不存在\r\n        {\r\n            m.get(count).add(key);               //这里我试试行不行 \r\n        }else\r\n        {\r\n            list=new LinkedList<Integer>();\r\n            list.add(key);\r\n            m.put(count,list);\r\n        }\r\n    }\r\n\r\n    int getMin()\r\n    {\r\n        Integer firstKey=null;\r\n        for(Integer key:m.keySet())\r\n        {\r\n            if(m.get(key).size()>0)\r\n            {\r\n                firstKey=key;\r\n                break;\r\n            }\r\n        }\r\n        if(firstKey==null)\r\n        {\r\n            return Integer.MIN_VALUE;\r\n        }\r\n        LinkedList<Integer> list=m.get(firstKey);\r\n        int anw=list.getFirst();\r\n        list.removeFirst();\r\n        if(list.size()==0)\r\n        {\r\n            m.remove(firstKey);//删除列表\r\n        }\r\n        return anw;\r\n    }\r\n\r\n    public LFUCache(int capacity) {\r\n        this.size=capacity;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if(cache.get(key)!=null)     //本身存在\r\n        {\r\n            int last=count.get(key);\r\n            count.put(key,last+1);    //查询一次加一一次\r\n            checkAndchange(last,key);\r\n            System.out.println(\"查询\"+key+\"返回\"+cache.get(key));\r\n            return cache.get(key);  \r\n        }else{\r\n            System.out.println(\"返回\"+\"-1\"+\"未找到\"+key);\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if(size==0)\r\n        {\r\n            return;\r\n        }\r\n        if(cache.get(key)!=null)\r\n        {\r\n            cache.put(key,value);\r\n            int last=count.get(key);\r\n            count.put(key,last+1);    //查询一次加一一次\r\n            checkAndchange(last,key);\r\n        }else{\r\n            if(cache.size()==size)\r\n            {\r\n                int num=getMin();\r\n                if(num!=Integer.MIN_VALUE)\r\n                {\r\n                    cache.remove(num);\r\n                }\r\n            }\r\n            cache.put(key,value);\r\n            count.put(key,1);\r\n            LinkedList<Integer> list=m.get(1);\r\n            if(list==null)\r\n            {\r\n                list=new LinkedList<Integer>();\r\n            }\r\n            list.add(key);\r\n            m.put(1,list);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your LFUCache object will be instantiated and called as such:\r\n * LFUCache obj = new LFUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n```',b'1','wdnmd太难了,写了个性能极差的算法,以及一个代码层面完全看不懂的实现，我是个菜鸡\r\n提供个自己或许只能这么写能写出来的java辣眼睛烂代码版本~~~~',b'0',2,NULL,NULL),(112,2,'2020-04-06 00:00:00','[leetcode]72. 编辑距离','https://dss0.baidu.com/73F1bjeh1BF3odCf/it/u=609327264,1583315288&fm=85&s=29F5C706C4A784A42FA653320300F05B',1,'*今天出去玩了有点累状态不太好,自己动态规划也学得自认为不是很熟悉.....看过题解草草理解就写了一遍.....*\r\n\r\n具体参考文章\r\nhttps://leetcode-cn.com/problems/edit-distance/solution/zi-di-xiang-shang-he-zi-ding-xiang-xia-by-powcai-3/\r\n就这样吧睡了睡了\r\n**题目如下:**\r\n\r\n**> 代码如下:**\r\n```java\r\nclass Solution {\r\n    public int minDistance(String word1, String word2) {\r\n        if(word1.length()==0||word2.length()==0)\r\n        {\r\n            return word1.length()==0?word2.length():word1.length();\r\n        }\r\n        int [][]edit=new int[word1.length()+1][word2.length()+1];\r\n        \r\n        for(int i=0;i<=word1.length();i++)\r\n        {\r\n            edit[i][0]=i;\r\n        }\r\n        for(int j=0;j<=word2.length();j++)\r\n        {\r\n            edit[0][j]=j;\r\n        }\r\n\r\n        for(int i=1;i<=word1.length();i++)\r\n        {\r\n            for(int j=1;j<=word2.length();j++)\r\n            {\r\n                    if(word1.charAt(i-1)==word2.charAt(j-1))\r\n                    {\r\n                        edit[i][j]=edit[i-1][j-1];\r\n                    }\r\n                    else{\r\n                        edit[i][j]=Math.min(Math.min(edit[i-1][j-1],edit[i-1][j]),edit[i][j-1])+1;\r\n                    }\r\n            }\r\n        }\r\n        return edit[word1.length()][word2.length()];\r\n    }\r\n}\r\n```',b'1','今天出去玩了有点累状态不太好\r\n自己动态规划也学得自认为不是很熟悉.....\r\n看过题解草草理解就写了一遍.....\r\n具体参考文章\r\nhttps://leetcode-cn.com/problems/edit-distance/solution/zi-di-xiang-shang-he-zi-ding-xiang-xia-by-powcai-3/\r\n就这样吧睡了睡了',b'0',2,NULL,NULL),(113,8,'2020-04-07 00:00:00','对于mybatis对于一对多复合对象进行PageHelper分页的解决方案','https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=848859921,2201379319&fm=26&gp=0.jpg',14,'*最近在维护更新这个博客系统的过程中,发现了对于包含时间以及其对应的博客数的时间轴对象的分页查询中,不能够按照\"时间\"进行正确的分页,这里提供下踩过坑之后的解决方案~~~*\r\n\r\n\r\n\r\n```java\r\npublic class TimeLine {\r\n    private Date time;         //哪一天\r\n    private List<Article> articleList;\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"TimeLine{\" +\r\n                \"time=\" + time +\r\n                \", articleList=\" + articleList +\r\n                \'}\';\r\n    }\r\n\r\n    public Date getTime() {\r\n        return time;\r\n    }\r\n\r\n    public void setTime(Date time) {\r\n        this.time = time;\r\n    }\r\n\r\n    public List<Article> getArticleList() {\r\n        return articleList;\r\n    }\r\n\r\n    public void setArticleList(List<Article> articleList) {\r\n        this.articleList = articleList;\r\n    }\r\n}\r\n```\r\n首先这是我们要查询的timeStamp对象,我们的目的是在按照time字段进行分页\r\n\r\n![这是article表的字段信息,我们接下来的查询都基于这张表进行](http://img.xuhaobo.site/29 \"这是article表的字段信息,我们接下来的查询都基于这张表进行\")\r\n\r\n如下是之前进行左连查询最后返回对象的mybatis xml文件\r\n这种查询方式**不能**正确地返回我们想要得到的结果\r\n不能够按照createTime进行分页\r\n\r\n```xml\r\n<resultMap id=\"timeLines\" type=\"com.example.xhbblog.pojo.TimeLine\">\r\n    <result column=\"createTime\" property=\"time\"/>\r\n    <collection property=\"articleList\" ofType=\"com.example.xhbblog.pojo.Article\">\r\n      <id column=\"id\" property=\"id\"/>\r\n      <result column=\"title\" property=\"title\"/>\r\n      <result column=\"content\" property=\"content\"/>\r\n    </collection>\r\n  </resultMap>\r\n\r\n  <select id=\"findTimeLines\" resultMap=\"timeLines\">\r\n    select a1.createTime,a2.id,a2.title,a2.content from article a1\r\n    left join article a2 ON a2.createTime=a1.createTime\r\n    where a1.published=true and a2.published=true\r\n    order by a1.createTime desc\r\n  </select>\r\n```\r\n\r\n百度后看到这种查询目前在mybatis中不能使用左连查询,必须使用子查询实现\r\n同时要使用**DISTINCT**关键字查询时间,不然会查出重复的时间从而重复查询\r\n\r\nxml解决方案如下:\r\n```xml\r\n  <resultMap id=\"timeLines\" type=\"com.example.xhbblog.pojo.TimeLine\">\r\n    <result column=\"createTime\" property=\"time\"/>\r\n    <collection property=\"articleList\" ofType=\"com.example.xhbblog.pojo.Article\" select=\"getArticlesByTime\" javaType=\"java.util.List\" column=\"{createTime=createTime}\">\r\n      <result column=\"id\" property=\"id\"/>\r\n      <result column=\"title\" property=\"title\"/>\r\n    </collection>\r\n  </resultMap>\r\n\r\n  <select id=\"findTimeLines\" resultMap=\"timeLines\" parameterType=\"map\">\r\n    select  DISTINCT createTime from article order by createTime\r\n  </select>\r\n\r\n  <select id=\"getArticlesByTime\" parameterType=\"map\"\r\n          resultType=\"map\">\r\n    select id,title from article a2 where a2.createTime=#{createTime}\r\n  </select>\r\n\r\n```\r\n\r\n\r\n\r\n注解解决方案如下:\r\n```java\r\n  @Select(\"select DISTINCT createTime from article where published=true order by createTime DESC\")\r\n    @Results({\r\n            @Result(property = \"time\",column = \"createTime\"),\r\n            @Result(property = \"articleList\",column = \"createTime\",one=@One(select = \"com.example.xhbblog.mapper.ArticleMapper.selectByCreateTime\"))\r\n    })\r\n    List<TimeLine> findTimeLines();      //时间轴查询\r\n\r\n    @Select(\"select id,title from article where published=true and createTime=#{createTime}\")\r\n    @Results({\r\n            @Result(property = \"id\",column = \"id\"),\r\n            @Result(property = \"title\",column = \"title\")\r\n    })\r\n    List<Article> selectByCreateTime(Date createTime);\r\n```\r\n个人踩坑经历如上~~~',b'1','最近在维护更新这个博客系统的过程中,发现了对于包含时间以及其对应的博客数的时间轴对象的分页查询中,不能够按照\"时间\"进行正确的分页,这里提供下踩过坑之后的解决方案~~',b'0',2,NULL,NULL),(114,2,'2020-04-07 00:00:00','[leetcode]面试题 01.07. 旋转矩阵','http://img.xuhaobo.site/31',1,'>*今天的每日一题算是放在前几天的**\"劝退三板斧\"**里比较轻松的一道了,如果自己使用额外的内存应该是很容易实现的,现在我们说一下不使用额外内存的方法*\r\n\r\n\t本来自己想了半天想到了一个类似于顺时针旋转的方法但是没有找到规律最后还是取看题解了.......还是太菜惹的祸哈哈哈哈\r\n\r\nleetcode题目如下:\r\n![](http://img.xuhaobo.site/31)\r\n\r\njava实现代码如下\r\n\r\n```java\r\nclass Solution {\r\n    public void rotate(int[][] matrix) {\r\n        if(matrix.length<=1)\r\n        {\r\n            return;\r\n        }\r\n        //将矩阵转置\r\n        for(int i=0;i<matrix.length;i++)\r\n        {\r\n            for(int j=i;j<matrix.length;j++)\r\n            {\r\n                if(i!=j)\r\n                {\r\n                    int tmp=matrix[i][j];\r\n                    matrix[i][j]=matrix[j][i];\r\n                    matrix[j][i]=tmp;\r\n                }\r\n            }\r\n        }\r\n        //将矩阵沿中心线转置\r\n        for(int i=0;i<matrix.length;i++)\r\n        {\r\n            for(int j=0;j<matrix.length/2;j++)\r\n            {\r\n                int tmp=matrix[i][j];\r\n                matrix[i][j]=matrix[i][matrix.length-j-1];\r\n                matrix[i][matrix.length-j-1]=tmp;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n代码比较易懂这里就不讲解了。。。\r\n参考的依然是雪姨的题解.....\r\n果然多简单的题想要做好都是难的\r\n啥时候自己也能这么有思路呢',b'1','今天的每日一题算是放在前几天的\"劝退三板斧\"里比较轻松的一道了,如果自己使用额外的内存应该是很容易实现的,现在我们说一下不使用额外内存的方法',b'0',2,NULL,NULL),(115,2,'2020-04-08 00:00:00','[leetcode]面试题13. 机器人的运动范围','http://img.xuhaobo.site/32',2,'>*算是我这段时间遇到的每日一题了比较实现简单的了,大体的思路就是深度优先搜索(应该广度也可以),之后用一个集合来去重,根据搜索条件进行筛选,不过测试结果在内存消耗上还可以,运行时间还是一言难尽,路漫漫其修远兮吧哈哈哈哈哈哈哈*\r\n\r\n题目如下:\r\n![](http://img.xuhaobo.site/32)\r\n\r\n代码如下,比较好理解这里不一一讲解了\r\n```java\r\nclass Solution {\r\n    Set<String> visited=new HashSet<>();      //用于判重\r\n    public int sum(int a)\r\n    {\r\n        int sum=0;\r\n        while(a>0)\r\n        {\r\n            sum+=a%10;\r\n            a/=10;\r\n        }\r\n        return sum;\r\n    }\r\n    public boolean overFlow(int x,int y,int m,int n)\r\n    {\r\n        return x>=0&&x<n&&y>=0&&y<m;\r\n    }\r\n    \r\n    public int DFS(int x,int y,int m,int n,int k)\r\n    {\r\n        System.out.println(x+\",\"+y);\r\n        visited.add(x+\",\"+y);\r\n        int sum=1;\r\n        int []a1={0,1,-1,0};\r\n        int []a2={1,0,0,-1};\r\n        for(int i=0;i<4;i++)\r\n        {\r\n            int x1=x+a1[i];\r\n            int y1=y+a2[i];\r\n            if(overFlow(x1,y1,m,n)==true&&sum(x1)+sum(y1)<=k&&!visited.contains(x1+\",\"+y1))\r\n            {\r\n                sum+=DFS(x1,y1,m,n,k);\r\n            }\r\n        }\r\n        return sum;\r\n    }\r\n    public int movingCount(int m, int n, int k) {\r\n        return DFS(0,0,m,n,k);\r\n    }\r\n}\r\n```',b'1','算是我这段时间遇到的每日一题了比较实现简单的了,大体的思路就是深度优先搜索(应该广度也可以),之后用一个集合来去重,根据搜索条件进行筛选,不过测试结果在内存消耗上还可以,运行时间还是一言难尽,路漫漫其修远兮吧哈哈哈哈哈哈哈',b'0',2,NULL,NULL),(116,20,'2020-04-08 00:00:00','王爽<<汇编语言>>实验四&&四,五章总结','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',9,'*实验三个人认为没什么难度,所以直接略过去了,下面着重说一下第五章的实验*\r\n\r\n1.比较简单,这里懒惰地略过了,反正和第二问一样~~\r\n2.代码如图:\r\n![](http://img.xuhaobo.site/33)\r\n这里循环体利用了数据为0~63,也就是一直都只占一个子节,所以直接传递bl过去就可以实现\r\n3.自己分析了一段时间,后来发现利用的也是一种\"我们存储的指令也同样可以被视为数据\"这样的思想,所以将ax设为cs寄存器所存储的程序段段地址,由于需要将\r\n**mov ax,4c00h**这条指令之前的指令转移,故我们需要**mov ax,4c00h**以及\r\n**int 21h**两条指令所存储带来的字节数,\r\n我们可以通过上一个程序来求出\r\n![](http://img.xuhaobo.site/34)\r\n可以算出所占子节总数为5\r\n这里有一个小技巧\r\n\"**cx在程序开始时默认存储程序的长度**\"\r\n又因为其他伪指令不被编译为机器码,由编译器执行形成描述信息入口地址,所以我们只需要将cx设置为原始的cx-5即可\r\n具体汇编代码如下:\r\n![](http://img.xuhaobo.site/35)',b'1','实验三个人认为没什么难度,所以直接略过去了,下面着重说一下第五章的实验\r\n\r\n1.比较简单,这里懒惰地略过了,反正和第二问一样~~\r\n2.代码如图:\r\n![](http://q7xlyvqgm.bkt.clouddn.com/33)\r\n这里循环体利用了数据为0~63,也就是一直都只占一个子节,所以直接传递bl过去就可以实现\r\n3.自己分析了一段时间,后来发现利用的也是一种\"我们存储的指令也同样可以被视为数据\"这样的思想,所以将ax设为cs寄存器所存储的程序段段地址,由于需要将\r\nmov ax,4c00h这条指令之前的指令转移,故我们需要mov ax,4c00h以及',b'0',2,NULL,NULL),(117,2,'2020-04-09 00:00:00','[leetcode]22. 括号生成','http://img.xuhaobo.site/36',9,'*今天的leetcode每日一题也是比较简单的,貌似有更好的算法,这里提供下自己的思路*\r\n\r\n大概就是简单的DFS回溯,这里用了一下通过判断左括号右括号的个数剪枝,因为我们自身根据题意可以推测出如果此时**左括号数少于右括号数**,那么一定不是**有效**的,而如果**左括号数多于总数的一半**,那么也一定不是有效的\r\n\r\n题目如下:\r\n![](http://img.xuhaobo.site/36)\r\njava实现的代码如下:\r\n```java\r\nclass Solution {\r\n    public void DFS(int n,int leftSize,int rightSize,String str,List<String> anw)\r\n    {\r\n        if(str.length()==2*n)\r\n        {\r\n            if(leftSize==rightSize)\r\n            {\r\n                anw.add(str);\r\n            }\r\n        }else{\r\n            if(leftSize>n)       //通过个数判断剪枝\r\n            {\r\n                return;\r\n            }\r\n            DFS(n,leftSize+1,rightSize,str+\"(\",anw);\r\n            if(leftSize>rightSize)\r\n            {\r\n                DFS(n,leftSize,rightSize+1,str+\")\",anw);\r\n            }            \r\n        }\r\n    }\r\n    public List<String> generateParenthesis(int n) {\r\n        List<String> anw=new ArrayList<>();\r\n        DFS(n,0,0,\"\",anw);        //起始的leftSize和rightSize均为0\r\n        return anw;\r\n    }\r\n}\r\n```\r\n\r\n运行结果:\r\n![](http://img.xuhaobo.site/37)\r\n用时上还可以,好像内存用得有点多',b'1','今天的leetcode每日一题也是比较简单的,貌似有更好的算法,这里提供下自己的思路\r\n大概就是简单的DFS回溯,这里用了一下通过判断左括号右括号的个数剪枝,因为我\r\n们自身根据题意可以推测出如果此时左括号数少于右括号数,那么一定不是\r\n有效的,而如果左括号数多于总数的一半,那么也一定不是有效的',b'0',2,NULL,NULL),(118,2,'2020-04-10 00:00:00','[leetcode]151. 翻转字符串里的单词','http://img.xuhaobo.site/38',11,'*今天的leetcode之前刷过,感觉难度不算很大,通过率低应该式边界问题卡得比较厉害导致的，总体就是把边界条件想全,那么问题就不大了,具体题目如下:*\r\n\r\n![](http://img.xuhaobo.site/38)\r\n提供一下之前写的java代码的版本:\r\n```java\r\nclass Solution {\r\n    public String reverseWords(String s) {\r\n        s=s.trim();\r\n        String []strs=s.split(\" \");\r\n        StringBuffer anw=new StringBuffer();\r\n        for(int i=strs.length-1;i>=0;i--)\r\n        {\r\n            if(strs[i].equals(\" \")==false)\r\n            {\r\n            strs[i]=strs[i].trim();\r\n            if(strs[i].length()==0)\r\n            {\r\n                continue;\r\n            }\r\n            anw.append(strs[i]).append(\" \");\r\n            }\r\n        }\r\n        return anw.toString().trim();\r\n    }\r\n}\r\n```\r\n这是原来代码的提交结果:\r\n![](http://img.xuhaobo.site/39)',b'1','今天的leetcode之前刷过,感觉难度不算很大,通过率低应该式边界问题卡得比较厉害导致的，总体就是把边界条件想全,那么问题就不大了,这里提供下java代码的版本,(主要是自己别的现在都不熟了就会写java哈哈哈)',b'0',2,NULL,NULL),(119,20,'2020-04-10 00:00:00','王爽<<汇编语言>>实验五','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',10,'*第六章总体内容不多,总体来讲就是对于汇编语言自己给内存划分栈,数据,和指令\r\n的相关内容,下面说一下对实验五的看法以及心得体会*\r\n\r\n（1）,（2）实验:\r\n\r\n大概就是熟悉一下划分段后的相关操作,值得说的地方就是第(2)题的第四问\r\n**如果段中的数据占N个子节,则程序加载后,该段实际占有的空间为多少子节?**\r\n(1)中的栈与数据的划分均为8字16子节,而其段寄存器值也是都相差1\r\n而(2)中的栈和数据均为2个字,也就是4字节,但其段寄存器值也是同样只相差1,因此我们应该可以得到一个普遍规律\r\n程序加载后,该段实际所占空间为**([N/16]+1)*16**个字节(*这里的[]的意义为小于该数的最小整数*)\r\n\r\n(3)实验\r\n前三问和之前一样的套路,没有什么难度\r\n第(4)问主要说的是end指定了程序的执行入口,也就是具体那一段程序被视作指令\r\n如果没有具体指定的话就会使得**cs寄存器段中所有的数据均被视为指令**\r\n**当执行程序的程序(command,debug)将我们定义的数据段也当作指令时就会出现问题**\r\n因此只有(3)中的程序cs段地址与指令地址重合,所以(3)仍然可以正确执行\r\n第五,六问就是做一点编码上的实际练习,注意一下第五问**分配的是字节单元**\r\n而非字单元\r\n第五问代码如下:\r\n![](http://img.xuhaobo.site/40)\r\n\r\n![](http://img.xuhaobo.site/41)\r\n第六问代码如下:\r\n![](http://img.xuhaobo.site/42)\r\n\r\n![](http://img.xuhaobo.site/43)',b'1','第六章总体内容不多,总体来讲就是对于汇编语言自己给内存划分栈,数据,和指令\r\n的相关内容,下面说一下对实验五的看法以及心得体会',b'0',2,NULL,NULL),(120,20,'2020-04-11 00:00:00','王爽<<汇编语言>>实验六','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',5,'*第七章大概讲述了几种比较复杂的访存方式(寻址方式)*\r\n\r\n与c语言二维数组或者结构比较学习就可以很快地掌握原理,同时通过这些寻址方式我们可以逐渐把原本看似零散的数据抽象为一个个数据结构,这里也体现了c语言数组访问的一些具体的细节\r\n\r\n用到的一个大小写变换比较有意思的地方:\r\n可以通过位运算\r\nand 设定某一位为0\r\nor  设定某一位为1（**二进制,and,or的数后面要加B**）\r\n之后通过or或者and直接控制ascii码范围从而改变大小写\r\n\r\n(1)这种上机调试自己走一遍就好,不多赘述了\r\n(2)程序代码为:\r\n![](http://img.xuhaobo.site/44)\r\n\r\n![](http://img.xuhaobo.site/45)\r\n\r\n在debug中查看运算结果:\r\n![](http://img.xuhaobo.site/46)',b'1','第七章大概讲述了几种比较复杂的访存方式(寻址方式)\r\n\r\n与c语言二维数组或者结构比较学习就可以很快地掌握原理,同时通过这些寻址方式我们可以逐渐把原本看似零散的数据抽象为一个个数据结构,这里也体现了c语言数组访问的一些具体的细节',b'0',2,NULL,NULL),(121,20,'2020-04-11 00:00:00','王爽<<汇编语言>>实验七','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',8,'*实验七应该算是一个小小的总结了吧,大概把之前用到的loop循环,各种访存方式都用了一下*\r\n\r\n\r\n编程思路:\r\n1.通过设置三个寄存器的值控制以及公司所有年份显示数据,被写入表,以及被读入雇员数的下标,之后循环遍历\r\n利用多种寻址方式进行运算,三个寄存器步长\r\n值分别为4，16，2\r\n\r\n**需要注意的点:这里被读入的雇员数一定要根据其基址以两个步长值与前面的年份,\r\n收入等分开,因为前面的数据均为4字节,所以每多遍历一个下标便下一次遍历多跳\r\n过一个雇员数**\r\n\r\n1.不能将平均数\r\n代码如下:\r\n前期数据准备:\r\n![](http://img.xuhaobo.site/47)\r\n\r\n![](http://img.xuhaobo.site/48)\r\n**执行指令**\r\n![](http://img.xuhaobo.site/49)\r\n\r\n![](http://img.xuhaobo.site/50)\r\n\r\n结果如下:![](http://img.xuhaobo.site/51)',b'1','实验七应该算是一个小小的总结了吧,大概把之前用到的loop循环,各种访存方式都用了一下\r\n\r\n\r\n编程思路:\r\n1.通过设置三个寄存器的值控制以及公司所有年份显示数据,被写入表,以及被读入雇员数的下标,之后循环遍历\r\n利用多种寻址方式进行运算,三个寄存器步长\r\n值分别为4，16，2',b'0',2,NULL,NULL),(122,20,'2020-04-14 00:00:00','王爽<<汇编语言>>第九章实验8&&实验9','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',16,'*不得不说这个转移指令本身理解上是挺容易的,做题上真的把我给雷到了哈哈哈哈\r\n*\r\n\r\n**基础知识:要注意jmp的关键字对应的转移范围,当转移范围超过所需范围时也会报错**\r\n\r\n## **实验八:**\r\n*本题大概就是理解jmp short指令相对寻址的特性*\r\n\r\n首先我通过debug试图在debug过程中找到规律\r\n![](http://img.xuhaobo.site/52)\r\n这里发现两个相对距离是相同的\r\n\r\n随后发现这里可以理解为,在运行过程中将s2的jmp指令复制到了s上,随后再次\r\n跳转到执行s时会去执行**jmp short s1**指令,而恰好其跳转的位置就是\r\n**mov ax,4cooh**,从而结束了程序的执行\r\n图示如下:\r\n![](http://img.xuhaobo.site/53)\r\n\r\n\r\n## **实验九:**\r\n*实验九算是花了我很长时间。。。。,之前一直试图将内层的两个loop写到一个loop里面,最终失败了...*\r\n\r\n大概的思路就是将我们要写的字符串写入指定的显存的偶数位，而具体的屏幕背景\r\n写入偶数位,中间还相关一个居中于屏幕的计算问题(我怀疑我列算错了)\r\n\r\n这个思路想想还算简单不过确实算是自己目前写的最复杂的汇编程序了\r\n\r\n**代码如下(这个博客系统集成的editor.md插件目前代码高亮显示没有汇编属实不太行)**\r\n\r\n    assume cs:codesg,ds:data,ss:stack\r\n    \r\n    data segment\r\n      db \'welcome to masm!\'\r\n      DB 00000010B,00100100B,01110001B\r\n    data ends\r\n    \r\n    stack segment\r\n     dw 32 dup(0)\r\n    stack ends\r\n    \r\n    codesg segment\r\n     start:MOV AX,0B800h\r\n           MOV ES,AX\r\n           MOV AX,DATA\r\n           MOV DS,AX\r\n           MOV BX,6e0h                          ;中间行\r\n           MOV DI,0\r\n           MOV CX,3\r\n           S:\r\n           PUSH CX\r\n           MOV SI,0\r\n           MOV CX,16\r\n    \t   \r\n               S0:MOV AL,DS:[SI]\r\n                  PUSH SI\r\n                  ADD SI,SI\r\n                  MOV ES:[BX+SI+70],AL          ;计算列\r\n                  POP SI\r\n                  INC SI\r\n                  LOOP S0\r\n    \r\n           MOV SI,1\r\n           MOV CX,16\r\n               S1:MOV AL,DS:[16+DI]\r\n                  MOV ES:[BX+SI+70],AL\r\n                  ADD SI,2\r\n                  LOOP S1\r\n    \r\n           POP CX\r\n           INC DI\r\n           ADD BX,0A0H\r\n           LOOP S\r\n    \r\n           MOV AX,4C00H\r\n           INT 21H\r\n    \r\n    codesg ends\r\n    end start\r\n\r\n程序运行结果如下:\r\n![](http://img.xuhaobo.site/54)',b'1','主要是对于实验的一些自己的代码\r\n不得不说这个转移指令本身理解上是挺容易的,做题上真的把我给雷到了哈哈哈哈\r\n基础知识:要注意jmp的关键字对应的转移范围,当转移范围超过所需范围时也会报错',b'0',2,NULL,NULL),(123,2,'2020-04-14 00:00:00','[leetcode]445. 两数相加 II','http://img.xuhaobo.site/80',3,'>这次的每日一题是之前用c++过的,这次用java重构了一下,大体思路有两种,一种是先将链表反转,另一种是将数值先存入栈中,再倒序输出,进行求和计算,并存储下一位的进位数,应该所谓的**进阶**方法就是第二种利用栈特性反转\r\n\r\n\r\n题目如下：\r\n![](http://img.xuhaobo.site/80)\r\n\r\n这里给出两种语言的进阶思路\r\n\r\n**c++:**\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\r\n        stack<int>S1;\r\n        stack<int>S2;\r\n        ListNode *p=l1;\r\n        ListNode *q=l2;\r\n        while(p)\r\n        {\r\n            S1.push(p->val);\r\n            p=p->next;\r\n        }\r\n        while(q)\r\n        {\r\n            S2.push(q->val);\r\n            q=q->next;\r\n        }\r\n        ListNode *L=NULL;\r\n        int tmp=0;\r\n        while(S1.size()&&S2.size())\r\n        {\r\n            ListNode *p=new ListNode((S1.top()+S2.top()+tmp)%10);\r\n            tmp=(S1.top()+S2.top()+tmp)/10;\r\n            S1.pop();\r\n            S2.pop();\r\n            p->next=L;\r\n            L=p;\r\n        }\r\n        while(S1.size())\r\n        {\r\n            ListNode *p=new ListNode((S1.top()+tmp)%10);\r\n            tmp=(S1.top()+tmp)/10;\r\n            S1.pop();\r\n            p->next=L;\r\n            L=p;\r\n        }\r\n        while(S2.size())\r\n        {\r\n            ListNode *p=new ListNode((S2.top()+tmp)%10);\r\n            tmp=(S2.top()+tmp)/10;\r\n            S2.pop();\r\n            p->next=L;\r\n            L=p;\r\n        }\r\n        if(tmp)\r\n        {\r\n            ListNode *p=new ListNode(tmp);\r\n            p->next=L;\r\n            L=p;\r\n        }\r\n        return L;\r\n    }\r\n};\r\n```\r\n\r\n**java**\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) { val = x; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\r\n        Stack<Integer> s1=new Stack<>();\r\n        Stack<Integer> s2=new Stack<>();\r\n        while(l1!=null)\r\n        {\r\n            s1.push(l1.val);\r\n            l1=l1.next;\r\n        }\r\n        while(l2!=null)\r\n        {\r\n            s2.push(l2.val);\r\n            l2=l2.next;\r\n        }\r\n        ListNode tmp=null;\r\n        int up=0;   //进位值 \r\n        while(!s2.isEmpty()||!s1.isEmpty())        //两栈都未空时\r\n        {\r\n            ListNode node=new ListNode();\r\n            node.next=tmp;\r\n            node.val=up;\r\n            if(!s1.isEmpty())\r\n            {\r\n                node.val+=s1.pop();\r\n            }\r\n            if(!s2.isEmpty())\r\n            {\r\n                 node.val+=s2.pop();\r\n            }\r\n            up=node.val/10;\r\n            node.val%=10;\r\n            tmp=node;\r\n        }\r\n        if(up!=0)\r\n        {\r\n            ListNode node=new ListNode();\r\n            node.val=up;\r\n            node.next=tmp;\r\n            tmp=node;\r\n        }\r\n        return tmp;\r\n    }\r\n}\r\n```',b'1','这次的每日一题是之前用c++过的,这次用java重构了一下,大体思路有两种,一\r\n种是先将链表反转,另一种是将数值先存入栈中,再倒序输出,进行求和计算,并存储\r\n下一位的进位数,应该所谓的进阶方法就是第二种利用栈特性反转',b'0',2,NULL,NULL),(124,20,'2020-04-15 00:00:00','王爽<<汇编语言>>第十章实验:三个子程序','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',9,'>*感觉汇编开始难起来了,写程序长起来就莫名有点慌.....还是高级语言好啊,感觉这几个代码写得很不好....先把字先码上吧哈哈哈*\r\n\r\n**大概内容就是写三个函数接口,这三个接口也同时起到让后面的程序调用同时实现代码复用的作用**\r\n\r\n### 1.显示字符串\r\n大概思路:这个差不多就是前面那个实验的一种变式吧,通过总结规律计算出行号,列号所对应的偏移,只是通过接口通用化了(当然了即使这样也花了我一个多小时)\r\n\r\n汇编代码如下:\r\n\r\n    assume cs:code\r\n    data segment\r\n      db \'welcome to masm!\',0\r\n    data ends\r\n    \r\n    code segment\r\n    start:mov dh,8\r\n    \t  mov dl,3\r\n    \t  mov cl,2\r\n    \t  mov ax,data\r\n    \t  mov ds,ax\r\n    \t  mov si,0\r\n    \t  call show_str\r\n    \t  \r\n    \t  mov ax,4c00h\r\n    \t  int 21h\r\n    \t  \r\n    show_str:\r\n    \t  \r\n    \t  mov ch,0\r\n    \t  ;确认输入的显存区域\r\n    \t  mov ax,0B800H\r\n    \t  mov es,ax\r\n    \t  \r\n    \t  ;计算对应的行\r\n    \t  mov bl,0A0h\r\n    \t  mov al,dh\r\n    \t  add al,-1\r\n    \t  mov ah,0\r\n    \t  mul bl\r\n    \t  mov di,ax        ;用di存储开始行以及开始列\r\n    \t  \r\n    \t  ;计算对应的列\r\n    \t  mov al,dl\r\n    \t  mov bx,2\r\n    \t  mul bl\r\n    \t  add al,-2\r\n    \t  mov ah,0\r\n    \t  add di,ax\r\n    \t  \r\n    \t  ;将文字输入\r\n    \t  s:mov ax,cx\r\n    \t\tmov cl,ds:[si]\r\n    \t    mov ch,0\r\n    \t    jcxz ok\r\n    \t\tmov es:[di],cl\r\n    \t\tmov cx,ax\r\n    \t\tmov es:[di+1],cl\r\n    \t    inc si\r\n    \t\tadd di,2\r\n    \t\tjmp s\r\n    \r\n    \t\tok:ret\r\n    \t  \r\n    \t  \r\n    code ends\r\n    end start\t \r\n\r\n测试结果如下:\r\n![测试成功!](http://q7xlyvqgm.bkt.clouddn.com/58 \"测试成功!\")\r\n\r\n### 2.解决除法溢出的问题\r\n大概思路:这个自己想的话难度非常大我觉得,看过公式就是通过写代码把那个公式实现吧(单单实现个公式我也是写得贼慢....)\r\n\r\n\r\n    assume cs:code\r\n    \r\n    code segment\r\n    start:mov ax,4240h\r\n    \t  mov dx,000fh\r\n    \t  mov cx,0ah\r\n    \t  call divdw\r\n    \t  mov ax,4c00h\r\n    \t  int 21h\r\n    \t  \r\n    divdw:\r\n    \t  mov si,ax             ;用si保存低位\r\n    \t  mov ax,dx\r\n    \t  mov dx,0\r\n    \t  div cx\r\n    \t  mov bx,ax         ;除得的商暂时存储到bx寄存器中\r\n    \t  mov dx,dx         ;除得的余数\r\n    \t  \r\n    \t  \r\n    \t  mov ax,si         ;将保存的低位返回\r\n    \t  div cx        ;执行后面的除法,此时高位低位都有了\r\n    \r\n    \t  mov cx,dx\r\n    \t  mov dx,bx\r\n    \t  ret\r\n    \t  \r\n    \t  \r\n    code ends\r\n    end start\r\n    \r\n    \r\n\r\n\r\n### 3.数值显示\r\n大概思路:先把字符串输入到数据段里去(**这里注意下其实算是倒着输入的**),之\r\n后调用前面所给的数据接口将数据段的数据显示\r\n\r\n这里说一下自己详细一点的过程吧(踩的坑有点多),一开始在想把数据段和栈段\r\n放在一起，之后发现了这句话\r\n![](http://img.xuhaobo.site/56)\r\n\r\n之后就自己手动地先把输出字符串长度求了出来,根据长度先写入后面的终止符0\r\n(**这里貌似不写也可以,我debug时发现这一段都是空的**)\r\n之后再进行倒序写入\r\n代码如下:(这里是后期测试的代码,所以加上了之前的接口)\r\n\r\n\r\n    assume cs:code\r\n    \r\n    \r\n    data segment\r\n     db 10 dup(0)\r\n    data ends\r\n    \r\n    code segment\r\n      start:mov ax,65535\r\n    \t\tmov bx,data\r\n    \t\tmov ds,bx\r\n    \t\tmov si,0\r\n    \t\tcall dtoc\r\n    \t\t\r\n    \t\tmov dh,8\r\n    \t\tmov dl,3\r\n    \t\tmov cl,2\r\n    \t\tcall show_str\r\n    \t\tmov ax,4c00h\r\n    \t\tint 21h\r\n      \r\n      \r\n      dtoc:\r\n    \t  mov di,ax\r\n    \t   ;计算字符串长度\r\n    \t   mov bx,0\r\n    \t   \r\n    \t   s1:mov cx,10\r\n    \t\t mov dx,0\r\n    \t     div cx\r\n    \t\t inc bx\r\n    \t\t mov cx,ax\r\n    \t\t jcxz write\r\n    \t\t jmp s1\r\n    \t\r\n    \t   ;开始写入到数据段中\r\n    \t   write:mov ax,di\r\n    \t\t\t mov byte ptr ds:[bx],0 \r\n    \t\t\t mov cx,bx\r\n    \t\t\t mov bx,cx\r\n    \t\t\t add bx,-1\r\n    \t\t\t mov si,10\r\n    \t\t\t s2:\r\n    \t\t\t\tmov dx,0\r\n    \t\t\t\tdiv si\r\n    \t\t\t\tmov dh,0\r\n    \t\t\t\tadd dl,30H\r\n    \t\t\t\tmov ds:[bx],dl\r\n    \t\t\t\tadd bx,-1\r\n    \t\t\t\tloop s2\r\n    \t\t\r\n    \t\tmov si,0\r\n    \t\tret\t\t\r\n    \t\t\r\n      show_str:\r\n    \t  \r\n    \t  mov ch,0\r\n    \t  ;确认输入的显存区域\r\n    \t  mov ax,0B800H\r\n    \t  mov es,ax\r\n    \t  \r\n    \t  ;计算对应的行\r\n    \t  mov bl,0A0h\r\n    \t  mov al,dh\r\n    \t  add al,-1\r\n    \t  mov ah,0\r\n    \t  mul bl\r\n    \t  mov di,ax        ;用di存储开始行以及开始列\r\n    \t  \r\n    \t  ;计算对应的列\r\n    \t  mov al,dl\r\n    \t  mov bx,2\r\n    \t  mul bl\r\n    \t  add al,-2\r\n    \t  mov ah,0\r\n    \t  add di,ax\r\n    \t  \r\n    \t  ;将文字输入\r\n    \t  s:mov ax,cx\r\n    \t\tmov cl,ds:[si]\r\n    \t    mov ch,0\r\n    \t    jcxz ok\r\n    \t\tmov es:[di],cl\r\n    \t\tmov cx,ax\r\n    \t\tmov es:[di+1],cl\r\n    \t    inc si\r\n    \t\tadd di,2\r\n    \t\tjmp s\r\n    \r\n    \t\tok:ret\r\n    \r\n    code ends\r\n    end start\r\n\r\n这里对我输入的数据做了下改变\r\n测试结果如下:\r\n![](http://img.xuhaobo.site/59)',b'1','感觉汇编开始难起来了,写程序长起来就莫名有点慌.....还是高级语言好啊,感觉这几个代码写得很不好....先把字先码上吧哈哈哈，\r\n大概内容就是写三个函数接口,这三个接口也同时起到让后面的程序调用同时实现代码复用的作用',b'0',2,NULL,NULL),(125,8,'2020-04-15 00:00:00','mybatis注解实现动态sql拼接','https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1586953045420&di=4d3663a7e9a654f43a24ab1727870a7b&imgtype=0&src=http%3A%2F%2Fimg2.imgtn.bdimg.com%2Fit%2Fu%3D2196685962%2C796489853%26fm%3D214%26gp%3D0.jpg',13,'>*今天再次给自己的博客后台系统更新了一波,自己在修改以往博客格式的过程中发现了自己在修改博客后总会返回第一页,就又要重复很多操作才能修改到下一篇我想要的,于是就更改了一下博客修改页,顺遍给博客列表页引入了**根据发布(草稿)状态进行筛选**的功能,在重写dao层mybatis代码时由于自己之前的mapper方法均是以注解的方式开发(对xml总感觉反感:tw-1f436:)于是便引出了今天的问题*\r\n\r\n首先我们看一下我之前想要达到的目标效果:\r\n\r\n直接进入后台系统模块(不做筛选地进行查询):\r\n![](http://img.xuhaobo.site/61)\r\n\r\n显示已发表状态(也就是访客可以看到)\r\n![](http://img.xuhaobo.site/60)\r\n\r\n显示未发表状态(我的草稿)\r\n![](http://img.xuhaobo.site/62)\r\n\r\n**这里表述的只是博客列表的需求,至于基于某标签下的博客或者某搜索结果下的博客道理相近,这里不细说了。**\r\n\r\n按照需求有三种状态:\r\n1.无筛选\r\n2.已发布\r\n3.草稿\r\n\r\n所以我们必须要动态地去拼接sql语句\r\nmybatis本身提供了**<if test=\'\'></if>**标签,本身我只对xml进行动态sq\r\nl有所了解\r\n其实基于注解的解决方案也很简单,只需要将拼接的字符放在\r\n**<script></script>**标签中即可实现\r\n\r\n这里的实际mapper实现如下\r\n```java\r\n    @Select(\"<script>\" +\r\n            \"select * from article\" +\r\n            \"<if test=\'published!=null\'>\"+\r\n            \"where published=#{published} \" +\r\n            \"</if>\"+\r\n            \"order by id desc\" +\r\n            \"</script>\")           //在注解中使用published动态拼接\r\n    @Results({\r\n            @Result(property = \"id\",column = \"id\"),\r\n            @Result(property = \"tid\", column = \"tid\"),\r\n            @Result(property = \"tag\",column = \"tid\",one = @One(select = \"com.example.xhbblog.mapper.TagMapper.selectByPrimaryKey\")),\r\n            @Result(property = \"commentSize\",column = \"id\",one = @One(select = \"com.example.xhbblog.mapper.CommentMapper.countOfArticle\")),\r\n    }\r\n    )\r\n    List<Article> listAll(Boolean published);        //给后台用的\r\n\r\n\r\n    @Select(\"<script>\" +\r\n            \"select * from article where tid=#{tid}\" +\r\n            \"<when test=\'published!=null\'>\"+\r\n            \"and published=#{published}\"+\r\n            \"</when>\"+\r\n            \"order by id desc\" +\r\n            \"</script>\")\r\n    @Results({\r\n            @Result(property = \"id\",column = \"id\"),\r\n            @Result(property = \"tid\", column = \"tid\"),\r\n            @Result(property = \"tag\", column = \"tid\", one = @One(select = \"com.example.xhbblog.mapper.TagMapper.selectByPrimaryKey\")),\r\n            @Result(property = \"commentSize\", column = \"id\", one = @One(select = \"com.example.xhbblog.mapper.CommentMapper.countOfArticle\"))\r\n    })\r\n    List<Article> listByTid(Integer tid,Boolean published);       //用于后台\r\n\r\n\r\n    @Select(\"<script>\" +\r\n            \"select * from article where id IN(select id from article where content like #{string} or title like #{string})\" +\r\n            \"<when test=\'published!=null\'>\"+\r\n            \"and published=#{published}\"+\r\n            \"</when>\"+\r\n            \"order by id desc\"+\r\n            \"</script>\")\r\n    @Results({\r\n            @Result(property = \"id\",column = \"id\"),\r\n            @Result(property = \"tid\", column = \"tid\"),\r\n            @Result(property = \"tag\", column = \"tid\", one = @One(select = \"com.example.xhbblog.mapper.TagMapper.selectByPrimaryKey\")),\r\n            @Result(property = \"commentSize\", column = \"id\", one = @One(select = \"com.example.xhbblog.mapper.CommentMapper.countOfArticle\"))\r\n    })\r\n    List<Article> listArticleLike(String string,Boolean published);         //给后台用\r\n```',b'1','今天再次给自己的博客后台系统更新了一波,\r\n自己在修改以往博客格式的过程中发现了自己在修改博客后总会返回第一页,就又\r\n要重复很多操作才能修改到下一篇我想要的,于是就更改了一下博客修改页,顺遍给\r\n博客列表页引入了根据发布(草稿)状态进行筛选的功能,在重写dao层mybatis代\r\n码时由于自己之前的mapper方法均是以注解的方式开发(对xml总感觉反感)于是便引出了今天的问题',b'0',2,NULL,NULL),(126,2,'2020-04-15 00:00:00','[leetcode]542. 01 矩阵','http://img.xuhaobo.site/63',8,'>*一道非常常见的(写了感觉很多次)的BFS常见题,之前看还有DP的解法,打算以后再详细看看吧,大体思路就是对方格里每一个点进行广度优先搜索,并存储到一个新数组中*\r\n\r\n题目如下:\r\n![](http://img.xuhaobo.site/63)\r\n\r\n![](http://img.xuhaobo.site/64)\r\n\r\njava代码如下:\r\n```java\r\nclass Solution {\r\n    private Set<String> visited=new HashSet<>();\r\n\r\n    public boolean check(int x,int y,int[][]matrix)\r\n    {\r\n        return y>=0&&y<matrix.length&&x>=0&&x<matrix[y].length;\r\n    }\r\n\r\n    public int get(int x,int y,int [][]matrix)\r\n    {\r\n        if(matrix[y][x]==0)\r\n        {\r\n            return 0;\r\n        }else\r\n        {\r\n            int anw=0;\r\n            int[]ix=new int[]{0,0,1,-1};\r\n            int[]iy=new int[]{1,-1,0,0};\r\n            Queue<int[]>q=new LinkedList<>();\r\n            q.offer(new int[]{x,y});\r\n            visited.add(x+\",\"+y);\r\n            while(!q.isEmpty())\r\n            {\r\n                int length=q.size();\r\n                anw++;\r\n                for(int k=0;k<length;k++)\r\n                {\r\n                    int []arr=q.poll();\r\n                    visited.add(arr[0]+\",\"+arr[1]);\r\n                    for(int i=0;i<4;i++)\r\n                    {\r\n                    if(check(arr[0]+ix[i],arr[1]+iy[i],matrix)==true)\r\n                    {\r\n                        if(matrix[arr[1]+iy[i]][arr[0]+ix[i]]==0)\r\n                        {\r\n                            visited.clear();\r\n                            return anw;\r\n                        }else{\r\n                            q.offer(new int[]{arr[0]+ix[i],arr[1]+iy[i]});      //x,y进队列\r\n                        }\r\n                    }  \r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    public int[][] updateMatrix(int[][] matrix) {\r\n        int [][]anw=new int[matrix.length][matrix[0].length];\r\n        for(int i=0;i<matrix.length;i++)\r\n        {\r\n            for(int j=0;j<matrix[i].length;j++)\r\n            {\r\n                anw[i][j]=get(j,i,matrix);\r\n            }\r\n        }\r\n        return anw;\r\n    }\r\n}\r\n```',b'1','一道非常常见的(写了感觉很多次)的BFS常见题,之前看还有DP的解法,打算以后再\r\n详细看看吧,大体思路就是对方格里每一个点进行广度优先搜索,并存储到一个新数组中',b'0',2,NULL,NULL),(127,2,'2020-04-16 00:00:00','[leetcode]56. 合并区间','http://img.xuhaobo.site/87',5,'>*总感觉这个是在哪里做过的......具体在哪又忘记了,反正自己当时的代码是挺不好看的,大体思路就是先将数组排一下序,那么接下来是否合并数组就只需要先判定一下是否能合并,之后具体合并只需要改变较大的一侧的值*\r\n**\r\nps:感觉自己改补补java基础语法的课了,lambda排序真香~**\r\n\r\n具体题目如下:\r\n![](http://img.xuhaobo.site/87)\r\n\r\njava实现代码如下:\r\n```java\r\nclass Solution {\r\n    public int[][] merge(int[][] intervals) {\r\n        Arrays.sort(intervals, (v1, v2) -> v1[0] - v2[0]);    //通过lambda排序\r\n        int [][]anw=new int[intervals.length][2];\r\n        int cnt=0; //存储进anw的下标\r\n        int last=Integer.MIN_VALUE;\r\n        for(int []interval:intervals)\r\n        {\r\n            if(interval[0]>last)\r\n            {\r\n                anw[cnt]=interval;//不合并直接复制,返回数组的元素个数加1\r\n                last=anw[cnt++][1]; \r\n            }else{\r\n                anw[cnt-1][1]=Math.max(interval[1],anw[cnt-1][1]);     //两者取最大\r\n                last=anw[cnt-1][1];\r\n            }\r\n        }\r\n        return Arrays.copyOf(anw,cnt);\r\n    }\r\n}\r\n```',b'1','总感觉这个是在哪里做过的......具体在哪又忘记了,反正自己当时的代码是\r\n挺不好看的,大体思路就是先将数组排一下序,那么接下来是否合并数组就只需要\r\n先判定一下是否能合并,之后具体合并只需要改变较大的一侧的值',b'0',2,NULL,NULL),(128,2,'2020-04-17 00:00:00','[leetcode]55.跳跃游戏','http://img.xuhaobo.site/66',6,'>*一开始轻敌了,直接用DFS结果超时了,之后自己试图对DFS疯狂优化....然并卵最后一气之下换成贪心+递归了,看来做题还是要认真点,少些暴力遍历这样的东西,\r\n多些想法少些套路:tw-1f436::tw-1f436:*:tw-1f436:\r\n\r\n本题leetcode链接:\r\nhttps://leetcode-cn.com/problems/jump-game/\r\n\r\n具体题目描述如下:\r\n![](http://img.xuhaobo.site/66)\r\n**贪心思想概述:局部最优之和==整体最优**\r\n我们的目的是判断自己能否到大**最后一个位置**,且起始点是第一个下标,所以\r\n一定程度上讲,我们只需要将下标**大于或等于最后一个位置即可**\r\n\r\n首先从第零个下标开始搜索,**如果直接下标+跳跃距离可以大于最后的位置,那么\r\n一定可以跳到最后的位置**,此时我们可以直接返回true\r\n\r\n**之后是要重点理解的部分**：\r\n如果没有大于最后的位置,那么我们需要权衡我们**下一步要跳到的点**是哪里\r\n我们需要权衡两点,首先我们要找到能够让我们肯定的**局部能跳范围最大的点**\r\n这个范围可以理解成**下一步的位置能跳的范围**,这个范围可以理解成与终点越\r\n近越好,**与起点距离越大越好**\r\n**\r\n那么下一步能够与起点的距离==下一步位置+下一步跳的范围\r\n所以遍历再取最大值\r\n最终跳到这个位置继续递归搜索....**\r\n\r\njava实现代码如下:\r\n```java\r\nclass Solution {\r\n    public boolean jumpto(int []nums,int index)\r\n    {\r\n        if(index==-1||nums[index]==0)\r\n        {\r\n            return false;\r\n        }\r\n        int maxIdx=-1;      //最合适的那个下标\r\n        int max=Integer.MIN_VALUE;\r\n        for(int i=nums[index];i>=1;i--)\r\n        {\r\n            if(index+i>=nums.length-1)\r\n            {\r\n                return true;\r\n            }else{\r\n                if(nums[index+i]!=0)\r\n                {\r\n                    maxIdx=nums[index+i]+i>max?index+i:maxIdx;\r\n                    max=nums[index+i]+i>max?nums[index+i]+i:max;\r\n                }\r\n            }\r\n        }\r\n        return jumpto(nums,maxIdx);\r\n    }\r\n    public boolean canJump(int[] nums) {\r\n        if(nums.length<=1)\r\n        {\r\n            return true;\r\n        }else\r\n        {\r\n            return jumpto(nums,0);\r\n        }\r\n    }\r\n}\r\n```',b'1','一开始轻敌了,直接用DFS结果超时了,之后自己试图对DFS疯狂优化....然并卵\r\n最后一气之下换成贪心+递归了,看来做题还是要认真点,少些暴力遍历这样的东西,\r\n多些想法少些套路(逃',b'0',2,NULL,NULL),(129,2,'2020-04-18 00:00:00','[leetcode]11. 盛最多水的容器','http://img.xuhaobo.site/67',94,'>*深夜刷题啊哈哈哈,赶着每日一题刷新直接十分钟刷出来了,直接ac真是畅爽~,这题算是之前刷过的了,六个月前还是在用c++的时候刷过一遍一开始试图想起之前的思路想不起来了,看了眼提示说双指针,自己直接想出来了,整体思路还是简单的*\r\n\r\n**题目如下:**\r\n![](http://img.xuhaobo.site/67)\r\n\r\n**大体思路**\r\n我们盛水的思路就是求矩形面积最大,矩形面积==长*宽\r\n首先设立两个指针(一个指向0,一个指向终点),(此时理论上宽最大)\r\n随后我们要排除长影响面积最大值的情况,那么我们可以通过更新较小的指针来\r\n逐步实现,大体讲一下循环遍历过程:\r\n1.求较小的值所对应指针\r\n2.根据较小的高求面积刷新目前最大值\r\n3.指针变动并判断是否遍历完毕\r\n\r\njava实现如下:\r\n```java\r\nclass Solution {\r\n    public int maxArea(int[] height) {\r\n        int max=0;\r\n        int begin=0;\r\n        int end=height.length-1;\r\n        while(begin<end)\r\n        {\r\n            int square=0;\r\n            if(height[end]<height[begin])\r\n            {\r\n                square=(end-begin)*height[end];\r\n                end--;\r\n            }else\r\n            {\r\n                square=(end-begin)*height[begin];\r\n                begin++;\r\n            }\r\n            max=max>square?max:square;\r\n        }\r\n        return max;\r\n    }\r\n}\r\n```\r\n\r\nc++实现如下:(6个月前)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int maxArea(vector<int>& height) {\r\n        int i=0,j=height.size()-1;\r\n        int max=0;\r\n        while(i<j)\r\n        {\r\n            int k=height[i]>height[j]?height[j]:height[i];\r\n            int s=k*(j-i);\r\n            if(s>max)\r\n            {\r\n                max=s;\r\n            }\r\n            if(k==height[j])\r\n            {\r\n                j--;\r\n            }\r\n            else if(k==height[i])\r\n            {\r\n                i++;\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n};\r\n```\r\n\r\nc语言:\r\n```c\r\nint maxArea(int* height, int heightSize){\r\n    int begin=0;\r\n    int end=heightSize-1;\r\n    int max=0;\r\n    while(begin<end)\r\n    {\r\n        int squ=0;\r\n        if(height[begin]>height[end])\r\n        {\r\n            squ=height[end]*(end-begin);\r\n            end--;\r\n        }else\r\n        {\r\n            squ=height[begin]*(end-begin);\r\n            begin++;\r\n        }\r\n        max=max>squ?max:squ;\r\n    }\r\n    return max;\r\n}\r\n```',b'1','深夜刷题啊哈哈哈,赶着每日一题刷新直接十分钟刷出来了,直接ac真是畅爽~,\r\n这题算是之前刷过的了,六个月前还是在用c++的时候刷过一遍\r\n一开始试图想起之前的思路想不起来了,看了眼提示说双指针,自己直接想出来了,\r\n整体思路还是简单的(又一道我既可以提供java又可以提供c++实现的题了哈哈哈哈',b'0',2,NULL,NULL),(130,20,'2020-04-18 00:00:00','王爽<<汇编语言>>第十一章&&十二章总结','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',58,'*第十一章主要讲述了几个条件寄存器cf,pf,zf,sf,of,df的作用以及使用原理,以及相关的cmp以及条件转移指令外加加减法进位指令;这里具体用法逻辑就不细说了，第十二章大概内容讲述了程序的内中断过程,书中逐渐开始介绍中断的概念。*\r\n\r\n这里首先我们要明确一下“**中断**”的定义:这里引用一下csapp里的定义**中断是异步发生的,是来自处理器外部的I/O设备的信号的结果**。\r\n\r\n中断的过程既有软件,又有硬件的参与,其过程如下图所示:\r\n![](http://img.xuhaobo.site/68)\r\n\r\n可以看出,中断的过程是由硬件发去信号(这里就是异常号,比如我们实验中除以0\r\n的异常本质上就是\"零号异常\"),随后控制传递给中断处理程序(位于中断向量表),\r\n\r\n\r\n中断向量表位于内存中一块固定的地址里,存储着中断处理程序的入口地址的cs,ip值,一个表项存放一个中断向量,也就是一个中断处理程序的入口地址,对于8086cpu,这个入口地址包括段地址和偏移地址,以一个表项占两个字,**高地址字存放短地址,低地址字存放偏移地址。**\r\n\r\n我们要做的就是中断过程中中断处理程序这个层面的事情.\r\n\r\n1.首先编写中断处理程序\r\n2.将中断处理程序存入指定的,不会在别的程序运行过程中被覆盖的位置(安装)\r\n3.设置中断向量(将我们中断处理程序所存放的那段入口地址存入中断向量表中),这个过程我个人比较愿意理解为注册,将我们的程序注册进去\r\n\r\n实验代码如下:\r\n    \r\n\tassume cs:code\r\n    code segment\r\n      start:\r\n      mov ax,cs\r\n      mov ds,ax\r\n      mov si,offset do0       ;将所传送的代码段长度设为下标\r\n      \r\n      mov ax,00\r\n      mov es,ax\r\n      mov di,0200h                ;要写入安装的内存位置\r\n      \r\n      mov cx,offset do0_end-offset do0         ;这里偏置的也是字节？\r\n      rep movsb                    ;按字节传送\r\n      \r\n      ;使得该入口地址成为0号中断的中断处理程序\r\n      \r\n      \r\n      mov ax,0\r\n      mov es,ax\r\n      mov di,0\r\n      mov word ptr es:[0*4],200h           ;所传入的中断向量表表项,第一个字为ip,第二个字为Cs\r\n      mov word ptr es:[0*4+2],0\r\n      \r\n      ;测试中断程序\r\n      mov ax,10\r\n      mov bx,0\r\n      div bx\r\n      \r\n      mov ax,4c00h\r\n      int 21h\r\n      \r\n      do0:jmp short show_do0\r\n    \t  db \"divideserror!\"\r\n    \t  ;将字符串写入显存进行表示\r\n      show_do0:mov ax,cs\r\n    \t\t   mov ds,ax\r\n    \t\t   mov si,202h\r\n    \t\t   \r\n    \t\t   mov ax,0b800h\r\n    \t\t   mov es,ax\r\n    \t\t   mov di,12*160+36*2\r\n    \t\t   \r\n    \t\t   mov cx,13\r\n    \t\t   mov bx,0\r\n    \t\t   \r\n    \t\t   s:\r\n    \t\t\tmov al,ds:[si]\r\n    \t\t\tmov es:[di],al\r\n    \t\t\tmov byte ptr es:[di+1],01000010b\r\n    \t\t\tadd di,2\r\n    \t\t\tinc si\r\n    \t\t\tloop s\r\n    \t\t   rep movsw         ;整段传送到显存中\r\n    \t\t   \r\n    \t\t   mov ax,4c00h\r\n    \t\t   int 21h\r\n    \t\t   \r\n      do0_end:nop                    ;用于计算代码段字节数的占位段\r\n    \r\n    code ends\r\n    end start',b'1','第十一章主要讲述了几个条件寄存器cf,pf,zf,sf,of,df的作用以及使用原理以及相关的cmp以及条件转移指令外加加减法进位指令;这里具体用法逻辑就不细说了\r\n第十二章大概内容讲述了程序的内中断过程,这里首先我们要明确一下“中断”的定义:这里引用一下csapp里的定义',b'0',2,NULL,NULL),(131,20,'2020-04-20 00:00:00','王爽<<汇编语言>>十三&十四&十五章实验总结','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',20,'*第十三章主要讲了如何使用int指令引发内中断,个人认为难点是用过int实现loop循环的过程,第十四章主要讲了如何通过控制端口实现输入/输出操作,以及向端口的IO操作的原理,第十五章个人认为算是十三,十四的总和,需要我们编写并安装对某端口输入输,出\r\n--》发动外中断的中断例程*\r\n## 第十三章(int指令)实验:\r\n(1)实现较为简单,这里给一下代码实现:\r\n    \r\n\tassume cs:code\r\n    \r\n    code segment\r\n    \r\n    start:mov ax,cs\r\n    \t  mov ds,ax\r\n    \t  mov si,offset show_str\r\n    \t  mov ax,0\r\n    \t  mov es,ax\r\n    \t  mov di,200h\r\n    \t  mov cx,offset show_end-offset show_str\r\n    \t  rep movsb\r\n    \t  \r\n    \t  mov word ptr es:[7ch*4],200h\r\n    \t  mov word ptr es:[7ch*4+2],0\r\n    \t\t\r\n    \t  mov ax,4c00h\r\n    \t  int 21h\r\n    \r\n    \r\n    show_str:\r\n    \t  mov bl,cl\r\n    \t  input:\r\n    \t\t \r\n    \t\tset:;设置光标\r\n    \t\t\tmov ah,2\r\n    \t\t\tmov bh,0;这里写一下是为了传参直观一?\r\n    \t\t\tmov dl,dl\r\n    \t\t\tmov dh,dh\r\n    \t\t\tint 10h\r\n    \t\t\r\n    \t\t\r\n    \t\t  ;输出光?\r\n    \t\t\tmov ch,0\r\n    \t\t\tmov cl,ds:[si]\r\n    \t\t\tjcxz ok;判定字符结束\r\n    \t\r\n    \t\t\t;在光标位置显示字符\r\n    \t\t\tmov ah,9\r\n    \t\t\tmov al,cl\r\n    \t\t\t\r\n    \t\t\tmov bh,0\r\n    \t\t\tmov cx,1\r\n    \t\t\tint 10h\r\n    \t\t\t\r\n    \t\t\tinc dl\r\n    \t\t\tinc si\r\n    \t\t\tjmp input\r\n    \r\n    \t\tok: iret\r\n    \t\t\r\n    show_end:nop\r\n    \r\n    code ends\r\n    end start\r\n\r\n(2)原理:我们可以把通过int发动中断处理程序类似于调用子程序一样理解,之前我们已经将int 7ch的下一句ip与s代码段首地址的ip值的差(**注意此处为负值**),用bx存储了起来,我们只需要在中断例程中修改最终iret指令pop的ip值即可这里一定要明确清楚的地方是iret的内部实现:刷新ip和cs值\r\n\r\n代码如下:\r\n    ;实现loop的中断处理程序安装例程\r\n    assume cs:code\r\n    \r\n    code segment\r\n    \r\n    start:mov ax,cs\r\n    \t  mov ds,ax\r\n    \t  mov si,offset lop_str\r\n    \t  mov ax,0\r\n    \t  mov es,ax\r\n    \t  mov di,200h\r\n    \t  mov cx,offset lop_end-offset lop_str\r\n    \t  rep movsb\r\n    \t  \r\n    \t  mov word ptr es:[7ch*4],200h\r\n    \t  mov word ptr es:[7ch*4+2],0\r\n    \t\t\r\n    \t  mov ax,4c00h\r\n    \t  int 21h\r\n    \r\n    \r\n    lop_str:\r\n    \t\tpush bp\r\n    \t\tmov bp,sp\r\n    \t\tdec cx\r\n    \t\tjcxz ok\r\n    \t\tadd [bp+2],bx\r\n    \t\t\r\n    \t\tok:pop bp\r\n    \t\t\tiret\r\n    \t\t\t\r\n    \t\t\r\n    lop_end:nop\r\n    \r\n    code ends\r\n    end start\r\n\r\n(3)很简单,就是把内存寄存器什么的关系梳理清楚就好了\r\n代码如下:\r\n    \r\n\tassume cs:code\r\n    code segment\r\n    \r\n    s1:db \'good better,best,\',\'$\'\r\n    s2:db \'never give up,\',\'$\'\r\n    s3:db \'fuck up,\',\'$\'\r\n    s4:db \'holly shit,\',\'$\'\r\n    s:dw offset s1,offset s2,offset s3,offset s4\r\n    row:db 2,4,6,8\r\n    \r\n    start:mov ax,cs\r\n    \t  mov ds,ax\r\n    \t  mov bx,offset s\r\n    \t  mov si,offset row\r\n    \t  mov cx,4\r\n    \t  \r\n    \tok:mov bh,0\r\n    \t   mov dh,ds:[si]\r\n    \t   mov dl,0\r\n    \t   mov ah,2\r\n    \t   int 10h\r\n    \t   \r\n    \t   mov dx,ds:[bx]\r\n    \t   mov ah,9\r\n    \t   int 21h\r\n    \t   add bx,2\r\n    \t   inc si\r\n    \t   loop ok\r\n    \t   \r\n    \t   mov ax,4c00h\r\n    \t   int 21h\r\n    \t   \r\n    code ends\r\n    end start\t   \r\n\r\n## 第十四章(端口)实验:\r\n**实验十四感觉它中间那个分隔符当时感觉有点困难\r\n后来想到可以先改写一段初始化的内存里去\r\n再把这段内存写到显存里就好了**\r\n    \r\n    assume cs:code\r\n    data segment\r\n    db 9,8,7,4,2,0\r\n    db \"yy/mm/dd hh:mm:ss\"\r\n    data ends\r\n    \r\n    code segment\r\n    start:\r\n    \tmov ax,data\r\n    \tmov ds,ax\r\n    \tmov cx,6\r\n    \tmov bx,0\r\n    \tmov dx,0\r\n    \r\n    s:\tmov al,ds:[bx]\r\n    \r\n    ;取时间数据\r\n    \tout 70h,al\r\n    \tin al,71h\r\n    \tmov ah,al\r\n    \tmov dl,cl\r\n    \tmov cl,4\r\n    \tshr al,cl\r\n    \tmov cl,dl\r\n    \tand ah,00001111B\r\n    \tadd ah,30h\r\n    \tadd al,30h\r\n    ;写入数据区域\r\n    \r\n    \tmov bp,bx\r\n    \tshl bp,1\r\n    \tadd bp,bx\r\n    \tmov ds:[bp+6],ax\r\n    \t\r\n    \t\r\n    \tadd bx,1            ;刷新bx\r\n    \tloop s\r\n    \r\n    \r\n    ;写入显存中\r\n    mov ax,4c00h\r\n    int 21h\r\n    code ends\r\n    end start\t \r\n\r\n运行结果如下:\r\n![](http://img.xuhaobo.site/70)\r\n\r\n## 第十五章(外中断)实验:\r\n外中断可以简单理解为外部设备发出的中断信号引发的cpu中断\r\n可分为**可屏蔽**中断和不可屏蔽中断(通过IF设置不响应状态时可屏蔽中断会被屏蔽，)\r\n**我们接触到的大部分外设引发的中断都是可屏蔽中断,不可屏蔽中断是系统中有必须处理的紧急情况时发出的中断信号**\r\n代码如下:\r\n    \r\n\tassume cs:code,ss:stack\r\n    \r\n    stack segment\r\n      db 128 dup(0)\r\n    stack ends\r\n    \r\n    code segment\r\n    \r\n    start:mov ax,stack\r\n    \t  mov ss,ax\r\n    \t  mov sp,128\r\n    \t  \r\n    \t  ;安装中断处理程序\r\n    \t  push cs\r\n    \t  pop ds\r\n    \t  mov si,offset fill_A\t\r\n    \t\t\r\n    \t  mov ax,0\r\n    \t  push ax\r\n    \t  pop es\r\n    \t  mov di,204h\r\n    \t  \r\n    \t  mov cx,offset fill_A_end-offset fill_A\r\n    \t  cld\r\n    \t  rep movsb\r\n    \t  \r\n    \t  ;保存原中断处理程序int 9h\r\n    \t  push es:[9*4]\r\n    \t  pop es:[200h]\r\n    \t  push es:[9*4+2]\r\n    \t  pop es:[202h]\r\n    \t  \r\n    \t  cli\r\n    \t  mov word ptr es:[9*4],204h\r\n    \t  mov word ptr es:[9*4+2],0\r\n    \t  sti\r\n    \t  \r\n    \t  mov ax,4c00h\r\n    \t  int 21h\r\n    \t  \r\n    fill_A:push ax\r\n    \t   push bx\r\n    \t   push cx\r\n    \t   push es\r\n    \t   \r\n    \t   in al,60h\r\n    \t   normal:pushf\r\n    \t\t\t  pushf\r\n    \t\t\t  pop bx\r\n    \t\t\t  and bh,11111100b\r\n    \t\t\t  push bx\r\n    \t\t\t  popf\r\n    \t\t\t  call dword ptr cs:[200h]\r\n    \t\t\t  \r\n    \t   cmp al,9eh\r\n    \t   jne ok\r\n    \t   \r\n    \t   ;循环将A输入到屏幕上\r\n    \t\t\t  \r\n    \t\tmov ax,0b800h\r\n    \t\tmov es,ax\r\n    \t\tmov cx,2000\r\n    \t\tmov bx,0\r\n    \t   s:\r\n    \t     mov byte ptr es:[bx],\'A\'\r\n    \t\t add bx,2\r\n    \t\t loop s\t  \r\n    \t\t\r\n    \t\t\t\r\n    \t   ok:\tpop es\t\r\n    \t\t\tpop cx\r\n    \t\t\tpop bx\r\n    \t\t\tpop ax\r\n    \t\tiret\r\n    \t\t\r\n    fill_A_end:nop\r\n    \t\t   \r\n    \r\n    code ends\r\n    end start',b'1','第十三章主要讲了如何使用int指令引发内中断,个人认为难点是用过int实现loop\r\n循环的过程\r\n第十四章主要讲了如何通过控制端口实现输入/输出操作,以及向端口的IO操作的原理\r\n第十五章个人认为算是十三,十四的总和,需要我们编写并安装对某端口输入输出\r\n--》发动外中断的中断例程',b'0',2,NULL,NULL),(132,20,'2020-04-21 00:00:00','王爽<<汇编语言>>十六章实验总结','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',73,'*第十六章主要讲了直接定址表的具体实现,具体学习的内容就是通过标号来寻址,并依照这种位置关系进行较为复杂的寻址,个人认为难点主要在于进行复杂寻址的这种编程,这种思路貌似与之前看csapp里switch的机器级实现很像*\r\n\r\n**实验分析:大概内容就是自己实现一个根据参数动态选择功能字程序的中断例程,这里要实现的功能之前在书中已经给了很好的实现,我们主要讲述整个中断过程的逻辑,也算是对于整个中断过程理解的一次复习**\r\n\r\n首先我们要明确在中断处理的过程中的cs,ip值,这里的cs,ip就是之前我们在安\r\n装过程中我们将中断例程代码段放入的地址,按本题分析,cs为零,\r\n**所以当我们在通过参数寻找在table所对应的子功能程序地址,以及根据table所提供的偏移地址寻找代码段时,要记得加上本身程序的偏移量200h**\r\n\r\n需要明确的一点:\r\n我们首先通过参数找到在table下的**存储偏移量的地址**\r\n这里的偏移量,是我们通过table找到的是**函数对应的地址偏移量**\r\n进行了两次寻址的过程\r\n\r\n\r\n自己写的图示如下:\r\n![](http://img.xuhaobo.site/73)\r\n\r\n整体代码如下:\r\n    \r\n\tassume cs:code,ss:stack\r\n    \r\n    stack segment\r\n      db 128 dup(0)\r\n    stack ends\r\n    \r\n    code segment\r\n    \r\n    start:mov ax,stack\r\n    \t  mov ss,ax\r\n    \t  mov ax,cs\r\n    \t  mov ds,ax\r\n    \t  mov si,offset function\r\n    \t  mov ax,0\r\n    \t  mov es,ax\r\n    \t  mov di,200h\r\n    \t  mov cx,offset function_end-offset function\r\n    \t  rep movsb\r\n    \t  \r\n    \t  mov word ptr es:[7ch*4],200h\r\n    \t  mov word ptr es:[7ch*4+2],0\r\n    \t\t\r\n    \t  mov al,1\r\n    \t  mov ah,2\r\n    \t  int 7ch\r\n    \t \r\n    \t  mov ax,4c00h\r\n    \t  int 21h\r\n    \t  \r\n    function:\r\n    \tjmp short begin\r\n    \t;这里table存的是各段函数相对于cs(0)的偏移量(ip)\r\n    \ttable dw offset sub1-offset function+0200h,offset sub2-offset function+0200h,offset sub3-offset function+0200h,offset sub4-offset function+0200h            ;table表记下各功能函数的偏置值\r\n    \t\r\n    \tbegin:push bx\r\n    \t\t  push es\r\n    \t\t  mov bx,0\r\n    \t\t  mov bl,ah\r\n    \t\t  add bl,bl                    ;此时的bx代表的是我要去用第几个函数处理\r\n    \t\t  add bx,offset table-offset function        ;table相对于中断处理程序(function)的偏移量  \r\n    \t\t  call word ptr cs:[bx+200h]                     ;+200h是先cs找到中断处理程序的位置\r\n    \t\t  pop es\r\n    \t\t  pop bx\r\n    \t\t  iret\r\n    \t\r\n    \t\r\n    \tsub1:push bx\r\n    \t\t push cx\r\n    \t\t push es\r\n    \t\t mov ax,0b800h\r\n    \t\t mov es,ax\r\n    \t\t mov bx,0\r\n    \t\t mov cx,2000\r\n    \t\t \r\n    \tsub1_loop:\r\n    \t\t\t  mov byte ptr es:[bx],\' \'\r\n    \t\t\t  add bx,2\r\n    \t\t\t  loop sub1_loop\r\n    \t\t\t  \r\n    \tpop es\r\n    \tpop cx\r\n    \tpop bx\r\n    \tret\r\n    \t\r\n    \tsub2:push bx\r\n    \t\t push cx\r\n    \t\t push es\r\n    \t\t mov ah,0\r\n    \t\t mov al,al           ;设置背景色的参\r\n    \t\t mov di,ax\r\n    \t\t mov ax,0b800h\r\n    \t\t mov es,ax\r\n    \t\t mov ax,di\r\n    \t\t mov bx,1           ;背景色在后三位\r\n    \t\t mov cx,2000\r\n    \t\r\n    \tsub2_loop:and byte ptr es:[bx],11111000b\r\n    \t\t\t  or byte ptr es:[bx],al\r\n    \t\t\t  add bx,2\r\n    \t\t\t  loop sub2_loop\r\n    \tpop es\r\n    \tpop cx\r\n    \tpop bx\r\n    \tret\r\n    \t\t\r\n    \tsub3:push bx\r\n    \t\t push cx\r\n    \t\t push es\r\n    \t\t mov ah,0\r\n    \t\t mov al,al           ;设置背景色的参数\r\n    \t\t mov di,ax\r\n    \t\t mov ax,0b800h\r\n    \t\t mov es,ax\r\n    \t\t mov ax,di\r\n    \t\t mov bx,1           ;背景色在后三位\r\n    \t\t mov cx,2000\r\n    \t\t shl al,1\r\n    \t\t shl al,1\r\n    \t\t shl al,1\r\n    \t\t shl al,1\r\n    \t\r\n    \tsub3_loop:and byte ptr es:[bx],11000111b\r\n    \t\t\t  or byte ptr es:[bx],al\r\n    \t\t\t  add bx,2\r\n    \t\t\t  loop sub3_loop\r\n    \tpop es\r\n    \tpop cx\r\n    \tpop bx\r\n    \tret\t\r\n    \t\r\n    \t;先让前几行移位\r\n    \tsub4:push bx\r\n    \t\t push cx\r\n    \t\t push es\r\n    \t\t push si\r\n    \t\t push ds\r\n    \t\t \r\n    \r\n    \t\t mov ax,0b800h\r\n    \t\t mov es,ax\r\n    \t\t mov ds,ax\r\n    \t\t mov di,0\r\n    \t\t mov si,160\r\n    \t\t cld\r\n    \t\t mov cx,24\r\n    \t\t s:push cx\r\n    \t\t   mov cx,160\r\n    \t\t   rep movsb\r\n    \t\t   pop cx\r\n    \t\t   loop s\r\n    \t\t   \r\n    \t\tmov cx,80\r\n    \t\tmov si,0\r\n    \tc_e:\r\n    \t\tmov byte ptr es:[160*24+si],\' \'\r\n    \t\tadd si,2\r\n    \t\tloop c_e\r\n    \t\t\r\n    \tpop ds\r\n    \tpop si\r\n    \tpop es\r\n    \tpop cx\r\n    \tpop bx\r\n    \tret\r\n    \t\r\n    function_end:nop\r\n    \t\t   \r\n    \r\n    code ends\r\n    end start',b'1','第十六章主要讲了直接定址表的具体实现,具体学习的内容就是通过标号来寻址,并依照这种位置关系进行较为复杂的寻址,个人认为难点主要在于进行复杂寻址的这种编程,这种思路貌似与之前看cs:app里switch的机器级实现很像',b'0',2,NULL,NULL),(133,2,'2020-04-21 00:00:00','[leetcode]1248. 统计「优美子数组」','http://img.xuhaobo.site/74',16,'>*今天这题乍一看像是有难度的,看了\"双指针\"二字之后我就开始往下标的方向去想,没想到自己推出来了:tw-1f436: :tw-1f436:\r\n*\r\n\r\n\r\n题目如下:\r\n![](http://img.xuhaobo.site/74)\r\n**我们可以数组以奇数的位置分段,以循环遍历的下标为开始,给奇数计数,通过分段对两侧进行下标的运算进而统计数量。**\r\n自己的大概算法图解如下:\r\n![个人解法如下](http://img.xuhaobo.site/76 \"解法图解\")\r\n向左伸展和向右伸展都可以理解,朝两侧伸展可以理解为两侧相乘\r\n要注意的点就是边界量(第一个指针是第一个奇数,以及第二个指针是最后一个奇数的情况)\r\n**距离记得减一**\r\n\r\n```java\r\nclass Solution {\r\n    public int numberOfSubarrays(int[] nums, int k) {\r\n        List<Integer> odds=new ArrayList<>();\r\n        int sum=0;         //优美子数组的个数\r\n        for(int i=0;i<nums.length;i++)\r\n        {\r\n            if(nums[i]%2!=0)                              //是奇数就记位置\r\n            {\r\n                odds.add(i);\r\n            }\r\n        }\r\n        if(k==0)                //奇数不够,不存在\r\n        {\r\n            return 0;\r\n        }else\r\n        {\r\n            int step=k-1;       //步长值\r\n            int size=odds.size();      //未扫描时的总个数\r\n            for(int i=0;i<odds.size();i++)\r\n            {\r\n                if(size<k)\r\n                {\r\n                    break;              //奇数的数量不足时退出\r\n                }else{\r\n                    sum+=1;     //本身\r\n                    int last=(i==0)?-1:odds.get(i-1);\r\n                    int next=size>k?odds.get(i+k):nums.length;\r\n                    sum+=odds.get(i)-last-1;\r\n                    sum+=next-odds.get(i+k-1)-1;\r\n                    sum+=(odds.get(i)-last-1)*(next-odds.get(i+k-1)-1);\r\n                }\r\n                size--;\r\n            }\r\n        }\r\n        return sum;\r\n    }\r\n}\r\n```',b'1','今天这题乍一看像是有难度的,看了\"双指针\"二字之后我就开始往下标的方向去想,没想到自己推出来了,看来以后遇到双指针的题就多往数组下标去想,大概率是对的方向',b'0',2,NULL,NULL),(134,2,'2020-04-22 00:00:00','[leetcode]199. 二叉树的右视图','http://img.xuhaobo.site/77',25,'>*这算是四月最简单的题么,比好想的做法就是二叉树BFS(算是学BFS时的标准应用了),取每一层最后一个的值,比起前面的题要用visited剪枝还要更简单一点~~~*\r\n\r\n题目如下:\r\n![](http://img.xuhaobo.site/77)\r\n**我们要确定他是最右边的,最好的方式就是二叉树的BFS(说法就和二叉树的层序遍历是一回事)**\r\nJAVA代码如下:\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode(int x) { val = x; }\r\n * }\r\n */\r\nclass Solution {\r\n    public List<Integer> rightSideView(TreeNode root) {\r\n        List<Integer>anw=new ArrayList<>();\r\n        if(root==null)\r\n        {\r\n            return anw;\r\n        }\r\n        Queue<TreeNode>q=new LinkedList<>();\r\n        q.offer(root);\r\n        while(!q.isEmpty())\r\n        {\r\n            int length=q.size();\r\n            for(int i=0;i<length;i++)\r\n            {\r\n                TreeNode t=q.poll();\r\n                if(i==length-1)  //最后一个结点\r\n                {\r\n                    anw.add(t.val);\r\n                }\r\n                if(t.left!=null)\r\n                {\r\n                    q.offer(t.left);\r\n                }\r\n                if(t.right!=null)\r\n                {\r\n                    q.offer(t.right);\r\n                }\r\n            }\r\n        }\r\n        return anw;            \r\n    }\r\n}\r\n```\r\n\r\nc++代码如下:\r\n```cpp\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    vector<int> rightSideView(TreeNode* root) {\r\n        vector<int>anw;\r\n        if(!root)\r\n        {\r\n            return anw;\r\n        }\r\n        queue<TreeNode*>Q;\r\n        Q.push(root);\r\n        while(Q.size())\r\n        {\r\n            int length=Q.size();\r\n            for(int i=0;i<length;i++)\r\n            {\r\n                TreeNode* T=Q.front();\r\n                Q.pop();\r\n                if(i==length-1)\r\n                {\r\n                    anw.push_back(T->val);\r\n                    printf(\"%d \",T->val);\r\n                }\r\n                if(T->left)\r\n                {\r\n                    Q.push(T->left);\r\n                }\r\n                if(T->right)\r\n                {\r\n                    Q.push(T->right);\r\n                }\r\n            }\r\n        }\r\n        return anw;\r\n    }\r\n};\r\n```',b'1','这算是四月最简单的题么,比好想的做法就是二叉树BFS(算是学BFS时的标准应\r\n用了),取每一层最后一个的值,比起前面的题要用visited剪枝还要更简单一点~~~',b'0',2,NULL,NULL),(135,20,'2020-04-22 00:00:00','王爽<<汇编语言>>终章---十七章实验总结','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',43,'*终于算是把整本书的知识部分学完了....感觉学过之后觉得汇编还是挺值得一学的,它能够一定程度上让人有实际操控底层内存的体验,一定程度上也算是\"打开计算机的黑盒子\"中的一环吧*\r\n\r\n书中的算法如下:\r\n![](http://img.xuhaobo.site/78)\r\n\r\n**最后一个实验比较简单,主要涉及的还是根据它所给的公式进行计算,最终再调用中断处理程序,传入读写磁盘所需的参数,十七章也主要讲述了将一个功能化成几个小功能小程序段的思想,我想这应该算是“面向过程编程”非常好的案例了吧**\r\n\r\n汇编代码如下:\r\n\r\n    assume cs:code,ss:stack\r\n    \r\n    stack segment\r\n      db 128 dup(0)\r\n    stack ends\r\n    \r\n    code segment\r\n    \r\n    start:\r\n    \t  mov ax,stack\r\n    \t  mov ss,ax\r\n    \t  mov sp,128\r\n    \t  mov ax,0b800h\r\n    \t  mov es,ax\r\n    \t  mov bx,0\r\n    \t  \r\n    \t  mov ah,1      ;功能号为1\r\n    \t  mov al,2      ;扇区数为2\r\n    \t  mov dx,1200\r\n    \t  call main_func\r\n    \t  \r\n    \t  mov ax,4c00h\r\n    \t  int 21h\r\n    \r\n    ;取商\r\n    fun_int:mov ax,ax\r\n    \t\tmov dx,0\r\n    \t\tret\r\n    \r\n    ;取余\r\n    fun_rem:mov ax,dx\r\n    \t\tmov dx,0\r\n    \t\tret\r\n    \r\n    ;求面号\r\n    face:push bx\r\n         mov ax,dx\r\n    \t mov bx,1440\r\n    \t mov dx,0\r\n    \t div bx\r\n    \t call fun_int\r\n    \t pop bx\r\n    \t ret\r\n    \r\n    ;求磁道号\r\n    track:\r\n          push bx\r\n    \t  mov ax,dx\r\n    \t  mov bx,1440\r\n    \t  mov dx,0\r\n    \t  div bx\r\n    \t  call fun_rem\r\n    \t  mov bx,18\r\n    \t  mov dx,0\r\n    \t  div bx\r\n    \t  call fun_int\r\n    \t  pop bx\r\n    \t  ret\r\n    \r\n    ;求扇区号\r\n    sector:push bx\r\n    \t   mov ax,dx\r\n    \t   mov bx,1440\r\n    \t   mov dx,0\r\n    \t   div bx\r\n    \t   call fun_rem\r\n    \t   mov bx,18\r\n    \t   mov dx,0\r\n    \t   div bx\r\n    \t   call fun_rem\r\n    \t   inc ax\r\n    \t   pop bx\r\n    \t   ret\r\n    ;主功能\t\t   \r\n    main_func:\r\n    \t\t push ax\r\n    \t\t push dx\r\n    \t\t push bx\r\n    \t\t push es\r\n    \t\t push si\r\n    \t\t \r\n    \t\t push ax\r\n    \t\t \r\n    \t\t mov cx,0\r\n    \t\t \r\n    \t\t push dx\r\n    \t\t call track\r\n    \t\t mov ch,al\r\n             pop dx\r\n    \r\n    \t\t push dx\r\n    \t\t call sector\r\n    \t\t mov cl,al\r\n    \t\t pop dx\r\n    \r\n    \r\n    \t\t call face\r\n    \t\t mov dh,al\t\r\n    \t\t mov dl,0         ;我们这里默认使用软驱A\r\n    \t\t \r\n    \r\n    \t\t \r\n    \t\t \r\n    \t\t pop ax\r\n    \t\t int 13h\r\n    \t\t \r\n    \t\t pop si\r\n    \t\t pop es\r\n    \t\t pop bx\r\n    \t\t pop dx\r\n    \t\t pop ax\r\n    \t\t ret\r\n    code ends\r\n    end start\r\n\r\n检验结果如下:\r\n![](http://img.xuhaobo.site/79),与传入的逻辑地址:1200所建立的对应相同',b'1','终于算是把整本书的知识部分学完了....感觉学过之后觉得汇编还是挺值得一学的,它能够一定程度上让人有实际操控底层内存的体验,一定程度上也算是\"打开计算机的黑盒子\"中的一环吧',b'0',2,NULL,NULL),(136,22,'2020-04-24 00:00:00','操作系统第一天---操作系统引导程序','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3621867659,1152751757&fm=26&gp=0.jpg',445,'>今天正式开始学习一直心心念念的操作系统了,没想到引导程序和搭建实验环境竟如当头一棒,路漫漫其修远兮....吾将上下而求索\r\n\r\n\r\n**开机后的操作系统读取细节:**\r\n**1**.读取1号扇区到**0x7c00h**\r\n![](http://img.xuhaobo.site/81)\r\n**2**.进入存储在0x7c00h的bootsect引导扇区程序,并将该程序段移至0x9000段,并通过jmp指令跳到移植后的下一段\r\n![](http://img.xuhaobo.site/83)\r\n**3**.在引导扇区程序中读入load_setup程序段(读入setup段)\r\n![](http://img.xuhaobo.site/84)\r\n**4**.setup程序段读取成功后读入load_setup_ok程序段(这里同时将开机显示字显示到屏幕上),随后读入system程序段(操作系统代码)\r\n![](http://img.xuhaobo.site/85)\r\n**5**.进入setup程序段,载入操作系统相关的参数,将sys放入零地址(前面已经将**引导扇区程序**移动了)，**相关参数例如拓展内存(1M以外的内存)**\r\n![](http://img.xuhaobo.site/86)\r\n**6.**通过一段复杂指令进入保护模式(从此汇编也由16位转变成32位)\r\n\r\n\t**这里着重地说一下保护模式:**\r\n**1.首先我们之前编写汇编程序是一直在实模式下编写的,我们的寻址范围可以理解为cs:ip,那么最多的范围也只有1M,保护模式中cs寄存器所存储的并非段地址而是通过cs查GDT表获得真正的段地址,从而内存的空间由1M变为4G,并且内存完全交由操作系统管理,不需要程序员去考虑**\r\n\r\n**内存空间是如何从1M转变为4G的???**',b'1','今天正式开始学习一直心心念念的操作系统了,没想到引导程序和搭建实验环\r\n境竟如当头一棒,路漫漫其修远兮....吾将上下而求索。',b'0',2,NULL,NULL),(139,22,'2020-04-29 00:00:00','<<操作系统导论>>第一天','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3621867659,1152751757&fm=26&gp=0.jpg',31,'>*<<操作系统导论>>主要围绕虚拟化,并发以及持久化讲述了操作系统,\"虚拟化\"的第四,五章讲述了操作系统的进程机制,第四章侧重于理论的叙述,第五章讲述了linux的实际进程相关的api以及api为何如此设计的原理*\r\n\r\n\r\n\r\n\r\n首先明确一点:内存实现了cpu的\"虚拟化\",提供了**存在多个虚拟cpu**的假象,使得每一个运行的程序都**分开拥有一整块的内存空间以及寄存器**\r\n\r\n这种运行的程序加上其存储空间的“假象”我们习惯性地称之为**\"进程\"**,多个进程可以一起运行，通过底层机制和高级策略来完成\r\n\r\n进程状态:\r\n1.运行(这个比较常见,就不多赘述了)\r\n\r\n2.就绪:就绪状态:被阻塞后到运行的一种中间态，进程**被调度**-->运行,从运行转移到就绪则为取消调度\r\n--->**已经准备好运行**\r\n\r\n3.阻塞:进程停止运行,直到发生其他事件才继续,可以于操作系统的wait()api相对应,进程在进行wait后只有在回收fork的子进程后才能够继续进行(fork：创建子进程)--->**没有准备好运行**\r\n\r\n**(第四章作业英文太多瓦看不懂......)**\r\n## LINUX相关api补充:\r\n再补充一下linux提供的进程相关的api,大概分为3类,fork(),wait()和exec()\r\n#### fork\r\nfork()是在原地开启一个一样的子进程,可以理解成复制一份完全相同的内存,其变量值与父进程相同,但是互不影响(同时也体现了内存空间的一种虚拟化),**但是写入文件会互相覆盖,毕竟其写入的文件不属于父也不属于子**\r\n\r\n这里fork的原地是指子进程开始进行的位置就是父进程fork的位置\r\n如下图的代码\r\n```c\r\n#nclude<stdio.h>\r\n#include<stdlib.h>\r\n#include<unistd.h>\r\n#include<string.h>\r\n#include<sys/wait.h>\r\n#include<fcntl.h>\r\nint main(int argc,char *argv[])\r\n{\r\n        int rc=fork();\r\n        if(rc<0)\r\n        {\r\n                fprintf(stderr,\"fork failed\\n\");        //fork进程失败\r\n                exit(1);             //退出进程\r\n        }\r\n        else if(rc==0)\r\n        {\r\n                 fprintf(stderr,\"execl failed\\n\");\r\n                 int i=waitpid(rc,NULL,WUNTRACED);         //子进程调用wait\r\n                printf(\"进程%d结束,wait值为%d\",(int)getpid(),i);\r\n                 exit(-1);\r\n        }\r\n        else{\r\n                int i=waitpid(rc,NULL,WUNTRACED);\r\n                printf(\"进程%d结束,wait值为%d\",(int)getpid(),i);\r\n        }\r\n\r\n        return 0;\r\n}\r\n```\r\n这里我\"fork\"的位置在第九行,那么后面的子进程也同样在第九行开始,只是父进程返回的int值为子进程的pid(进程ID)，而子进程返回为-1\r\n\r\n#### wait\r\nwait算是和fork一起使用的api,它比fork好理解很多,大概功能就是等待回收我的子进程(这里补充下进程状态除了就绪,运行和阻塞外,其实还有初始和僵死态),这里我所等待的就是子进程从僵死态被回收\r\n**这里注意我所说的linux api可能均有多种实现接口,这里只是浅显地分一下类**\r\n\r\n#### exec(不可逆的重定向)\r\nexec个人认为算是给我直观感受**\"简单粗暴\"**的api，它的作用就是加载并执行指定的可执行程序,并且直接覆盖掉原有分配的内存空间(堆,栈)等\r\n\r\n我们在shell里面执行程序的过程可以理解成先fork一个子进程,再使用exec执行指定的程序(我们已经通过命令行输入),并在父进程调用wait等待子程序的完成\r\n\r\n**为什么不直接exec开启进程执行程序:将fork与exec分离,给了shell再fork后\r\nexec前一个实现多种功能的空间,(例如将某进程运行结果打印到某一文件)**\r\n\r\n#### 补充说明:write,read,pipe函数(输入输出相关)\r\n这里我认为可以通过问题中的最后一道题来说明:\r\n![](http://img.xuhaobo.site/99)\r\n代码如下:\r\n```c\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<unistd.h>\r\n#include<string.h>\r\n#include<sys/wait.h>\r\n#include<fcntl.h>\r\nint main(int argc,char *argv[])\r\n{\r\n        int fd[2]; //用于创建管道的数组\r\n\r\n        char w[100];\r\n        memset(w,0,sizeof(w));//将w里所有字节设置为0\r\n \r\n        char r[100];\r\n        memset(r,0,sizeof(r));//将r中所有字节设置为0\r\n \r\n \r\n        if(pipe(fd)==-1)\r\n        {\r\n        fprintf(stderr,\"pipe failed\\n\");\r\n        }          //创建管道\r\n\r\n        int rc=fork();\r\n        if(rc<0)\r\n        {\r\n        fprintf(stderr,\"fork failed\\n\");        //fork进程失败\r\n        exit(1);             //退出进程\r\n        }\r\n        else if(rc==0)                        //第一个子进程\r\n        {\r\n            close(fd[0]);\r\n            char w[]=\"250\\n\";\r\n            write(1,w,sizeof(w));                   //字符串写入标准输出\r\n            write(fd[1],w,sizeof(w));      //将父进程所写的全部读入管道中\r\n            close(fd[1]);\r\n            exit(1);\r\n        }else{\r\n           wait(NULL); //等待子进程进行完\r\n           int p2;\r\n           if((p2=fork())==-1)\r\n          {\r\n            fprintf(stderr,\"pipe failed\\n\");\r\n          }else if(p2==0){\r\n            close(fd[1]);                      //第二个子进程\r\n            read(fd[0],r,sizeof(w));\r\n            write(0,r,sizeof(w));           //将缓冲区值读入输入中\r\n            close(fd[0]);\r\n            exit(1);\r\n          }else{\r\n            wait(NULL);                //等待第二个子进程输入完毕\r\n            printf(\"运行结束\");\r\n                }\r\n        }\r\n\r\n        return 0;\r\n}\r\n```\r\n**接下来我将使用伪代码来实现:**\r\nwrite(被写入文件修饰符,缓冲区首地址，字节数)；\r\nread(文件修饰符,被读入缓冲区首地址，\'字节数\')；\r\npipe(int fd[2]):使用两个文件构建一个管道\r\nfd[0]固定被只被读文件\r\nfd[1]固定为只被写文件\r\n\r\n**本题思路实现**\r\n在LINUX中我们同样可以将标准输入输出当作一种文件来看,规定标准输入为0,输出为1,所以可以通过read,write写入写出,先将被写入到文件修饰符1的缓冲区写入到fd[1] (只被写),再通过fd[0] (只被读)接受我们想得到的字节,再通过write到文件修饰符0(标准输入)打在命令行上\r\n如图即为运行结果\r\n![](http://img.xuhaobo.site/100)',b'1','<<操作系统导论>>主要围绕虚拟化,并发以及持久化讲述了操作系统,\"虚拟化\"的第四,五章讲述了操作系统的进程机制,第四章侧重于理论的叙述,第五章讲述了linux的实际进程相关的api以及api为何如此设计的原理',b'0',2,NULL,NULL),(140,22,'2020-05-01 00:00:00','<<操作系统导论>>进程机制与策略(1)','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3621867659,1152751757&fm=26&gp=0.jpg',63,'>*操作系统对于进程的管理,可以分为底层的机制(受限直接进行)以及上层的策略(进程调度),通过底层机制和上层调度共同完成操作系统的进程切换并保护其数据。*\r\n\r\n##1.机制：受限直接执行\r\n受限直接执行机制,大概应用于两方面,**系统调用**以及**进程的上下文切换**\r\n####系统调用原理\r\n我们平时使用的程序均为用户程序,操作系统为用户程序提供管理,以防止用户程序进行超限访问，IO请求等可能会影响到其他进程的指令,因此操作系统提供了用户\r\n程序通过系统调用完成这些特殊指令的机制\r\n\r\n通俗点的解释:操作系统可以比作家长,用户程序比作孩子,这个“孩子”想要吃饭,但是它自己点火可能会把房子烧了,所以家长把厨房的门锁了起来,孩子如果想要吃饭,那么向家长发出请求,家长帮它去做\r\n\r\n具体实现:用户程序在发出系统调用时,操作系统将寄存器保存到内核栈,陷入到操作系统(此时模式由用户模式转向内核模式),操作系统处理陷阱(特权操作),随后返回程序,根据内核栈回复寄存器，跳到陷阱之后的程序计数器。\r\n\r\n####进程间切换\r\n目前的操作系统采用非协作方式,通过上下文切换的方式进行,通过时钟周期发送中断信号,操作系统定期通过中断处理程序取得cpu的控制权\r\n\r\n具体实现:\r\n1.**时钟周期发送定期中断，通过中断处理程序cpu控制权转向操作系统**\r\n2.**和之前陷入内核模式一样将寄存器保存在内核栈**\r\n3.在内存栈将目前进程寄存器保存在进程结构,将将要转入的进程结构保存在寄存器\r\n4.**从内核栈恢复到寄存器**\r\n\r\n那么操作系统如何选择我们要切换到哪个进程呢?\r\n\r\n##1.策略：进程调度\r\n1.几个概念:\r\n**工作负载**:我们大概可以理解成每个进程的特点\r\n**调度指标**:\r\n周转时间:任务完成时间减去任务到达系统的时间\r\n响应时间:任务到达系统到任务被响应的时间(IO)\r\n**常见算法(这里我们用排队办银行业务来比喻)**\r\n**FIFO**:常见的队列的先进先出\r\n**SJF**:最短时间优先(非抢占)(你几个人一起排的按时间短的先来,后来的接着排着)\r\n**STCF**:最短时间优先(抢占)(有比你快的能把你正办的业务给挤掉)\r\n(STCF适用于获得最好的性能(所有人取钱最快))\r\n\r\n**响应优先:**\r\n**RR**:轮转(你要取1000,先给你一百,你再接着排,给每个人一百,每个人接\r\n着排)\r\n##### 这不急吗?\r\n确实，这么做一定程度上性能是最低的,每个人排,每个人取走他的所有钱的时间都会晚,也就是周转时间最长\r\n但是操作系统不同于取钱的时,很多程度你打开后进行IO操作就是需要立即响应\r\n让你等个10秒等别的干完您再来,您就觉得操蛋了\r\n就像我本来想取1000,我中间闹肚子了想要10块,还是没排到我,你就想我先取10块别的再以后取,\r\n**现实生活中是个奇葩,但是在计算机里这种操作很多,毕竟我们的程序都是有\"交互\"的需求的,我们用鼠标按一下,就是想要有立刻的响应**\r\n\r\n这就体现了所谓“公平”(让每一个进程共同享有资源)和\"性能\"的矛盾\r\n但是,这些都是基于操作系统本身知道每个工作的长度(可以抽象理解成每个进程所需要的时间)的。但是现实中往往是不知道的,银行哪知道你进来要取多少钱呢?所以后续还要有继续的补充',b'1','操作系统对于进程的管理,可以分为底层的机制(受限直接进行)以及上层的策略(进程调度),通过底层机制和上层调度共同完成操作系统的进程切换并保护其数据。',b'0',2,NULL,NULL),(141,22,'2020-05-01 00:00:00','<<操作系统导论>>第七章问题解析','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3621867659,1152751757&fm=26&gp=0.jpg',109,'1.2.3题:都基于对于各种调度算法的简单理解,这里不多说了\r\n4.SJF：时间最短优先,所以FIFO要么相等，要么递增(队列自动符合从小的开始)\r\n5.每个进程的时间与时间分片相同,或者总时间小于时间分片(也就没分片)\r\n6.这个题的用意我依然没能理解.....\r\n自己试着写的C代码如下:\r\n```c\r\n#include<stdio.h>\r\n#include<math.h>\r\nint main()\r\n{\r\n\tint time=0;\r\n\tint last=0;\r\n\tint sum=0;\r\n\tfor(int i=1;i<=100;i++)\r\n\t{\r\n\t\tprintf(\"总响应时间为%d\\n\",i+(i+1));\r\n\t}\r\n\treturn 0;\r\n } \r\n```\r\n\r\n7.**RR的最坏情况(重点)**\r\n**也就是最后一个被响应的进程**\r\n我们设时间片为q，因此最坏的情况就是,前几个进程**每一个都占据一个时间分片**，**每次的时间分片只能响应一个进程，取得每一次时间分片的最低效率**\r\n即为:**(N-1)*q前N-1个进程工作每一个都是q**,最好的肯定是第一个进程,直接响应,为0 \r\n那么平均响应时间即为**（N-1)*q/2**',b'1','<<操作系统导论>>第七章问题解析',b'0',2,NULL,NULL),(142,22,'2020-05-02 00:00:00','<<操作系统导论>>进程与策略(2)-MLFQ队列调度笔记以及习题解析','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3621867659,1152751757&fm=26&gp=0.jpg',129,'##理论知识\r\n\r\n>MLFQ规则:有多级队列,cpu每次都执行最高级的进程,如果最高级有多个进程则使用轮转运行\r\n\r\n**每一个进程刚刚进入队列时都在最高级队列,工作用完整个时间片后,降低优先级,如果工作在时间内主动释放CPU,则优先级不变(此时系统局部判断它在进行IO中断释放cpu，因此属于交互程序)**\r\n\r\n这样使得每一个进程刚刚进入都被是做短进程优先进行,随着时间推移优先度降低\r\n，这样也同时使得短时间进行交互的IO密集型进程能够迅速被响应,随着时间推移操作系统会\"自主\"学习判断该队列是重视长时间计算进行的**计算密集型**,还是重视短时间IO交互的**IO密集型**\r\n\r\n**而加重号的机制一定程度上造成了三种问题:**\r\n1.饥饿问题:IO密集进程始终保持高优先级,使得低优先级计算进程始终难以得到CPU资源\r\n2.愚弄调度程序:一个进程可以每一次在时间片的最后调用一下IO操作,从而主动释放cpu,一直不断保持高优先级\r\n3.进程的变化:一个进程的状态是可以变化的,也就是说如果一个计算密集型某时间内表现为IO密集型进程,它将\"永无出头之日\"\r\n\r\n**我们所给出的解决方案**:\r\n问题1:每间隔一段时间就将系统所有工作全部放入最高优先级队列\r\n这里时间的设置要适度,太短的话会影响IO交互效率,太长的话长工作又会饥饿\r\n问题2,3:不把\"释放cpu\"的操作看作特殊操作,进程到达**队列时间片**后自动下沉,\r\n**（后期实验后的补充:我们可以通过设置IOdump使得之前操作过IO的工作在下一队列第一个被执行）**\r\n\r\n最终优化后的规则如下:![](http://img.xuhaobo.site/101)\r\n\r\n##**习题解析**:\r\n1.根据规则判断即可,主要考察对整个调度过程的熟悉\r\n2.\r\n实例1:![](http://img.xuhaobo.site/102)\r\n\r\n实例2:![](http://img.xuhaobo.site/103)\r\n\r\n实例3：![](http://img.xuhaobo.site/104)\r\n3.暂时还不太理解.......个人认为只要同时进入,且各队列时间分片相同即可\r\n4.大体思路:每99分钟发起一次1分钟的IO,时间分片为100分钟,发起IO时放弃cpu会给低优先级进程1分钟的时间进行,IO结束后由于机制的原因不会降低优先级,愚弄进程重新\"掌控大权\",因此为99%\r\n![](http://img.xuhaobo.site/105)\r\n5.-B 200(10/0.05)\r\n6.两者直观比较为:\r\n1.**未使用IO dump**：\r\n![](http://img.xuhaobo.site/106)\r\n进程下沉后按顺序在低级队列排队\r\n使用IO dump\r\n![](http://img.xuhaobo.site/107)\r\n进程0完成IO后在下沉后进行\"插队\"',b'1','MLFQ队列解决了前面说的\"既要优化周转时间,又要给用户很好的交互体验\",以及\"在时间片不可知的情况下进行短队列\"的问题',b'0',2,NULL,NULL),(143,22,'2020-05-05 00:00:00','<<操作系统导论>>进程与策略(3)调度:比例份额','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3621867659,1152751757&fm=26&gp=0.jpg',164,'## 1.彩票调度\r\n基本想法:在分配进程中给每个进程分配一些彩票份额(每个进程的彩票数不同),随后进程产生一个彩票的随机数,随机数对应哪张彩票哪个进程就被调度,由此可见,哪个进程彩票多,那么运行的机会也就大,但是具体的彩票如何分配目前尚没有太好的解决方案\r\n\r\n缺陷:在运行时间很短的情况下,不容易产生正常的比例\r\n## 2.步长调度\r\n根据进程的票数求出自己的步长值(进程票数越多步长越小)初始化每一个进程行程值为0,可以理解成所有的进程一起行走\r\n每一个选择\"走得最少\"的进程,那么步长小(**票数多的**)的走得最慢,也就一直被选择调度,\r\n好处:比彩票调度更精准\r\n缺陷:要记录全局状态以免新进入的进程(行程值为0),直接占有整个cpu',b'1','比例份额算法基于一个简单的想法:确保每个工作获得一定比例的cpu时间,而不是优化周转时间和响应时间',b'0',2,NULL,NULL),(144,22,'2020-05-06 00:00:00','<<操作系统导论>>虚拟内存(1)','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3621867659,1152751757&fm=26&gp=0.jpg',330,'>前几章一直在介绍cpu的虚拟化(让进程认为自己独有一个cpu),这次开始讲述内存的虚拟化(使每个进程认为自己独自拥有一段内存)\r\n\r\n## 1.虚拟内存的目的:\r\n1. 使内存\"透明化\",程序员在编写程序的过程中不用关心自己使用具体的内存地址\r\n1. 提高内存的使用效率,原始的cpu只能使用32位内存\r\n1. 提高对进程数据的保护,各自进程间内存互不干扰\r\n\r\n## 2.内存操作API:\r\n这个算是老朋友了,早在学习c语言的时候已经见过面了,这里不细说了\r\n\r\n## 3.内存的地址转换机制(保证大部分时候由指令直接访问硬件,关键时刻操作系统介入):\r\n#### 1.原始的动态重定位:\r\n通过在创建进程时将内存基址以及界限寄存器存入指定值(内存基址以及界限寄存器由硬件实现)\r\n在之后取值执行访问内存时通过基址+虚拟地址重定向实现,超过界限寄存器以及使用内核指令则会引起操作系统介入,调用相关的异常处理程序\r\n\r\n**该转换机制的缺陷很明显,每一次分配指定的基址的同时会为该进程分配一大块空间,会造成很大的内存浪费**\r\n\r\n#### 1.分段(将进程中的各内存空间解耦):\r\n首先明确一些进程中的内存空间:\r\n代码段:我们所编写的代码部分,用于取址执行\r\n栈:用于临时分配的变量(如int a=1),**存储方向为地址由大向小存储**\r\n堆:用于动态请求的内存块，**存储方向为地址由小向大存储**\r\n![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588789492427&di=7e5af1dd22a2c33e938424281c32e450&imgtype=0&src=http%3A%2F%2Fimg4.imgtn.bdimg.com%2Fit%2Fu%3D3388502434%2C3629963514%26fm%3D214%26gp%3D0.jpg)\r\n以之前说的三段代码段举例,我们把原本的进程内存空间切成一段一段的,每一段按照类似于原始的基址寄存器的方式存储,需要多组的基址寄存器\r\n**支持共享**:在段寄存器上添加保护位,设置代码以及部分数据为只读段,可以由其他进程共用而无法被修改,**类似于公共场所的公用电梯,你可以使用它但是不能把它的电缆给偷走**\r\n**引出\"段错误\"**:程序访问的虚拟内存超过了给定的分段内存的段以外的位置\r\n优势:我们将内存细分为一段一段的形式,使用时再动态地分配段,一定程序上避免了浪费\r\n\r\n缺点:外部碎片现象,我们分配的段中依然会有空余空间,分裂的段中空余空间会很多,每一个空余空间假如是1k,我们现在要使用一块10k的内存,本来有十个段都剩1k,这种时候却不能顺利地使用',b'1','前几章一直在介绍cpu的虚拟化(让进程认为自己独有一个cpu),这次开始讲述内存的虚拟化(使每个进程认为自己独自拥有一段内存)',b'0',2,'2020-08-07 23:15:48',NULL),(146,23,'2020-05-17 18:23:51','给c语言初学者的计算机基础补充','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3338099217,3521170801&fm=26&gp=0.jpg',0,'>本人在对同学进行c语言方面的帮助过程中深感大学c语言教育之不足,很多人对于计算机都知其然而不知其所以然,故写此文来告诉迷惑的各位,什么是计算机,c究竟做了什么,c是如何运行的\r\n\r\n**注:本文并未对计算机底层有太深入的探讨,仅是一篇为初学者的科普文章,若有相关大佬欢迎指正,望轻喷~~~**\r\n\r\n**首先我们要明确一下计算机的一个计算的过程,究其根本就是一件事:cpu对于内存进行计算,写入和读出操作**\r\n\r\n无论是我们的**\"程序\"**,还是我们程序中的**数据**(不管是你int的还是malloc的),都是被装在内存里被cpu读取进行计算的\r\n\r\n我们的每一行c代码经过编译链接等过程(这里可以不作太大的理解),如同密码一\r\n样的,变成了由0和1组成的可执行文件,在我们点击\"运行\"的瞬间,计算机将我们的代码从\"磁盘\"读入\"内存\",并开始执行(初学者可以将我们的代码也视为一种数据,),它的本质与我们的变量,数组都是一样的,都是数据,只是它的作用是控制计算机来执行而已',b'0','本人在对同学进行c语言方面的帮助过程中深感大学c语言教育之不足,很多人对于计算机都知其然而不知其所以然,故写此文来告诉迷惑的各位,什么是计算机,c究竟做了什么,c是如何运行的',b'0',2,NULL,NULL),(147,3,'2020-05-19 22:03:25','<<深入理解计算机系统>>第二章bomblab 1~4炸弹解析','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3020495497,2923874859&fm=26&gp=0.jpg',208,'>一直觉得CSAPP的LAB一直没有做很可惜,这次下决心做一下,先从反汇编的bomb lab做起，1--4个炸弹拆解难度其实不大,考察的就是对汇编语言的一种基础的掌握,自己一开始光用眼看楞想始终觉得困难,后来发现每一句汇编代码自己都去加一句解释,一下子\"拆弹\"速度快了许多\r\n\r\n###前期预备代码查看\r\n**说明:本文只讲述下思路,具体GDB调试的方式还请百度百科(毕竟我就这么干的)\r\n**\r\n![](http://img.xuhaobo.site/108)\r\n**可以看出我们拆弹的方式是通过调用read_line这个函数,根据我们输入的值来判定输出**\r\n再来一张图解释下它的机制:\r\n![](http://img.xuhaobo.site/109)\r\n执行了**explode_bomb**这个函数时即\"拆弹失败\",出现\"爆炸\"\r\n###炸弹一:**字符串相等**\r\n解析:主要内容就是输入一个字符串与给定内存存储的字符串相等,可以在上图看出给定函数的参数有一个地址为0x402400\r\n我们尝试查看该内存位置的数据:\r\n![](http://img.xuhaobo.site/110)\r\n(最后还是要补充下:这个要用gdb看\"**整个字符串**\"的方式)\r\n我们输入该字符串结果如图:\r\n![](http://img.xuhaobo.site/111)\r\n轻松通过(其实自己也试了半天哈哈哈哈)\r\n\r\n###炸弹二:**指定乘二规律的数组**\r\n解析:本题让我们输入**一个数组(以空格间隔),我们主要在逆向代码里分析的就是数组每个数的关系以及第一个数字必定为1**\r\n\r\n由此我们可以得出数组为 1 2 4 8 16 32，个人具体分析过程代码如下(已经通过后缀注释)(关键是看出这种以四间隔的内存访问事实上可以理解为数组)\r\n\r\n\r\n###炸弹三:**跳跃到指定可以访问的位置**\r\n关键在于那句jmp代码,我们通过访问0x402470的一整块内存可以发现唯一可以跳跃到的只有b9那一个位置,由此确定了我们要输入的两个值\r\n![](http://img.xuhaobo.site/112)\r\n\r\n\r\n**(注意q后缀指定为双字,算是x86汇编的一个特色)**\r\n```\r\n0000000000400f43 <phase_3>:\r\n  400f43:\t48 83 ec 18          \tsub    $0x18,%rsp            #栈指针减18\r\n  400f47:\t48 8d 4c 24 0c       \tlea    0xc(%rsp),%rcx         #12\r\n  400f4c:\t48 8d 54 24 08       \tlea    0x8(%rsp),%rdx        #8\r\n  400f51:\tbe cf 25 40 00       \tmov    $0x4025cf,%esi         #一个内存地址\r\n  400f56:\tb8 00 00 00 00       \tmov    $0x0,%eax             #将0移入eax中\r\n  400f5b:\te8 90 fc ff ff       \tcallq  400bf0 <__isoc99_sscanf@plt>\r\n  400f60:\t83 f8 01             \tcmp    $0x1,%eax           #将输入的数字数量与1相比较\r\n  400f63:\t7f 05                \tjg     400f6a <phase_3+0x27>        #结果大于1则继续\r\n  400f65:\te8 d0 04 00 00       \tcallq  40143a <explode_bomb>\r\n  400f6a:\t83 7c 24 08 07       \tcmpl   $0x7,0x8(%rsp)           #将数组[2]与7立即数对比\r\n  400f6f:\t77 3c                \tja     400fad <phase_3+0x6a>        #若小于7则爆炸\r\n  400f71:\t8b 44 24 08          \tmov    0x8(%rsp),%eax         #将数组[2]放入eax中\r\n  400f75:\tff 24 c5 70 24 40 00 \tjmpq   *0x402470(,%rax,8)         #将pc寄存器指令转移至*(0x402470+8*num[2])处(注意为4字,其实只可以跳到400fb9)\r\n  400f7c:\tb8 cf 00 00 00       \tmov    $0xcf,%eax                   \r\n  400f81:\teb 3b                \tjmp    400fbe <phase_3+0x7b>        \r\n  400f83:\tb8 c3 02 00 00       \tmov    $0x2c3,%eax\r\n  400f88:\teb 34                \tjmp    400fbe <phase_3+0x7b>\r\n  400f8a:\tb8 00 01 00 00       \tmov    $0x100,%eax\r\n  400f8f:\teb 2d                \tjmp    400fbe <phase_3+0x7b>\r\n  400f91:\tb8 85 01 00 00       \tmov    $0x185,%eax\r\n  400f96:\teb 26                \tjmp    400fbe <phase_3+0x7b>\r\n  400f98:\tb8 ce 00 00 00       \tmov    $0xce,%eax\r\n  400f9d:\teb 1f                \tjmp    400fbe <phase_3+0x7b>\r\n  400f9f:\tb8 aa 02 00 00       \tmov    $0x2aa,%eax\r\n  400fa4:\teb 18                \tjmp    400fbe <phase_3+0x7b>\r\n  400fa6:\tb8 47 01 00 00       \tmov    $0x147,%eax\r\n  400fab:\teb 11                \tjmp    400fbe <phase_3+0x7b>\r\n  400fad:\te8 88 04 00 00       \tcallq  40143a <explode_bomb>\r\n  400fb2:\tb8 00 00 00 00       \tmov    $0x0,%eax\r\n  400fb7:\teb 05                \tjmp    400fbe <phase_3+0x7b>\r\n  400fb9:\tb8 37 01 00 00       \tmov    $0x137,%eax            #跳跃到之后赋值\r\n  400fbe:\t3b 44 24 0c          \tcmp    0xc(%rsp),%eax          #将num[3]的值与我们跳转的那个地方值比较,必须相等\r\n  400fc2:\t74 05                \tje     400fc9 <phase_3+0x86>\r\n  400fc4:\te8 71 04 00 00       \tcallq  40143a <explode_bomb>\r\n  400fc9:\t48 83 c4 18          \tadd    $0x18,%rsp\r\n  400fcd:\tc3                   \tretq  \r\n```\r\n\r\n###炸弹四:输入值只可以比递归函数计算结果小或是相等,递归函数(fun4)的最后一段永远不能被执行\r\n\r\n**一定要理解的就是递归结果的eax必须为零,所以fun4的最后的一段不能够执行(会使eax>0)**\r\n\r\n```\r\n0000000000400fce <func4>:                                  #edx ：0xe,# esi:0,%edi :第一个输入的数\r\n  400fce:\t48 83 ec 08          \tsub    $0x8,%rsp           #栈\r\n  400fd2:\t89 d0                \tmov    %edx,%eax           # edx放入eax\r\n  400fd4:\t29 f0                \tsub    %esi,%eax            #eax减去esi\r\n  400fd6:\t89 c1                \tmov    %eax,%ecx             #ecx=edx-esi eax=edx-esi\r\n  400fd8:\tc1 e9 1f             \tshr    $0x1f,%ecx            #将ecx逻辑右移31位(取最高位)\r\n  400fdb:\t01 c8                \tadd    %ecx,%eax              #eax=eax+eax>>31\r\n  400fdd:\td1 f8                \tsar    %eax                #将eax算数右移1位\r\n  400fdf:\t8d 0c 30             \tlea    (%rax,%rsi,1),%ecx         \r\n  400fe2:\t39 f9                \tcmp    %edi,%ecx             #比较ecx和第一个输入的值\r\n  400fe4:\t7e 0c                \tjle    400ff2 <func4+0x24>       #小于等于第一个输入的值\r\n  400fe6:\t8d 51 ff             \tlea    -0x1(%rcx),%edx             #将rcs-1赋给edx\r\n  400fe9:\te8 e0 ff ff ff       \tcallq  400fce <func4>         #重新调用func4\r\n  400fee:\t01 c0                \tadd    %eax,%eax\r\n  400ff0:\teb 15                \tjmp    401007 <func4+0x39>\r\n  400ff2:\tb8 00 00 00 00       \tmov    $0x0,%eax               #将eax设为0\r\n  400ff7:\t39 f9                \tcmp    %edi,%ecx            \r\n  400ff9:\t7d 0c                \tjge    401007 <func4+0x39>   #等于时结束\r\n  400ffb:\t8d 71 01             \tlea    0x1(%rcx),%esi       #注意必须在上面结束而不能跑到下面来,不然eax的值就不能为一,也就是说\"要么大,要么等\"\r\n  400ffe:\te8 cb ff ff ff       \tcallq  400fce <func4>\r\n  401003:\t8d 44 00 01          \tlea    0x1(%rax,%rax,1),%eax        \r\n  401007:\t48 83 c4 08          \tadd    $0x8,%rsp\r\n  40100b:\tc3                   \tretq   \r\n\r\n000000000040100c <phase_4>:\r\n  40100c:\t48 83 ec 18          \tsub    $0x18,%rsp\r\n  401010:\t48 8d 4c 24 0c       \tlea    0xc(%rsp),%rcx     #第二个输入\r\n  401015:\t48 8d 54 24 08       \tlea    0x8(%rsp),%rdx      #第一个输入\r\n  40101a:\tbe cf 25 40 00       \tmov    $0x4025cf,%esi\r\n  40101f:\tb8 00 00 00 00       \tmov    $0x0,%eax\r\n  401024:\te8 c7 fb ff ff       \tcallq  400bf0 <__isoc99_sscanf@plt>\r\n  401029:\t83 f8 02             \tcmp    $0x2,%eax\r\n  40102c:\t75 07                \tjne    401035 <phase_4+0x29>         #输入两个数字\r\n  40102e:\t83 7c 24 08 0e       \tcmpl   $0xe,0x8(%rsp)        #将输入的第一个数与0xe进行比较,第一个数必须小于等于0xe\r\n  401033:\t76 05                \tjbe    40103a <phase_4+0x2e>\r\n  401035:\te8 00 04 00 00       \tcallq  40143a <explode_bomb>\r\n  40103a:\tba 0e 00 00 00       \tmov    $0xe,%edx                   #将0xe放入edx\r\n  40103f:\tbe 00 00 00 00       \tmov    $0x0,%esi                   #将0x0放入esi\r\n  401044:\t8b 7c 24 08          \tmov    0x8(%rsp),%edi               #将第一个输入的数放入edi\r\n  401048:\te8 81 ff ff ff       \tcallq  400fce <func4>                #调用函数\r\n  40104d:\t85 c0                \ttest   %eax,%eax                    \r\n  40104f:\t75 07                \tjne    401058 <phase_4+0x4c>          #函数计算后的eax值必须为零(排除了等于的情况)\r\n  401051:\t83 7c 24 0c 00       \tcmpl   $0x0,0xc(%rsp)              #第二个输入的数必为0\r\n  401056:\t74 05                \tje     40105d <phase_4+0x51>\r\n  401058:\te8 dd 03 00 00       \tcallq  40143a <explode_bomb>\r\n  40105d:\t48 83 c4 18          \tadd    $0x18,%rsp\r\n  401061:\tc3                   \tretq \r\n```',b'1','一直觉得CSAPP的LAB一直没有做很可惜,这次下决心做一下,先从反汇编的bomb lab做起~，1~4个炸弹拆解难度其实不大,考察的就是对汇编语言的一种基础的掌握,自己一开始光用眼看楞想始终觉得困难,后来发现每一句汇编代码自己都去加一句解释,一下子\"拆弹\"速度快了许多',b'0',2,'2020-08-07 23:15:48',NULL);
INSERT INTO `article` VALUES (148,3,'2020-05-21 21:08:59','<<深入理解计算机系统>>第二章bomblab 5~6炸弹解析','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3020495497,2923874859&fm=26&gp=0.jpg',44,'>与1到4的炸弹间隔了一天的时间(给这网站加了个点赞功能哈哈哈),今天算是硬着头皮把lab2做完了,不得不说难度还是挺大的,尤其第六个链表是真的晕...\r\n\r\n###五:根据输入数字进行运算与查看的字符串匹配\r\n**解析**:第五个炸弹感觉还是比较好做的,个人认为细心一点,注意转换机制就可以,通过查询内存可以看到要求我们最终输出的字符串:\r\n![](http://img.xuhaobo.site/114)\r\n我们中间可以看见我们所需要提取字符的字符串0x4024b0,之后通过GDB查看:\r\n![](http://img.xuhaobo.site/113)\r\n代码如下:\r\n\r\n```\r\n0000000000401062 <phase_5>:\r\n  401062:\t53                   \tpush   %rbx        \r\n  401063:\t48 83 ec 20          \tsub    $0x20,%rsp    \r\n  401067:\t48 89 fb             \tmov    %rdi,%rbx     \r\n  40106a:\t64 48 8b 04 25 28 00 \tmov    %fs:0x28,%rax              \r\n  401071:\t00 00 \r\n  401073:\t48 89 44 24 18       \tmov    %rax,0x18(%rsp)\r\n  401078:\t31 c0                \txor    %eax,%eax       \r\n  40107a:\te8 9c 02 00 00       \tcallq  40131b <string_length>     \r\n  40107f:\t83 f8 06             \tcmp    $0x6,%eax         \r\n  401082:\t74 4e                \tje     4010d2 <phase_5+0x70>\r\n  401084:\te8 b1 03 00 00       \tcallq  40143a <explode_bomb>\r\n  401089:\teb 47                \tjmp    4010d2 <phase_5+0x70>\r\n  40108b:\t0f b6 0c 03          \tmovzbl (%rbx,%rax,1),%ecx #将所输入的字符串零拓展到双字放在ecx里      \r\n  40108f:\t88 0c 24             \tmov    %cl,(%rsp)              #最后一个字节赋给rsp\r\n  401092:\t48 8b 14 24          \tmov    (%rsp),%rdx            #再将值赋给rdx\r\n  401096:\t83 e2 0f             \tand    $0xf,%edx              #将edx的值改为输入的值的最后一个字节\r\n  401099:\t0f b6 92 b0 24 40 00 \tmovzbl 0x4024b0(%rdx),%edx       #将num[最后一个字节]的值赋给edx\r\n  4010a0:\t88 54 04 10          \tmov    %dl,0x10(%rsp,%rax,1)     #再将edx的最后一个字节付给nums[输入值最后一个字节]\r\n  4010a4:\t48 83 c0 01          \tadd    $0x1,%rax                 \r\n  4010a8:\t48 83 f8 06          \tcmp    $0x6,%rax\r\n  4010ac:\t75 dd                \tjne    40108b <phase_5+0x29>      #循环6次\r\n  4010ae:\tc6 44 24 16 00       \tmovb   $0x0,0x16(%rsp)        \r\n\r\n  4010b3:\tbe 5e 24 40 00       \tmov    $0x40245e,%esi           #再将之前所得的两个字符串互相做比较\r\n  4010b8:\t48 8d 7c 24 10       \tlea    0x10(%rsp),%rdi        \r\n  4010bd:\te8 76 02 00 00       \tcallq  401338 <strings_not_equal>\r\n  4010c2:\t85 c0                \ttest   %eax,%eax\r\n  4010c4:\t74 13                \tje     4010d9 <phase_5+0x77>\r\n  4010c6:\te8 6f 03 00 00       \tcallq  40143a <explode_bomb>\r\n\r\n  4010cb:\t0f 1f 44 00 00       \tnopl   0x0(%rax,%rax,1)\r\n  4010d0:\teb 07                \tjmp    4010d9 <phase_5+0x77>\r\n  4010d2:\tb8 00 00 00 00       \tmov    $0x0,%eax          \r\n  4010d7:\teb b2                \tjmp    40108b <phase_5+0x29>  \r\n  4010d9:\t48 8b 44 24 18       \tmov    0x18(%rsp),%rax\r\n  4010de:\t64 48 33 04 25 28 00 \txor    %fs:0x28,%rax\r\n  4010e5:\t00 00 \r\n  4010e7:\t74 05                \tje     4010ee <phase_5+0x8c>\r\n  4010e9:\te8 42 fa ff ff       \tcallq  400b30 <__stack_chk_fail@plt>\r\n  4010ee:\t48 83 c4 20          \tadd    $0x20,%rsp\r\n  4010f2:\t5b                   \tpop    %rbx\r\n  4010f3:\tc3                   \tretq   \r\n```\r\n\r\n###六:根据内存构建一个递减的链表(重点)\r\n解析:不得不说,真心难得批爆....中间各种地址就快把我给绕晕了:tw-1f480:\r\n梳理一下整个程序的运行过程\r\n-**输入数字**:如同我们之前一样输入六个数字\r\n-**判断数据范围**:程序要求你输入的数字各不相同且小于6\r\n-**数字处理**:将所有数字更新x=7-x;\r\n-**根据数据寻找地址并存在栈中**:注意这里就开始晕了,我们在栈中存储的,是链表的地址而非值\r\n-**根据换算出的地址构建链表**:这里我们的链表结构体就是一个如下16字节的地址空间,头八个字节地址存储我们最后要递增的值,后面是地址\r\n![](http://img.xuhaobo.site/117)\r\n-**判断我们构建的链表是否满足要求**:判断是否递增\r\n\r\n这里推荐一些自己反汇编的小方法:\r\n1.多写注释,实在不懂就画图\r\n2.将循环的部分与循环体与其他部分空行分隔开看,能够更直观\r\n\r\n加上自己注释的汇编代码如下:\r\n```\r\n00000000004010f4 <phase_6>:\r\n  4010f4:\t41 56                \tpush   %r14\r\n  4010f6:\t41 55                \tpush   %r13\r\n  4010f8:\t41 54                \tpush   %r12\r\n  4010fa:\t55                   \tpush   %rbp\r\n  4010fb:\t53                   \tpush   %rbx\r\n\r\n  4010fc:\t48 83 ec 50          \tsub    $0x50,%rsp\r\n  401100:\t49 89 e5             \tmov    %rsp,%r13      \r\n  401103:\t48 89 e6             \tmov    %rsp,%rsi      \r\n  401106:\te8 51 03 00 00       \tcallq  40145c <read_six_numbers>   \r\n  40110b:\t49 89 e6             \tmov    %rsp,%r14      \r\n  40110e:\t41 bc 00 00 00 00    \tmov    $0x0,%r12d     \r\n\r\n  401114:\t4c 89 ed             \tmov    %r13,%rbp      \r\n  401117:\t41 8b 45 00          \tmov    0x0(%r13),%eax \r\n  40111b:\t83 e8 01             \tsub    $0x1,%eax      \r\n  40111e:\t83 f8 05             \tcmp    $0x5,%eax      \r\n  401121:\t76 05                \tjbe    401128 <phase_6+0x34>  #输入的每一个数都要小于等于6\r\n  401123:\te8 12 03 00 00       \tcallq  40143a <explode_bomb>\r\n  401128:\t41 83 c4 01          \tadd    $0x1,%r12d      \r\n  40112c:\t41 83 fc 06          \tcmp    $0x6,%r12d      \r\n  401130:\t74 21                \tje     401153 <phase_6+0x5f>   \r\n  401132:\t44 89 e3             \tmov    %r12d,%ebx         #将它的下一位下标付过来开始遍历\r\n\r\n  401135:\t48 63 c3             \tmovslq %ebx,%rax          \r\n  401138:\t8b 04 84             \tmov    (%rsp,%rax,4),%eax     \r\n  40113b:\t39 45 00             \tcmp    %eax,0x0(%rbp)         \r\n  40113e:\t75 05                \tjne    401145 <phase_6+0x51> #这六个数中每一个数均不相同\r\n  401140:\te8 f5 02 00 00       \tcallq  40143a <explode_bomb>\r\n  401145:\t83 c3 01             \tadd    $0x1,%ebx      \r\n  401148:\t83 fb 05             \tcmp    $0x5,%ebx     \r\n  40114b:\t7e e8                \tjle    401135 <phase_6+0x41> \r\n\r\n  40114d:\t49 83 c5 04          \tadd    $0x4,%r13    \r\n  401151:\teb c1                \tjmp    401114 <phase_6+0x20>   \r\n\r\n#现在我们已经知道每个数都小于等于6且每个数都不相同(确立筛选条件)\r\n  \r\n  401153:\t48 8d 74 24 18       \tlea    0x18(%rsp),%rsi\r\n  401158:\t4c 89 f0             \tmov    %r14,%rax      #将rsp赋给rax\r\n  40115b:\tb9 07 00 00 00       \tmov    $0x7,%ecx        #将7赋给ecx\r\n  \r\n  401160:\t89 ca                \tmov    %ecx,%edx      #将7赋给edx\r\n  401162:\t2b 10                \tsub    (%rax),%edx     #使用edx将去esp所指的内容值(我们所输入的最后一个值)\r\n  401164:\t89 10                \tmov    %edx,(%rax)     #将该值写回去  \r\n  401166:\t48 83 c0 04          \tadd    $0x4,%rax       #移动到倒数第二个输入的值\r\n  40116a:\t48 39 f0             \tcmp    %rsi,%rax       #将rsi赋给rax\r\n  40116d:\t75 f1                \tjne    401160 <phase_6+0x6c>\r\n\r\n#该循环目的:将每一个值都用7减一下\r\n  40116f:\tbe 00 00 00 00       \tmov    $0x0,%esi     #将0赋给esi\r\n  401174:\teb 21                \tjmp    401197 <phase_6+0xa3>\r\n\r\n\r\n  401176:\t48 8b 52 08          \tmov    0x8(%rdx),%rdx       #将0赋给rdx\r\n  40117a:\t83 c0 01             \tadd    $0x1,%eax            #eax加1\r\n  40117d:\t39 c8                \tcmp    %ecx,%eax             #与ecx作比较\r\n  40117f:\t75 f5                \tjne    401176 <phase_6+0x82>  #若不等于的情况\r\n  401181:\teb 05                \tjmp    401188 <phase_6+0x94>   #此时eax就是之前eax的值\r\n\r\n\r\n##过程:将我们输入的数值转换为实际的地址\r\n  401183:\tba d0 32 60 00       \tmov    $0x6032d0,%edx          #若ecx小于1\r\n  401188:\t48 89 54 74 20       \tmov    %rdx,0x20(%rsp,%rsi,2)     #将0x6032d0或者0写入以四字为字长的存储空间\r\n  40118d:\t48 83 c6 04          \tadd    $0x4,%rsi              #让rsi由0加四\r\n  401191:\t48 83 fe 18          \tcmp    $0x18,%rsi             \r\n  401195:\t74 14                \tje     4011ab <phase_6+0xb7>\r\n  401197:\t8b 0c 34             \tmov    (%rsp,%rsi,1),%ecx  #将第一个值写入ecx      \r\n  40119a:\t83 f9 01             \tcmp    $0x1,%ecx              #比较ecx与1\r\n  40119d:\t7e e4                \tjle    401183 <phase_6+0x8f>    #若ecx小于1    \r\n  40119f:\tb8 01 00 00 00       \tmov    $0x1,%eax               #若大于,则eax为1\r\n  4011a4:\tba d0 32 60 00       \tmov    $0x6032d0,%edx          \r\n  4011a9:\teb cb                \tjmp    401176 <phase_6+0x82>   #循环回去\r\n\r\n##根据转换来的地址在内存中建立链表 注意此时0x20(寄存器)是我们链表的地址的地址,是一块存储着之前转换出的地址的空间\r\n  4011ab:\t48 8b 5c 24 20       \tmov    0x20(%rsp),%rbx        #起始地址的值\r\n  4011b0:\t48 8d 44 24 28       \tlea    0x28(%rsp),%rax\r\n  4011b5:\t48 8d 74 24 50       \tlea    0x50(%rsp),%rsi\r\n  4011ba:\t48 89 d9             \tmov    %rbx,%rcx           #获得链表头的地址 \r\n  4011bd:\t48 8b 10             \tmov    (%rax),%rdx        #获得下一位地址\r\n  4011c0:\t48 89 51 08          \tmov    %rdx,0x8(%rcx)     #将下一位的地址赋给链表当前结点的下一位\r\n  4011c4:\t48 83 c0 08          \tadd    $0x8,%rax          \r\n  4011c8:\t48 39 f0             \tcmp    %rsi,%rax          #循环6次,6个结点\r\n  4011cb:\t74 05                \tje     4011d2 <phase_6+0xde>\r\n  4011cd:\t48 89 d1             \tmov    %rdx,%rcx        #获得当前结点地址(同时也是链表头的地址)\r\n  4011d0:\teb eb                \tjmp    4011bd <phase_6+0xc9>\r\n  4011d2:\t48 c7 42 08 00 00 00 \tmovq   $0x0,0x8(%rdx)      #以零结尾\r\n  4011d9:\t00 \r\n\r\n##根据之前所给的筛选条件进行比较  (注意这里刚才所赋的起始地址的值也没有变化)\r\n  4011da:\tbd 05 00 00 00       \tmov    $0x5,%ebp        #将5赋给ebp(遍历所有结点)\r\n  4011df:\t48 8b 43 08          \tmov    0x8(%rbx),%rax     #下一个结点地址赋给rax\r\n  4011e3:\t8b 00                \tmov    (%rax),%eax      #赋值\r\n  4011e5:\t39 03                \tcmp    %eax,(%rbx)         #与上一个值比较\r\n  4011e7:\t7d 05                \tjge    4011ee <phase_6+0xfa>   #必须小于等于上一个值\r\n  4011e9:\te8 4c 02 00 00       \tcallq  40143a <explode_bomb>\r\n  4011ee:\t48 8b 5b 08          \tmov    0x8(%rbx),%rbx\r\n  4011f2:\t83 ed 01             \tsub    $0x1,%ebp\r\n  4011f5:\t75 e8                \tjne    4011df <phase_6+0xeb>   #循环，\r\n  4011f7:\t48 83 c4 50          \tadd    $0x50,%rsp\r\n  4011fb:\t5b                   \tpop    %rbx\r\n  4011fc:\t5d                   \tpop    %rbp\r\n  4011fd:\t41 5c                \tpop    %r12\r\n  4011ff:\t41 5d                \tpop    %r13\r\n  401201:\t41 5e                \tpop    %r14\r\n  401203:\tc3                   \tretq   \r\n\r\n0000000000401204 <fun7>:\r\n  401204:\t48 83 ec 08          \tsub    $0x8,%rsp\r\n  401208:\t48 85 ff             \ttest   %rdi,%rdi\r\n  40120b:\t74 2b                \tje     401238 <fun7+0x34>\r\n  40120d:\t8b 17                \tmov    (%rdi),%edx\r\n  40120f:\t39 f2                \tcmp    %esi,%edx\r\n  401211:\t7e 0d                \tjle    401220 <fun7+0x1c>\r\n  401213:\t48 8b 7f 08          \tmov    0x8(%rdi),%rdi\r\n  401217:\te8 e8 ff ff ff       \tcallq  401204 <fun7>\r\n  40121c:\t01 c0                \tadd    %eax,%eax\r\n  40121e:\teb 1d                \tjmp    40123d <fun7+0x39>\r\n  401220:\tb8 00 00 00 00       \tmov    $0x0,%eax\r\n  401225:\t39 f2                \tcmp    %esi,%edx\r\n  401227:\t74 14                \tje     40123d <fun7+0x39>\r\n  401229:\t48 8b 7f 10          \tmov    0x10(%rdi),%rdi\r\n  40122d:\te8 d2 ff ff ff       \tcallq  401204 <fun7>\r\n  401232:\t8d 44 00 01          \tlea    0x1(%rax,%rax,1),%eax\r\n  401236:\teb 05                \tjmp    40123d <fun7+0x39>\r\n  401238:\tb8 ff ff ff ff       \tmov    $0xffffffff,%eax\r\n  40123d:\t48 83 c4 08          \tadd    $0x8,%rsp\r\n  401241:\tc3                   \tretq   \r\n```\r\n\r\n![](http://img.xuhaobo.site/118)\r\n####看到最后\"胜利\"的结果还是很有满足感的,没白肝哈哈哈哈',b'1','与1到4的炸弹间隔了一天的时间(给这网站加了个点赞功能哈哈哈),今天算是硬着头皮把lab2做完了,不得不说难度还是挺大的,尤其第六个链表是真的晕...',b'0',2,'2020-08-07 23:15:48',NULL),(149,3,'2020-05-25 14:58:33','<<深入理解计算机系统>>lab3 attacklab 1~3解析(代码注入攻击)','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3020495497,2923874859&fm=26&gp=0.jpg',156,'>又开始刷起了lab3,书中关于缓冲区溢出攻击实验的讲解部分自己看得时候就一知半解,不得不说开始看得真.一脸懵逼(自己大方承认自己是FW),最后无奈地看了下网上对本实验的解析才掌握了一点点其中的原理(不得不说这种注入代码还是很奇妙的哈哈哈哈哈)\r\n\r\n###一:通过注入代码覆盖当前函数的返回地址\r\n算是最简单的一道了(无奈),考察的就是缓冲区溢出攻击机制的基本理解,也算是解决后面问题的基石\r\n\r\n原理阐述:当我们编写c语言的函数输入字符串时,我们会输入一个字符串到栈中,\r\n但是有趣的是c语言早期的输入机制并没有对于字节数的检查,这就使得我们可以\r\n不按**\"规矩\"**地输入我们的字符串。\r\n举个例子吧:\r\n```c\r\nchar str[10];    //定义一个字符数组,同时栈上为该临时变量分配10个字节的空间\r\ngets(str);   //将我们要输入的字符串输入到str中\r\n```\r\n但是问题在于,我们可以**\"听话\"**地把字符串发过去,但是同样也可以发送比自己定义的长度更大的字符串,那么此时栈并没有为这多余的部分多分配空间,我们输入的字符就会覆盖栈上面的内容,学习过汇编的我们知道,当我们在调用函数时,我们的返回地址也同样保存在栈中,因此我们可以通过改变返回地址的方式将rip值改变到我们自己想让它运行的地方\r\n\r\n这便是**\"缓冲区溢出攻击\"**的原理所在,我们可以让它通过返回地址重定向到别的代码段运行,同样也可以运行我们自己刚才在栈中注入的代码\r\n(是不是就很神奇:tw-1f44d:)\r\n\r\n**本题的内容便是让你通过注入代码改变返回地址**\r\n\r\n首先我们分析下初始的代码找到缓冲区的长度:\r\n![](http://img.xuhaobo.site/121)\r\n长度为40那么我们可以推出栈的地址并进行覆盖\r\n我们直接注入一段数据段,能够覆盖返回地址即可~~\r\n**touch1函数的地址如下**\r\n![](http://img.xuhaobo.site/122)\r\n我们所注入的如下:(每一个字节用空格隔开)\r\n![注入的数据](http://img.xuhaobo.site/123 \"注入的数据\")\r\n将我们的字符文件转换为字节码文件\r\n![](http://img.xuhaobo.site/125)\r\n结果如下,我们的函数成功地重定向到了touch1函数的地址\r\n![](http://img.xuhaobo.site/126)\r\n###二:重定向到我们注入的代码段\r\n大体思路仍建立在改变返回地址的基础上,不过复杂了一些\r\n需求要求不仅触碰到touch2并且要输入指定的数字(下载lab包给的cookie)\r\n**思路**:我们想要输入指定数字,必须要先让机器执行这部分的代码,我们可以根据栈地址使得函数ret重定向到我们注入的部分进行,而我们重定向的部分可以将touch3的地址push到栈中再ret,那么我们就直接重定向到touch3并且已经做好了之前的\"准备了\"\r\n我们需要看一下我们分配buf后的栈指针值为多少(为了重定向到我们输入的地址)\r\n![](http://img.xuhaobo.site/127)\r\ngdb调试过程中我们可以确认此时的栈指针值\r\n随后输入我们要输入的汇编代码并获取到该代码的自己码值\r\n经过编写.s文件编译链接再通过objdump获取的内容如下:\r\n![](http://img.xuhaobo.site/128)\r\n我们可以得到要注入的部分了\r\n![](http://img.xuhaobo.site/129)\r\n结果如下\r\n![](http://img.xuhaobo.site/130)\r\n\r\n###三:防止自己注入的数据被覆盖\r\n1.本题与上一道有很大的相似之处,不过本题要输入的是字符而非数字,并且在touch3中调用了一个函数用于比较每一位的字符\r\n这就中间出现了一个问题,也是本问题的关键:\r\n在这个函数中,局部变量会覆盖我们之前的堆栈,测试将我们的cookie所转换的\r\nascii码字符串放在rsp的顶部\r\n通过gdb在touch3中调试调用前已经调用后:\r\n**执行前**:![](http://img.xuhaobo.site/131)\r\n**执行后**:![](http://img.xuhaobo.site/132)\r\n可以看出位于第三行的我们的ascii码字符串被覆盖(0x31363534和0x31356564)\r\n而ca8的一片空间可用且不受调用函数的影响,而我们的目的,就是把我们的**数据**放到一个安全的区域0x5561dca8,将0x5561dca8作为输入保存字符串的地址\r\n汇编代码如下:\r\n![](http://img.xuhaobo.site/133)\r\n注入的数据如下(省略之前所说的字节化等固定步骤)\r\n![](http://img.xuhaobo.site/134)\r\n**这里的地址自行根据自己所选的空间(不只是这个ca8,其余不会被覆盖的均可)计算**\r\n\r\n![](http://img.xuhaobo.site/135)\r\ntouch3运行成功',b'1','又开始刷起了lab3,书中关于缓冲区溢出攻击实验的讲解部分自己看得时候就一知半解,不得不说开始看得真.一脸懵逼(自己大方承认自己是FW),最后无奈地看了下网上对本实验的解析才掌握了一点点其中的原理(不得不说这种注入代码还是很奇妙的哈哈哈哈哈),也算是对程序运行时的栈有了更直观的理解',b'0',2,'2020-08-07 23:15:48',NULL),(150,23,'2020-05-27 16:42:48','想做什么就做什么,如是而矣(站主的学习规划)','https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1103205669,2478736100&fm=26&gp=0.jpg',259,'>本站基于spring boot整合mybatis本人独立开发,采用MYSQL数据库存储,采用redis作为缓存,前端采用了thymeleaf模板引擎,bootstrap4作为UI模板,七牛云提供图片存储。\r\n\r\n**7月5日更新**:本站新增用户发表文章以及相关查询功能,用户也可以发表文章了,同时开发了基于websocket和redis的用户评论消息实时提示功能\r\n\r\n##博主信息:\r\n就读于合肥工业大学无机非金属材料专业,对计算机感兴趣遂开始自学计算机编程知识,非科班程序猿\r\n\r\n\r\n\r\n###主要技术栈:\r\n>后端\r\n\r\n- spring,spring mvc,spring boot\r\n- 持久层技术:mybatis,spring data jpa\r\n- 数据库:MYSQL,redis\r\n\r\n>前端:\r\n\r\n- 基本的HTML,CSS,JAVASCRIPT,JQUERY\r\n- bootstrap **~~复制粘贴~~**\r\n\r\n\r\n>基础知识:\r\n\r\n数据结构与算法,计算机组成原理,汇编语言\r\n\r\n###2020年六月后的规划:\r\n1.**基础知识**:操作系统掌握,做完CSAPP中的所有lab,leetcode刷够400题\r\n>**流行技术**:\r\n\r\n- python人工智能入门\r\n- 前端angular框架基本学习(不必深入)\r\n- 后端相关中间件学习\r\n## 加油！年轻人\r\n\r\n![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1595250153402&di=eb82e7b54490fd53a00af56b1d73b00a&imgtype=0&src=http%3A%2F%2Fp4.ssl.cdn.btime.com%2Ft012feca5d8e3cb87ad.gif%3Fsize%3D400x220)',b'1','欢迎来到本站,这里记录了本人的技术成长以及平时的一些感悟,本贴用于记录本站技术发展历程,以及每次的功能上的更新,定时更新,欢迎访客在其下提出自己的建设性意见',b'1',2,'2020-08-11 11:48:56',NULL),(151,3,'2020-05-27 18:19:33','<<深入理解计算机系统>>lab3 attacklab 4~5解析(针对栈随机化和限制情况下执行的攻击)','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3020495497,2923874859&fm=26&gp=0.jpg',623,'>我们之前的1~3实验是建立在栈中数据可执行以及栈段地址确定的基础上的,而为了防止这种攻击,现代编译器和操作系统实现了相关机制,接下来的操作就是关于我们如何在保护机制的基础上进行攻击\r\n\r\n由于每一次栈地址的随机化以及不可执行机制,我们不再能使用自己注入的代码,于是我们只能通过控制ret的值,从已有代码里寻找自己可用的代码,\"**截取指令对应操作数片段**\",来实现自己的目的。\r\n\r\n###4.输入cookie数到touch2(与实验二的需求是相同的)\r\n由于每一次栈地址的随机化以及不可执行机制,我们不再能使用自己注入的代码,于是我们只能通过控制ret的值,从已有代码里寻找自己可用的代码,\"截取指令对应操作数片段\",来实现自己的目的\r\n**具体思路**:其实自己寻找相关代码(感觉就是一种瞎找哈哈哈哈)花了很多时间,我们需要使用实验文档给的对照表作为参照,根据指令对应的二进制数字寻找可以被我们利用的地址\r\n**拼凑汇编的思路**:gets返回后,此时rip值为getbuf函数,将cookie放在栈顶,将栈顶赋给rax,再将其放到rdi中(实现了将数据放入rdi中),再通过出栈利用ret跳转到touch2(这里所有的跳转都是利用retq将我们注入到栈中的数据当作返回地址,跳转到下一个我们需要的地方去)\r\n**注入代码如下:**\r\n![](http://img.xuhaobo.site/138)\r\n**注入成功**\r\n![](http://img.xuhaobo.site/137)\r\n\r\n###5.输入cookie字符串到touch3(与实验三的需求是相同的)\r\n**具体思路**:同样地,我们还是需要将数据存储到栈上以便被取出,我们将其放在我们注入代码的尾部取出即可,**重点要根据偏移找到我们存储cookie字符串的空间**\r\n注意我们最后存到rdi的是字符串的地址,所以一定要使用lea指令(直接赋值)\r\n![](http://img.xuhaobo.site/139)\r\n**这段代码很容易引起我们的注意,那么我们接下来的操作就是把我们的cookie字符串,放入这个指定的(%rdi,%rsi,1)上了**\r\n>**分步讲解**:\r\n\r\n- getbuf退出后保存栈\r\n- 将栈指针赋给rax\r\n- 将rax赋给rdi(用于最终地址的拼接)\r\n- 将数据与当前存储位置偏移值(本题为72)赋给rax\r\n- 通过一系列寄存器赋值操作将rax赋到rsi上\r\n\r\n这里只讲述思路,具体可利用代码的寻找不是本题重点(虽然会花去大部分的时间:tw-1f637: :tw-1f637:)\r\n依然的,我们不断地在可利用代码反复横跳利用的仍是rep以及注入栈函数地址的配合\r\n\r\n**注入代码如下:**\r\n![](http://img.xuhaobo.site/140)\r\n**结果如下:**\r\n![](http://img.xuhaobo.site/141)',b'1','我们之前的1~3实验是建立在栈中数据可执行以及栈段地址确定的基础上的,而为了防止这种攻击,现代编译器和操作系统实现了相关机制,接下来的操作就是关于我们如何在保护机制的基础上进行攻击',b'0',2,'2020-08-10 10:41:08',NULL),(152,2,'2020-05-28 19:43:23','[leetcode]146. LRU缓存机制','http://img.xuhaobo.site/142',230,'>感觉好久没有刷过算法题了...，因为要开始做cache lab所以刷了下leetcode上的LRU算法,算是自己用JAVA实现了一下吧,感觉时间复杂度略高,先码住等有想法再更新吧\r\n\r\n**题目如下**\r\n![](http://img.xuhaobo.site/142)\r\n\r\n**大体思路:用队列的入队出队控制模拟最近使用的次数(使用一次就自动将其设置成队尾),需要出队时队首出队,队列存储key值,哈希表存储实际的value.**\r\n\r\njava实现如下:\r\n```java\r\nclass LRUCache {\r\n\r\n    private LinkedList<Integer> queue=new LinkedList<>();\r\n\r\n    private Integer capacity;\r\n\r\n    private Map<Integer,Integer>map =new HashMap<>();\r\n\r\n    public LRUCache(int capacity) {\r\n        this.capacity=capacity;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if(map.get(key)==null)\r\n        {\r\n            return -1;\r\n        }else{\r\n            queue.remove(new Integer(key));\r\n            queue.offer(new Integer(key));    //将其调整到队列的最前面\r\n            return map.get(key);\r\n        }\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if(map.get(key)!=null)  //修改操作\r\n        {\r\n            map.put(key,value);\r\n            get(key);    //刷新热度\r\n            return;\r\n        }\r\n        else if(queue.size()==capacity){\r\n            map.put(queue.peek(),null);   //删除队列最前面的值\r\n            queue.poll();\r\n        }\r\n        queue.offer(key);\r\n        map.put(key,value);\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n```',b'1','感觉好久没有刷过算法题了...，因为要开始做cache lab所以刷了下leetcode上的LRU算法,算是自己用JAVA实现了一下吧,感觉时间复杂度略高,先码住等有想法再更新吧',b'0',2,'2020-08-07 23:15:48',NULL),(156,2,'2020-06-21 18:33:14','[leetcode]25. K 个一组翻转链表','http://img.xuhaobo.site/150',327,'>还算简单的一道题，不过需要考虑的点还是不少的,感觉自己写的代码有点啰嗦,很久没有写过链表相关的题了,算是一次复习吧,其实一部分就是可以理解成用一个变量来存储一些值,和一开始编程用的交换的算法是很像的\r\n\r\n###题目如下:\r\n![](http://img.xuhaobo.site/150)\r\n###代码如下:\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) { val = x; }\r\n * }\r\n */\r\nclass Solution {\r\n    private boolean flag=true;\r\n    public ListNode nextNode(ListNode head,int k){\r\n        ListNode nxt=head;\r\n        while(k>0&&nxt!=null){\r\n            nxt=nxt.next;\r\n            k--;\r\n        }\r\n        if(k!=0){\r\n            flag=false;         //非正常退出\r\n        }else{\r\n            flag=true;                  //正常退出\r\n        }\r\n        return nxt;\r\n    }\r\n    public ListNode reverseKGroup(ListNode head, int k) {\r\n        if(head==null){\r\n            return head;\r\n        }\r\n        boolean first=true;\r\n        ListNode p=head;\r\n        ListNode anw=null;\r\n        ListNode nxt=nextNode(head,k);\r\n        ListNode last=head;   //上一组结点\r\n        while(flag==true){\r\n            ListNode firstNode=p;\r\n            ListNode pre=nxt;\r\n            for(int i=0;i<k;i++){\r\n                ListNode next=p.next;\r\n                p.next=pre;\r\n                pre=p;\r\n                p=next;\r\n            }\r\n            if(first==true){                       //第一次记录头节点\r\n                anw=pre;\r\n                first=false;\r\n            }else{\r\n                last.next=pre;\r\n            }\r\n            last=firstNode;\r\n            p=nxt;\r\n            nxt=nextNode(p,k);\r\n        }\r\n        return anw;\r\n    }\r\n}\r\n```',b'1','还算简单的一道题，不过需要考虑的点还是不少的,感觉自己写的代码有点啰嗦,很久没有写过链表相关的题了,算是一次复习吧,其实一部分就是可以理解成用一个变量来存储一些值,和一开始编程用的交换的算法是很像的',b'0',2,'2020-08-08 11:53:51',NULL),(157,2,'2020-06-21 22:07:14','[leetcode]116. 填充每个节点的下一个右侧节点指针','http://img.xuhaobo.site/151',370,'>一开始想的是直接暴力BFS的方法,后来看到要求只能使用常数级额外空间所以索性放弃BFS,后来发现可以直接根据父节点next指针递推,问题想通了代码量还是挺小的\r\n\r\n##问题如下\r\n\r\n![](http://img.xuhaobo.site/151) \r\n>###本题特殊要求\r\n![](http://img.xuhaobo.site/152)\r\n\r\n具体思路:dfs根据每个节点可以直接确立左右结点的next指针关系,关键在于确认如图所示结点的关系\r\n![](http://img.xuhaobo.site/153)此时两建立关系结点的父结点是不同的\r\n不能通过简单的遍历实现\r\n那么我们可以试图找一下他们之间父结点的关系\r\n![](http://img.xuhaobo.site/155)\r\n**可以观察出,这种情况左侧右结点的next,即为左侧子节点的父节点的next所对应结点的左结点**\r\n**我们遍历到下面的结点时,父结点next的关系其实已经确立好了**\r\n所以我们可以根据这种递推关系编程\r\njava递归实现如下:\r\n```java\r\nclass Solution {\r\n    public Node connect(Node root) {\r\n        if(root!=null&&root.right!=null&&root.left!=null)\r\n        {\r\n            if(root.next!=null)\r\n            {\r\n                root.right.next=root.next.left;\r\n            }\r\n            root.left.next=root.right;\r\n            connect(root.left);\r\n            connect(root.right);\r\n        }\r\n        return root;\r\n    }\r\n}\r\n```\r\n![](http://img.xuhaobo.site/156)\r\n###速度上还是可以的hhhh',b'1','一开始想的是直接暴力BFS的方法,后来看到要求只能使用常数级额外空间所以索性放弃BFS,后来发现可以直接根据父节点next指针递推,问题想通了代码量还是挺小的',b'0',2,'2020-08-10 20:55:29',NULL),(158,2,'2020-06-21 22:56:37','[leetcode]49. 字母异位词分组','http://img.xuhaobo.site/157',405,'>很简单的一道题,把字符串排下序即可将字母异位词组合在一起,放进哈希表里最后再遍历一遍\r\n\r\n####题目如下:\r\n![](http://img.xuhaobo.site/157)\r\n####题解如下:\r\n```java\r\nclass Solution {\r\n    String trans(String s)\r\n    {\r\n        char[] arr=s.toCharArray();\r\n        Arrays.sort(arr);  //排序\r\n        return new String(arr);\r\n    }\r\n\r\n    public List<List<String>> groupAnagrams(String[] strs) {\r\n        Map<String,List<String>> m=new HashMap<>();\r\n        for(int i=0;i<strs.length;i++)\r\n        {\r\n            String keyStr=trans(strs[i]);\r\n            if(m.get(keyStr)==null)\r\n            {\r\n                m.put(keyStr,new ArrayList<String>());\r\n            }\r\n            List<String> item=m.get(keyStr);\r\n            item.add(strs[i]);\r\n            m.put(keyStr,item);\r\n        }\r\n        List<List<String>> anws=new ArrayList<>();\r\n        for(String key:m.keySet())\r\n        {\r\n            anws.add(m.get(key));\r\n        }\r\n        return anws;\r\n    }\r\n}\r\n```',b'1','很简单的一道题,把字符串排下序即可将字母异位词组合在一起,放进哈希表里最后再遍历一遍',b'0',2,NULL,NULL),(159,2,'2020-06-22 08:52:15','[leetcode]面试题 17.10. 主要元素','http://img.xuhaobo.site/158',540,'>如果单纯是使用哈希表存储数字出现次数来看的话应该是很简单的一道题,对于时间复杂度为 O(N)，空间复杂度为 O(1)的拓展内容自己一直没有想到太好的方法,从网上看到了摩尔投票的原理,遂解（比评论里的代码写得简短hhhhh），双百\r\n\r\n\r\n###题目如下:\r\n![](http://img.xuhaobo.site/158)\r\n###重点依然是底下的要求，如果不考虑的话直接哈希表做应该是最好想的做法\r\n![](http://img.xuhaobo.site/159)\r\n\r\n>核心:摩尔投票算法原理\r\n\r\n大概道理也很好理解,我们的需求是**找到占比超过一半的元素**,\r\n**如果把所有不相同的进行两两删除,最后剩下的就是占比超过一半的元素**如果最后什么元素都没剩下,那么返回-1表示都被消去了,我们的代码编写过程,就是模拟这个消去的过程。\r\n\r\n用一个变量存储目前用于被消去的数字,另一个变量记录这个数字目前的连续出现个数(两数字如果相同则不被消去而通过这个count变量记录)\r\n当count为零时表示等待被消去区的数字为空,那么下一个数字就进入该区域\r\n最终count为零证明所有数字均被消去,不为零则证明有数字未被消去,就是要求得出的占比超过一半的数\r\n\r\n**java具体实现如下:**\r\n```java\r\nclass Solution {\r\n    public int majorityElement(int[] nums) {\r\n        int count=0;\r\n        int tmp=0;\r\n        for(int num:nums)\r\n        {\r\n            if(count==0)\r\n            {\r\n                tmp=num;\r\n                count++;     \r\n            }else if(tmp==num){\r\n                count++;\r\n            }else{\r\n                count--;\r\n            }\r\n        }\r\n        return count==0?-1:tmp;\r\n    }\r\n}\r\n```\r\n![](http://img.xuhaobo.site/160)\r\n双百通过,摩尔算法新技能get',b'1','如果单纯是使用哈希表存储数字出现次数来看的话应该是很简单的一道题,对于时间复杂度为 O(N)，空间复杂度为 O(1)的拓展内容自己一直没有想到太好的方法,从网上看到了摩尔投票的原理,遂解（比评论里的代码写得简短hhhhh），双百',b'0',2,'2020-08-11 11:48:00',NULL),(165,23,'2020-07-19 10:25:26','朋克--你的多用户知识分享平台(平台说明贴)','http://img.xuhaobo.site/171',1,'>欢迎用户注册并测试,若出现bug可以在评论区下实名或匿名反馈\r\n\r\n本站使用说明:\r\n1.目前只有站主,没事记录自己的计算机学习感想\r\n2.支持markdown语法编写文章\r\n3.评论支持emoji\r\n\r\n##注册步骤如下:\r\n首先点击右侧**\"登录\"**按钮进行登录或注册\r\n![](http://img.xuhaobo.site/167)\r\n\r\n登录栏如下，注册栏已被红圈全住:\r\n![](http://img.xuhaobo.site/168)\r\n\r\n注册后进入的管理员页面如下\r\n![](http://img.xuhaobo.site/172)\r\n\r\n有什么功能期待可以在底下反馈\r\n木大木大木大!!',b'1','\"好记性不如烂笔头\"<br>\r\n\"别管别人能不能看懂,写就完了\"<br>\r\n\"现在还算开发版,站主新学点新技术一高兴就加一个功能那种\"<br>\r\n\"什么他妈的叫朋克,我喜欢学什么学什么,不喜欢学什么就不学什么,这他妈就叫朋克\"',b'1',2,'2020-08-11 11:48:48',NULL),(166,23,'2020-07-22 10:53:28','小号测试帖','https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1595386308&di=9393e3ef763ae3974f53b0e8971a2018&src=http://img.qqzhi.com/uploads/2018-12-24/012906882.jpg',15,'测试小号',b'1','测试小号',b'0',16,'2020-08-11 11:48:47',NULL);

#
# Structure for table "thumb"
#

DROP TABLE IF EXISTS `thumb`;
CREATE TABLE `thumb` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `address` varchar(130) DEFAULT NULL,
  `aid` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `aid_addr` (`aid`,`address`)
) ENGINE=InnoDB AUTO_INCREMENT=6332 DEFAULT CHARSET=utf8;

#
# Data for table "thumb"
#

INSERT INTO `thumb` VALUES (31,'221.192.180.191',147),(32,'221.192.180.191',142),(45,'60.7.252.13',147),(49,'42.236.10.125',149),(50,'180.163.220.68',149),(57,'42.236.10.125',150),(58,'180.163.220.4',150),(80,'180.163.220.67',150),(83,'10.131.51.119',150),(90,'60.7.252.217',151),(93,'60.7.252.217',152),(94,'60.7.252.217',150),(95,'60.7.254.239',141),(98,'120.6.172.255',150),(99,'120.6.172.179',149),(102,'120.6.172.179',150),(105,'180.163.220.68',150),(106,'120.6.172.47',159),(107,'42.236.10.75',150),(108,'42.236.10.93',150),(109,'180.163.220.5',150),(110,'27.115.124.70',150),(205,'120.6.106.137',150),(301,'60.7.253.147',158),(1021,'180.163.220.68',165),(2234,'0:0:0:0:0:0:0:1',214),(2235,'0:0:0:0:0:0:0:1',196),(2236,'0:0:0:0:0:0:0:1',216),(2237,'0:0:0:0:0:0:0:1',195),(4395,'0:0:0:0:0:0:0:1',165),(4398,'0:0:0:0:0:0:0:1',166),(4400,'0:0:0:0:0:0:0:1',158),(5293,'0:0:0:0:0:0:0:1',159),(5786,'60.7.253.149',159),(5788,'60.7.253.149',158),(5789,'60.7.253.149',157),(5790,'120.6.172.179',154),(5791,'120.6.172.255',154),(5792,'60.7.252.217',154),(5793,'60.7.253.147',163),(5794,'60.7.253.149',163),(5799,'60.7.253.149',166),(5800,'60.7.253.147',160),(5801,'60.7.253.149',160),(5802,'180.163.220.4',165),(5804,'42.236.10.78',165),(5805,'60.7.253.149',165),(5806,'120.6.172.179',153),(5807,'120.6.172.255',153),(5808,'60.7.252.217',153),(5822,'60.7.253.149',150);

#
# Structure for table "user"
#

DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  `role` varchar(5) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `headSculpture` varchar(255) DEFAULT NULL,
  `salt` varchar(255) DEFAULT NULL,
  `updateTime` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  `createTime` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`),
  UNIQUE KEY `email` (`email`)
) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8;

#
# Data for table "user"
#

INSERT INTO `user` VALUES (2,'徐浩博','760c68fee36379bfb931281831716faf','admin','511928849@qq.com','http://img.xuhaobo.site/171','kEc4lyuLLDe8F7BA4IlVbA==',NULL,'2020-08-05 16:03:55'),(6,'西瓜酸奶','94e7d712742adbbb7a73a1d52a7cc1a9','user','yuanyi2000@aliyun.com',NULL,NULL,NULL,'2020-08-05 16:03:55'),(7,'你大爷还是你大爷','e10adc3949ba59abbe56e057f20f883e','user','18014913947@163.com',NULL,NULL,NULL,'2020-08-05 16:03:55'),(8,'快爬呀XHB快点爬','48e31b007b8863a5545a101b8c22749e','user','1779562376@qq.com',NULL,NULL,NULL,'2020-08-05 16:03:55'),(9,'匿名游客','c53a2b751bbc0eee6c082755afdb1e6e','user','51928849@qq.com',NULL,NULL,NULL,'2020-08-05 16:03:55'),(16,'徐浩博小号','760c68fee36379bfb931281831716faf','user','511928849@qq.cn','https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1595386308&di=9393e3ef763ae3974f53b0e8971a2018&src=http://img.qqzhi.com/uploads/2018-12-24/012906882.jpg','kEc4lyuLLDe8F7BA4IlVbA==',NULL,'2020-08-05 16:03:55'),(18,'刘雨萌','574bf51b3785d783e54f44b26fc5c42b','user','249351206@qq.com','',NULL,NULL,'2020-08-05 16:03:55'),(19,'徐浩博小小号','c53a2b751bbc0eee6c082755afdb1e6e','user','511927849@qq.com','https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3040801216,814662111&fm=26&gp=0.jpg',NULL,NULL,'2020-08-05 16:03:55'),(20,'徐浩博密码实验','09b1ca0825c5be39d53b9fe73990ba89','user','234@qq.com','fasd','FoduOVfaMS5f5VGkBgw/PA==',NULL,'2020-08-05 16:03:55'),(21,'dfas','4cecafab089812f640419f61adda526e','user','asdf@qq.com','dadasfafadfadfa','7axTTy5LBYRE1at68Kp1Jw==',NULL,'2020-08-05 16:03:55'),(22,'测试号','89bc62d8293c1e37820a18477b3b391a','user','1112@qq.com','asdf','paa0mBdI0YqENaUtBVC+hA==',NULL,'2020-08-05 16:03:55'),(23,'测试','c6e6753b3ac6e8dd30278119ce75c21c','user','dfas@qq.com','asdfaf','yMksuPe8yvQ7qGn/PL7GHg==',NULL,'2020-08-05 16:03:55'),(24,'fsd','37f47c692fa8bee950200cc69a639611','user','asdf@qdq.com','ffff','giEHNE/BN5s2jueBCrym7Q==',NULL,'2020-08-05 16:03:55');

#
# Structure for table "comment"
#

DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `aid` int(11) NOT NULL,
  `content` text,
  `createTime` datetime DEFAULT CURRENT_TIMESTAMP,
  `parentID` int(11) DEFAULT NULL,
  `uid` int(11) NOT NULL,
  `anonymous` bit(1) DEFAULT b'0',
  `updateTime` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `fk_comment_article` (`aid`),
  KEY `comment_parentComment` (`parentID`),
  KEY `comment_user` (`uid`),
  CONSTRAINT `comment_parentComment` FOREIGN KEY (`parentID`) REFERENCES `comment` (`id`),
  CONSTRAINT `comment_user` FOREIGN KEY (`uid`) REFERENCES `user` (`id`),
  CONSTRAINT `fk_comment_article` FOREIGN KEY (`aid`) REFERENCES `article` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=460 DEFAULT CHARSET=utf8mb4;

#
# Data for table "comment"
#

