# Host: 127.0.0.1  (Version: 5.5.15)
# Date: 2020-05-18 22:38:37
# Generator: MySQL-Front 5.3  (Build 4.269)

/*!40101 SET NAMES utf8 */;

#
# Structure for table "friendly_link"
#

DROP TABLE IF EXISTS `friendly_link`;
CREATE TABLE `friendly_link` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `link` varchar(255) DEFAULT NULL,
  `allowed` bit(1) DEFAULT b'0',
  `email` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=45 DEFAULT CHARSET=utf8;

#
# Data for table "friendly_link"
#

INSERT INTO `friendly_link` VALUES (44,'西瓜酸奶','https://www.yuanyi2000.top',b'1','yuanyi2000@aliyun.com');

#
# Structure for table "logs"
#

DROP TABLE IF EXISTS `logs`;
CREATE TABLE `logs` (
  `Id` int(11) DEFAULT NULL,
  `Num` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

#
# Data for table "logs"
#

INSERT INTO `logs` VALUES (1,1),(2,1),(3,1),(4,2),(5,1),(6,2),(7,2);

#
# Structure for table "message"
#

DROP TABLE IF EXISTS `message`;
CREATE TABLE `message` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `content` text,
  `createTime` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=75 DEFAULT CHARSET=utf8mb4;

#
# Data for table "message"
#

INSERT INTO `message` VALUES (58,'界面很丑','2020-04-11 00:00:00'),(69,'🐂','2020-05-11 20:24:38'),(74,'22','2020-05-18 22:04:50');

#
# Structure for table "picture"
#

DROP TABLE IF EXISTS `picture`;
CREATE TABLE `picture` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `filekey` varchar(255) NOT NULL,
  `url` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=108 DEFAULT CHARSET=utf8;

#
# Data for table "picture"
#

INSERT INTO `picture` VALUES (10,'10','http://q7xlyvqgm.bkt.clouddn.com/10'),(11,'11','http://q7xlyvqgm.bkt.clouddn.com/11'),(14,'14','http://q7xlyvqgm.bkt.clouddn.com/14'),(15,'15','http://q7xlyvqgm.bkt.clouddn.com/15'),(16,'16','http://q7xlyvqgm.bkt.clouddn.com/16'),(17,'17','http://q7xlyvqgm.bkt.clouddn.com/17'),(18,'18','http://q7xlyvqgm.bkt.clouddn.com/18'),(19,'19','http://q7xlyvqgm.bkt.clouddn.com/19'),(20,'20','http://q7xlyvqgm.bkt.clouddn.com/20'),(21,'21','http://q7xlyvqgm.bkt.clouddn.com/21'),(22,'22','http://q7xlyvqgm.bkt.clouddn.com/22'),(23,'23','http://q7xlyvqgm.bkt.clouddn.com/23'),(24,'24','http://q7xlyvqgm.bkt.clouddn.com/24'),(25,'25','http://q7xlyvqgm.bkt.clouddn.com/25'),(26,'26','http://q7xlyvqgm.bkt.clouddn.com/26'),(27,'27','http://q7xlyvqgm.bkt.clouddn.com/27'),(73,'73','http://img.xuhaobo.site/73'),(74,'74','http://img.xuhaobo.site/74'),(75,'75','http://img.xuhaobo.site/75'),(76,'76','http://img.xuhaobo.site/76'),(77,'77','http://img.xuhaobo.site/77'),(78,'78','http://img.xuhaobo.site/78'),(79,'79','http://img.xuhaobo.site/79'),(80,'80','http://img.xuhaobo.site/80'),(81,'81','http://img.xuhaobo.site/81'),(82,'82','http://img.xuhaobo.site/82'),(83,'83','http://img.xuhaobo.site/83'),(84,'84','http://img.xuhaobo.site/84'),(85,'85','http://img.xuhaobo.site/85'),(86,'86','http://img.xuhaobo.site/86'),(87,'87','http://img.xuhaobo.site/87'),(88,'88','http://img.xuhaobo.site/88'),(89,'89','http://img.xuhaobo.site/89'),(97,'97','http://img.xuhaobo.site/97'),(98,'98','http://img.xuhaobo.site/98'),(99,'99','http://img.xuhaobo.site/99'),(100,'100','http://img.xuhaobo.site/100'),(101,'101','http://img.xuhaobo.site/101'),(102,'102','http://img.xuhaobo.site/102'),(103,'103','http://img.xuhaobo.site/103'),(104,'104','http://img.xuhaobo.site/104'),(105,'105','http://img.xuhaobo.site/105'),(106,'106','http://img.xuhaobo.site/106'),(107,'107','http://img.xuhaobo.site/107');

#
# Structure for table "tag"
#

DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=29 DEFAULT CHARSET=utf8;

#
# Data for table "tag"
#

INSERT INTO `tag` VALUES (2,'数据结构与算法'),(3,'CS:APP'),(8,'JAVA后端开发'),(15,'python数据挖掘'),(20,'汇编语言'),(22,'操作系统'),(28,'ddf');

#
# Structure for table "article"
#

DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `tid` int(11) DEFAULT NULL,
  `createTime` datetime DEFAULT NULL,
  `title` varchar(255) DEFAULT NULL,
  `firstPicture` varchar(255) DEFAULT NULL,
  `visit` bigint(20) DEFAULT '0',
  `content` text,
  `published` bit(1) DEFAULT b'0',
  `info` text,
  PRIMARY KEY (`id`),
  KEY `fk_article_tag` (`tid`),
  CONSTRAINT `fk_article_tag` FOREIGN KEY (`tid`) REFERENCES `tag` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=146 DEFAULT CHARSET=utf8;

#
# Data for table "article"
#

INSERT INTO `article` VALUES (3,3,'2020-04-07 00:00:00','<<深入理解计算机系统>>之动态链接','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3020495497,2923874859&fm=26&gp=0.jpg',7,':pouting_cat: :pouting_cat: :pouting_cat: :tw-1f4a9: :tw-1f4a9: :tw-1f4a9:1.对static以及模块内的变量定义的区分:\r\n\r\n\tstatic:本地链接器符号---在模块中任何位置都可见,但是不能被其他模块所引用\r\n\t本地定义的变量: .symtab符号表并不包含本地变量定义的符号,这些符号由栈进行管理\r\n\r\n2.bss节与COMMON节的区分:\r\n    \r\n\tbss:局部未初始化||局部为0||全局为0(static为局部)\r\n\tCOMMON:全局为初始化\r\n\r\n3.未初始化的变量(如上说的.bss,COMMON)在重定向目标文件以及可执行目标文件中没有实际分配空间,但是在实际运行过程中按照符号表中的类型分配',b'1',':pouting_cat: :pouting_cat: :pouting_cat: :tw-1f4a9: :tw-1f4a9: :tw-1f4a9:1.对static以及模块内的变量定义的区分:\r\n\r\n\tstatic:本地链接器符号---在模块中任何位置都可见,但是不能被其他模块所引用\r\n\t本地定义的变量: .symtab符号表并不包含本地变量定义的符号,这些符号由栈进行管理\r\n\r\n2.bss节与COMMON节的区分:\r\n    \r\n\tbss:局部未初始化||局部为0||全局为0(static为局部)\r\n\tCOMMON:全局为初始化\r\n\r\n3.未初始化的变量(如上说的.bss,COMMON)在重定向目标文件以及可执行目标文件中没有实际分配空间,但是在实际运行过程中按照符号表中的类型分配'),(6,3,'2020-04-01 00:00:00','<<深入理解计算机系统>>第七章易错点总结','https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3394611025,2062792490&fm=26&gp=0.jpg',5,'1.对static以及模块内的变量定义的区分:\r\n\r\n\tstatic:本地链接器符号---在模块中任何位置都可见,但是不能被其他模块所引用\r\n\t本地定义的变量: .symtab符号表并不包含本地变量定义的符号,这些符号由栈进行管理\r\n\r\n2.bss节与COMMON节的区分:\r\n    \r\n\tbss:局部未初始化||局部为0||全局为0(static为局部)\r\n\tCOMMON:全局为初始化\r\n\r\n3.未初始化的变量(如上说的.bss,COMMON)在重定向目标文件以及可执行目标文件中没有实际分配空间,但是在实际运行过程中按照符号表中的类型分配',b'1','1.对static以及模块内的变量定义的区分:\r\n\r\n\tstatic:本地链接器符号---在模块中任何位置都可见,但是不能被其他模块所引用\r\n\t本地定义的变量: .symtab符号表并不包含本地变量定义的符号,这些符号由栈进行管理\r\n\r\n2.bss节与COMMON节的区分:\r\n    \r\n\tbss:局部未初始化||局部为0||全局为0(static为局部)\r\n\tCOMMON:全局为初始化\r\n\r\n3.未初始化的变量(如上说的.bss,COMMON)在重定向目标文件以及可执行目标文件中没有实际分配空间,但是在实际运行过程中按照符号表中的类型分配'),(7,15,'2020-04-02 00:00:00','pandas库的相关文件IO操作','https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3506000979,3290554988&fm=11&gp=0.jpg',2,'pandas库的文件最常用的是csv,hdf以及json,下面介绍下他们\r\n各自的api\r\n\r\n\r\n\r\n\r\n\tcsv:\r\n```python\r\n#从路径中读取csv文件,usecols代表其所读取的字段\r\ndata_csv=pd.read_csv(\"C:/Users/user/Desktop/教程文档/Python数据挖掘基础教程资料/day3资料/02-代码/stock_day/stock_day.csv\",usecols=data.columns[0:4])\r\n#数据写入,index控制是否传入索引,columns控制要写入那几个字段的数据\r\ndata_csv.to_csv(\"C:/Users/user/Desktop/教程文档/Python数据挖掘基础教程资料/day3资料/02-代码/stock_day/tostock_day3.csv\",columns=data.columns[0:2],index=False)      \r\n\r\n\r\n```\r\n\r\n\tHDF5：hdf5数据可以通过key来获取相应的二维数据,本质上可以看作是三维数据\r\n```python\r\n#从路径中读取HDF5文件,注意HDF5为二进制文件,hdf5数据可以通过key来获取相应的二维数据,本质上可以看作是三维数据\r\n\r\ndata_hdf=pd.read_hdf(\"D:/totest.h5\",key=\'first\')        #当只有一个key时可以读取\r\ndata_csv.to_hdf(\"D:/totest.h5\",key=\'third\')            #这里必须要存入相应的key\r\n\r\n```\r\n\r\n\tjson:学java web,spring boot时的老朋友了,又在这遇见了哈哈哈\r\n```python\r\n#读取json文件\r\njson=pd.read_json(\'C:/Users/user/Desktop/教程文档/Python数据挖掘基础教程资料/day3资料/02-代码/test.json\',orient=\"records\",lines=True)  \r\n#(path,orient,lines)    orient默认设成\"records\"格式, line表示按照行一行一行读取json数据\r\nprint(json)\r\njson.to_json(\'C:/Users/user/Desktop/教程文档/Python数据挖掘基础教程资料/day3资料/02-代码/testto.json\',orient=\"records\",lines=True) \r\n#这里的常用属性设置与之前相同,lines的意思是一行一行读进json文件中去\r\n```',b'1','pandas库的文件最常用的是csv,hdf以及json,下面介绍下他们\r\n各自的api。'),(8,15,'2020-04-06 00:00:00','[python]第一天数据挖掘','https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3890848816,3171555074&fm=26&gp=0.jpg',6,'#python数据挖掘之matplotlab的使用\r\n*最近为了开学的大创,在学习一点python数据挖掘相关的内容,简单地看黑马\r\n的视频学了一点点的matplotlab.....感觉这一块还是不难的,大概就是调ap\r\ni吧,具体使用还是要多用得好\r\n至于什么是matplotlab,为什么要使用matplotlab这里就不细说了....*\r\n##1.容器层(画布)\r\n&emsp;&emsp;这个没什么好说的,就是要在画布上画画的道理,如果要生成一组统计图就只建立一个画布而不需要坐标系：\r\n```python\r\nfig = plt.figure(figsize=(a, b), dpi=dpi)\r\n#figsize a,b指定画布长宽,dpi指定清晰度\r\n```\r\n&emsp;&emsp;如果要建立多个图像则需要建立坐标系\r\n```python\r\nﬁgure, axes = plt.subplots(nrows=, ncols=, ﬁgsize=, dpi=)\r\n#nrows代表行数,ncols代表列数,控制划分区域,而后的、figsize和dpi用法则与之前相同\r\n\r\n```\r\n两者间使用的api略有不同,这里我举例折线图把建立坐标系所使用的的api如下\r\n```python\r\nimport matplotlib.pyplot as plt\r\nimport random\r\n%matplotlib inline\r\n\r\nx=[i for i in range(60)]\r\nx_label=[\"值为{}\".format(i) for i in x]\r\n\r\ny=[int(random.uniform(10,18)) for i in range(60)]\r\ny_label=[\"值为{}\".format(i) for i in y]\r\n\r\nx2=[i for i in range(60)]\r\nx2_label=[\"值为{}\".format(i) for i in x]         \r\n\r\ny2=[int(random.uniform(10,18)) for i in range(60)]  //这里通过列表生成式不断生成随机数\r\ny2_label=[\"值为{}\".format(i) for i in y]\r\n\r\nfigure,axes=plt.subplots(nrows=1,ncols=2)\r\n\r\n#plt.figure(figsize=(20,8),dpi=80)    画布 plt.figure()\r\n\r\n#画图 plot函数先传x轴上的再传y轴上的\r\n\r\naxes[0].plot(x,y,color=\"r\",label=\"第一个图像\",linestyle=\"--\")     #linestyle控制线条的粗细(忽然感觉)\r\naxes[1].plot(x2,y2,color=\"g\",label=\"第二个图像\",alpha=0.8)       #实际的画的动作,alpha控制透明度\r\n\r\n\r\n#辅助显示\r\naxes[0].grid(alpha=0.5,linestyle=\"--\")      #grid设置表格\r\naxes[1].legend()              #选择图例位置(默认为best) ,之前给设置的plot时的 图像时显示\r\naxes[0].legend()\r\n\r\naxes[0].set_xticks(x[::5])     #设置辅助显示x轴,增加标注刻度\r\naxes[0].set_xticklabels(x_label[::5])\r\naxes[0].set_yticks(y[::5])     #设置辅助显示y轴,增加标注刻度\r\naxes[0].set_yticklabels(y_label[::5])\r\n\r\naxes[1].set_xticks(x2[::5])     #设置辅助显示x轴,增加标注刻度\r\naxes[1].set_xticklabels(x2_label[::5])\r\naxes[1].set_yticks(y2[::5])     #设置辅助显示y轴,增加标注刻度\r\naxes[1].set_yticklabels(y2_label[::5])\r\n\r\naxes[0].set_xlabel(\"x轴。。。。\")\r\naxes[0].set_ylabel(\"y轴。。。。\")\r\n\r\nplt.show()\r\n```\r\n&emsp;&emsp;当然里面也有图像层的对应用法,可以把这种思路的不同理解成不建立坐标系时是面向过程的,而建立坐标系后则是面向对象的。\r\n\r\n##2.辅助显示层\r\n\t同样地,辅助显示层也是大同小异,常用地可以控制x,y轴刻度,以及描述信息,添加网格,显示图例等,这里只描述下单个图像的api\r\n```python\r\nplt.xticks([i for i in range(10)][::5],[\"i的值为{}\".format(i) for i in range(10)][::5])   #前面的是实际的x轴数据,后面是所修改的x,y刻度\r\nplt.xlabel(\"x轴上所加的标签\")          #用字符串指代x轴所加标签\r\nplt.grid()       #添加网格,这个没什么可说的\r\n\r\nplt.legend()       #这个要与绘制图像的Api一起使用,之后会提到\r\n```\r\n\r\n##3.图像层\r\n\r\n\t图像层就有很多的不同了,需要我们根据不同的数据选取合适的图像\r\n\t都有的属性:linestyle:线条类型  alpha:透明度 color:色彩\r\n####1.折线图--变化趋势:\r\n```python\r\nplt.plot([i for i in range(10)],[j for j in range(10)],label=\"直线\") #(x,y,图例说明)\r\n```\r\n####2.散点图--是否存在关系:\r\nplt.scatter(x,y,...)\r\n\r\n####3.柱状图:\r\nplt.bar(x,y,...)\r\n柱状图在进行比较时通常会有多个一组一起比,这里需要考虑一下偏移量的问题\r\n例如:\r\n```python\r\nimport matplotlib.pyplot as plt\r\nimport random\r\n%matplotlib inline\r\n\r\nplt.figure(figsize=(10,10),dpi=80)\r\n# plt.bar([i for i in range(10)],[j for j in range(10)],x_label=\"x轴\")\r\n\r\nplt.bar([i for i in range(10)],[j for j in range(10)],color=\'b\',width=0.2) #(x,y,图例说明)\r\nplt.bar([i+0.2 for i in range(10)],[j for j in range(10)],color=\'r\',width=0.2)\r\n\r\n\r\nplt.xticks([i+0.1 for i in range(10)],[\"i的值为{}\".format(i) for i in range(10)])   #前面的是实际的x轴数据,后面是所修改的x,y刻度,这里向右平移0.1使其恰好居中\r\nplt.xlabel(\"x轴上所加的标签\")          #用字符串指代x轴所加标签\r\nplt.grid()       #添加网格,这个没什么可说的\r\n\r\n#plt.legend()       #这个要与绘制图像的Api一起使用,之后会提到\r\n\r\nplt.show()\r\n```\r\n####直方图:一段连续范围内各数所占的比例\r\n```python\r\nplt.hist(x,bin)  #normed==true为显示频率\r\n# bin为所分的组数,可以以下形式求\r\nl=[i for i in range(10)]\r\ndistance=1   #设置组距\r\nbin=(max(l)-min(l))/distance\r\nplt.xticks(x[::distance])\r\n```\r\n####饼图---占比\r\n函数格式:```python\r\ndef pie(x, explode=None, labels=None, colors=None, autopct=None,\r\n        pctdistance=0.6, shadow=False, labeldistance=1.1, startangle=None,\r\n        radius=None, counterclock=True, wedgeprops=None, textprops=None,\r\n        center=(0, 0), frame=False, rotatelabels=False, hold=None, data=None)\r\n```\r\nx为x轴(自动生成占比)\r\nlabels为每部分的标签\r\ncolors为颜色\r\nautopct为保留的位数%1.2ff%%\r\n```python\r\nplt.pie(x,labels=[i for i in x],autopct=\'%1.2f%%\')\r\n```\r\n\r\n![](http://q7xlyvqgm.bkt.clouddn.com/9)',b'1','最近为了开学的大创,在学习一点python数据挖掘相关的内容,简单地看黑马\r\n的视频学了一点点的matplotlab.....感觉这一块还是不难的,大概就是调ap\r\ni吧,具体使用还是要多用得好\r\n至于什么是matplotlab,为什么要使用matplotlab这里就不细说了....'),(105,2,'2020-04-02 00:00:00','leetcode 57插入区间','http://img.xuhaobo.site/88',3,'*好久没刷算法题了......\r\n乍一刷有点自闭........\r\n虽说代码写出来了吧但是感觉还是不太好*\r\n\r\n题意如下:给出一个无重叠的 ，按照区间起始端点排序的区间列表。\r\n\r\n在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。\r\n![](http://img.xuhaobo.site/88)\r\n\r\n```java\r\nclass Solution {\r\n    public static boolean contains(int []insert,int []tocheck)\r\n    {\r\n        if((insert[0]<=tocheck[0]&&insert[1]<=tocheck[1]&&insert[1]>=tocheck[0])||\r\n        (insert[1]>=tocheck[1]&&insert[0]>=tocheck[0]&&insert[0]<=tocheck[1])||(insert[1]>=tocheck[1]&&insert[0]<=tocheck[0]))\r\n        {\r\n            return true;\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }\r\n```\r\n\r\n```java\r\npublic int[][] insert(int[][] intervals, int[] newInterval) {\r\n        if(intervals==null||intervals.length==0)\r\n        {\r\n            System.out.println(1);\r\n            int [][] b=new int[1][2];\r\n            b[0]=newInterval;\r\n            return b;\r\n        }\r\n        else if(intervals.length!=0){\r\n            List<int[]> anw=new ArrayList<>();   //存储最终结果\r\n            int[] tochange=new int[2];       //中间由于插入数组发生变化的数组\r\n            boolean flag=false;                //记录重叠状态\r\n            boolean hasContain=false;   //判断是否重叠过\r\n            for(int i=0;i<intervals.length;i++)\r\n            {\r\n                if(contains(newInterval,intervals[i])==true)       //若判断包含关系则开始更新\r\n                {\r\n                    System.out.println(flag);\r\n                    hasContain=true;   //证明有重叠过\r\n                    if(flag==true)\r\n                    {\r\n                        if(tochange[1]<=intervals[i][1])\r\n                        {\r\n                            tochange[1]=intervals[i][1];\r\n                        }\r\n                    }\r\n                    else if(flag==false)\r\n                    {\r\n                        tochange=intervals[i];\r\n                        if(tochange[0]>=newInterval[0])\r\n                    {\r\n                        tochange[0]=newInterval[0];\r\n                    }\r\n                    if(tochange[1]<=newInterval[1])\r\n                    {\r\n                        System.out.println(tochange[1]);\r\n                        tochange[1]=newInterval[1];\r\n                    }\r\n\r\n                        flag=true;         //进入检验重叠的模式中\r\n                    }\r\n                }\r\n                else{\r\n                    if(flag==true)   //之前有在重叠模式里的元素就先加进去,不重叠的元素一定加进去\r\n                    {\r\n                        anw.add(tochange);\r\n                        flag=false;\r\n                    }\r\n                    anw.add(intervals[i]);\r\n                }\r\n            }\r\n                    if(flag==true)   //之前有在重叠模式里的元素就先加进去,不重叠的元素一定加进去\r\n                    {\r\n                        anw.add(tochange);\r\n                        flag=false;\r\n                    }\r\n            if(hasContain==false)       //从未发生过重叠则要根据之前的结果进行插入\r\n            {\r\n                for(int i=0;i<anw.size();i++)\r\n                {\r\n                    if(i==0&&anw.get(i)[0]>newInterval[1])\r\n                    {\r\n                       anw.add(0,newInterval);\r\n                        break;\r\n                    }\r\n                    if(i==anw.size()-1&&anw.get(i)[1]<newInterval[0])\r\n                    {\r\n                        anw.add(newInterval);\r\n                        break;\r\n                    }\r\n                    else if(anw.get(i)[1]<newInterval[0]&&anw.get(i+1)[0]>newInterval[1])\r\n                    {\r\n                        anw.add(i+1,newInterval);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            int [][]retArray=new int[anw.size()][2];\r\n            for(int i=0;i<anw.size();i++)\r\n            {\r\n                retArray[i]=anw.get(i);   //移入一个二维数组中去\r\n            }\r\n            return retArray;\r\n        }\r\n        return null;\r\n    }\r\n    \r\n}\r\n```\r\n\r\n........\r\n```',b'1','好久没刷算法题了......\r\n乍一刷有点自闭........\r\n虽说代码写出来了吧但是感觉还是不太好'),(106,8,'2020-04-02 00:00:00','spring boot解决文件存储的虚拟路径问题','http://img.xuhaobo.site/89',3,'*我们都知道,有些大文件我们无法放入数据库中,需要在数据库中存储存储路径而在本机中去获取,很多企业有自己的文件服务器,我在新血来潮想开发音乐网站的过程中就遇到了相关的问题.......y1s1,有点酸爽......找了半天csdn....也算是终于找到相关的地址了....项目还在接着开发,目前也只是找到了windows的解决方案....linux等部署的时候更新吧23333*\r\n\r\n我参考的csdn文章是:\r\n\r\n&emsp;&emsp;首先说一下需求:就是从前端传文件到后端,之后后端通过输入输出流存储文件到指定路径,之后存储到本地,随后访问前端时后端把本地地址给前端,(这里看着是tm挺简单的),这里可能有的网站说前端src可以用file://获取本地文件,但事实上很多浏览器现在已经开始不支持访问本地文件了,我们如果想要访问本地文件,所以我们需要配置一个类能够建立本地文件与前端uri的映射,这样虽然看似套上了uri的壳,但我们依然可以获取本地文件了\r\n\r\n核心的java配置类代码如下:\r\n```java\r\n    @Configuration\r\n    public class FileConfig extends WebMvcConfigurerAdapter {\r\n    \r\n        public static String filePath=\"D:\\\\music\\\\\"; //配置的本地物理保存地址\r\n    \r\n    \r\n        //核心的配置方法,实现映射,我们可以理解成:/file/文件名请求路径   实质指的是 file:///D:/music/文件名\r\n        @Override\r\n        public void addResourceHandlers(ResourceHandlerRegistry registry) {\r\n           registry.addResourceHandler(\"/file/**\").addResourceLocations(\"file:///\"+filePath);\r\n           super.addResourceHandlers(registry);\r\n        }\r\n    \r\n    \r\n        //自己写的将文件名转化为uri的方法\r\n        public static String getURI(String str)\r\n        {\r\n            return \"/file/\"+str;\r\n        }\r\n    \r\n    \r\n    }\r\n```\r\n\r\n这样我们就可以通过请求路径来实现访问本地数据了\r\n实际存储到数据库,前端的src都是转化后的请求路径即可\r\n\r\n这里也贴一下前端的代码\r\n前端用的是thymeleaf模板渲染的技术\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\" xmlns:th=\"http://www.w3.org/1999/xhtml\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n</head>\r\n<body>\r\n\r\n<!--html5 audio 从后端取src-->\r\n\r\n<audio th:if=\"${musics}\" th:each=\"music:${musics}\" controls=\"controls\" th:src=\"@{${music.uri}}\">\r\n    Your browser does not support the audio element.\r\n</audio>\r\n\r\n<!--文件上传表单,注意这里一定要加 enctype=\"multipart/form-data\"属性-->\r\n\r\n<form method=\"post\" action=\"upload\" enctype=\"multipart/form-data\">\r\n    <input type=\"file\" name=\"file\" accept=\"music/*\"/><br>\r\n    <input name=\"name\" placeholder=\"请输入歌曲名\"/><br>\r\n    <input name=\"style\" placeholder=\"请输入歌曲风格\"/><br>\r\n    <input name=\"singer\" placeholder=\"请输入歌手名\"/><br>\r\n    <input type=\"submit\">\r\n</form>\r\n\r\n\r\n</body>\r\n</html>\r\n```',b'1','我们都知道,有些大文件我们无法放入数据库中,需要在数据库中存储存储路径而在本机中去获取,很多企业有自己的文件服务器,我在新血来潮想开发音乐网站的过程中就遇到了相关的问题.......y1s1,有点酸爽......找了半天csdn....也算是终于找到相关的地址了....项目还在接着开发,目前也只是找到了windows的解决方案....linux等部署的时候更新吧23333'),(107,15,'2020-04-02 00:00:00','Numpy ndarray数组的生成以及相关修改操作','https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3890848816,3171555074&fm=26&gp=0.jpg',7,'*大概可以分为四类:\r\n1.生成指定数字的数组\r\n2.从原有数组中生成数组(分深拷贝和浅拷贝两类)\r\n3.生成成正态分布和均匀分布的随机数数组\r\n4.生成一定范围的等差数列*\r\n\r\n\r\n```python\r\nimport matplotlib.pyplot as plt\r\nimport random\r\nimport numpy as np\r\n%matplotlib inline\r\n#生成数组(指定0和1)\r\narray1=np.zeros(20)         \r\nprint(array1)\r\narray2=np.ones((10,10))  #传入shape元组\r\nprint(array2)\r\n#生成数组(均匀分布和正态分布)\r\nnp.random.uniform(0,1,size=(100,100))                #(low,hign,size)\r\nprint(np.random.normal(1,2,size=(100,100)))          #正态分布(平均值,标准差,)\r\n\r\n#生成数组(从现有拷贝中生成)\r\narray2=np.array([[1,2,3],[4,5,6]])    #深拷贝\r\narray1=np.asarray(array2)             #浅拷贝\r\nprint(array2==array1)\r\n\r\n#从固定范围内生成数组\r\nprint(np.linspace(0,1,5))               #生成一个数到另一个数的等差数列(start,end,等差数列中的数字个数)\r\nprint(np.arange(0,5,2))                 #同样还是生成一个数到另一个数的等差数列(start,end,等差数列的步长值)\r\n\r\n```\r\n\r\n\t数组的相关修改操作,由于修改后修改的是对象,所以采用 对象.方法()的形式进行修改\r\n```python\r\nimport matplotlib.pyplot as plt\r\nimport random\r\nimport numpy as np\r\n%matplotlib inline\r\n#修改数组形状(因为是修改一个对象,所以这里都直接采用对象.方法而非np.函数的方式进行操作)\r\narray1=np.array([[1,2,3],[1,1,1]])\r\narray2=array1.reshape((3,-1))     #reshape不能改变其本身在内存中的大小,因此形状的乘积,面积不同\r\nprint(array2)\r\nprint(array2.T)\r\n#修改数组的类型\r\nprint(array2.dtype)\r\nprint(array2.astype(\"float32\").dtype)\r\nprint(array2.tostring())   #序列化(哪天专门再写个文章说一下序列化吧哈哈哈)\r\nprint(np.unique(array2))\r\n```',b'1','大概可以分为四类:\r\n1.生成指定数字的数组\r\n2.从原有数组中生成数组(分深拷贝和浅拷贝两类)\r\n3.生成成正态分布和均匀分布的随机数数组\r\n4.生成一定范围的等差数列'),(108,20,'2020-04-04 00:00:00','王爽<<汇编语言>>实验一','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',8,'看完csapp后(其实自己太菜太渣lab做不下去了之后)自己打算开始学习操作系统方面的知识,自己本身对于操作系统算是比较感兴趣吧,但是自己在上哈工大李治军老师的OS课时发现了8086汇编代码.....(我TM只能看懂x86-64的皮毛),于是便展开了王爽这本书的学习......\r\n\r\n前几章和实验一的内容个人觉得其实东西并不多,大概和x86-64的区别就在于着重说了段寄存器cs和指令寄存器ip\r\n我们可以姑且理解为:地址=cs左移一位+ip的值\r\n好了步入正题我们来说**实验**:\r\n\r\n\t(1)(2)其实都是在考关于dos的使用,这里比较坑的地方就是win10去掉了貌似xp和win7都用的DOS debug,不过我们可以通过安装实验环境来进行\r\n\r\n（3）第三问要求在ROM区寻找一个生产日期,我大概认为我找到的是这个地址所存\r\n的内存块的值:\r\n![](http://img.xuhaobo.site/11)\r\n(或许是看着像吧.....)\r\n可以分析出第一个图这里存储的**\"30\",\"31\"**就是后面所实际acsii码对应的01而\"/\"则是哪个2F\r\n\r\n随后我试图修改了一下这个地址的数据值![](http://img.xuhaobo.site/72)\r\n这里可以看出我把那个01应该修改成了\"12\"\r\n接下来我再查询地址![](http://img.xuhaobo.site/11)\r\n发现与之前的内存单元所存值相等.后来注意到了题干的**\"ROM\"**\r\nROM是只读访问存储器不可更改(我又懂了)\r\n补充:ROM所对应的虚拟内存地址为A000H~FFFFH\r\n\r\n（4)\r\n首先依据题干向指定内存写入值:\r\n![](http://img.xuhaobo.site/71)\r\n发现居然出现了这么个小图案\r\n![](http://img.xuhaobo.site/15)\r\n修改一下输入试试~~~\r\n![](http://img.xuhaobo.site/16)\r\n图案颜色也在发生变化\r\n![](http://img.xuhaobo.site/17)\r\n所运用的知识:在8086pc机的内存地址空间分配中\r\n规定了A0000~BFFFF为显存\r\n向显存中写数据会直接被显示卡输出到显示器上\r\n![](http://img1.imgtn.bdimg.com/it/u=580104775,186890874&fm=15&gp=0.jpg)',b'1','看完csapp后(其实自己太菜太渣lab做不下去了之后)自己打算开始学习操作系统方面的知识,自己本身对于操作系统算是比较感兴趣吧,但是自己在上哈工大李治军老师的OS课时发现了8086汇编代码.....(我TM只能看懂x86-64的皮毛),于是便展开了王爽这本书的学习......'),(109,2,'2020-04-04 00:00:00','[leetcode]42. 接雨水','http://img.xuhaobo.site/21',5,'*leetcode新出的每日一题这个栏目快给我强迫症都梭出来了.....\r\n今天的每日一题所考察的的算法是单调栈,也是每日一题里目前少数的几个\"困难\"*\r\n\r\n参考了雪姨的题解\r\nhttps://leetcode-cn.com/problems/trapping-rain-water/solution/dan-diao-zhan-jie-jue-jie-yu-shui-wen-ti-by-sweeti/\r\n接下来先分析一下问题:![](http://img.xuhaobo.site/19)\r\n可以看到它接雨水的轮廓大概就是向向下再往上升的过程\r\n所以.....好吧我没接触过单调栈看题解才今天勉强学会了一点....\r\n我们可以根据栈的特点,将水的不规则体积(好像也挺规则)化成一个个规则矩形\r\n大概就是去维护一个降序的栈一旦有升序的情况我们可以理解成这里就可以分出了一个\r\n![](http://img.xuhaobo.site/20)\r\n的思路\r\n\r\n对于面积高的运算:\r\n一旦遍历到一个不符合降序的值随后\r\n开始外层遍历直到遍历到符合栈顶大于height[i]\r\n出栈(这个值最终被减去)\r\n同时也将维护的递减栈里和它相等的数一律出栈(我们只需要求一个值用于求高)\r\n通过比较它左边的值与该不符合降序的值(也就是height[i])比较出比较小的一个\r\n求出高(能留下雨水的取小的),随后用这个高减去那个被出栈的之前留下的height值\r\n\r\n对于底的运算:右边下标-被搜寻到的小的数左下标-1\r\n\r\n随后累加\r\n```java\r\nclass Solution {\r\n    public int trap(int[] height) {\r\n        Stack<Integer> s=new Stack<>();\r\n        int anw=0;\r\n        for(int i=0;i<height.length;i++)\r\n        {\r\n            while(!s.isEmpty()&&height[i]>height[s.peek()])\r\n            {\r\n                int index=s.pop();\r\n                while(!s.isEmpty()&&height[s.peek()]==height[index])      \r\n                {\r\n                    s.pop();              //后面相等的全都出栈\r\n                }\r\n                if(!s.isEmpty())\r\n                {\r\n                    anw+=(i-s.peek()-1)*(Math.min(height[s.peek()],height[i])-height[index]);\r\n                }\r\n            }\r\n            s.push(i);\r\n        }\r\n        return anw;\r\n    }\r\n}\r\n```',b'1','leetcode新出的每日一题这个栏目快给我强迫症都梭出来了.....\r\n今天的每日一题所考察的的算法是单调栈,也是每日一题里目前少数的几个\"困难\"'),(110,20,'2020-04-05 00:00:00','王爽<<汇编语言>>实验二&&第三章总结','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',2,'``*第三章依然是寄存器的内容,不过涉及了内存的部分，个人对于关于栈满后究竟是覆盖栈段内容还是栈以外的内存部分还是有点懵逼 。。。。:tw-1f436:*\r\n\r\n检测点3.1:\r\n 1.这里大概注意一下段寄存器里是一不是零就好了,所以数据是从第二行开始读起\r\n 的而并非第一行,这个算是要着力重视的一个点,另外就是第三问\"add al,bl\"要看清楚寄存器的种类,比方说是AX,AH还是AL\r\n2.其实也没什么好说的,我之前理解错了过程:tw-1f637: :tw-1f637:,做完体会就是在8086中指令按顺序执行时,改变的是ip的值(ip+=指令段长度)\r\n实验部分:\r\n(1)比较简单,就是熟悉下程序出栈入栈的过程,敲一遍就完事了~~~\r\n![](http://img.xuhaobo.site/22)\r\n(2)\r\n![](http://img.xuhaobo.site/23)\r\n 第二问我自己每一步都在Debug中看了一下2000:0的变化,得出了如下图的分析:\r\n ![](http://img.xuhaobo.site/24)\r\n ![](http://img.xuhaobo.site/25)\r\n ![](http://img.xuhaobo.site/26)\r\n 我们可以理解着在栈中不仅保存着我们所存储的数据,还有当前指令的CS,IP值以及其段地址所对应寄存器的值\r\n 个人目前只能理解到这一步了哈哈哈哈',b'1','第三章依然是寄存器的内容,不过涉及了内存的部分，个人对于关于栈满后究竟是覆盖栈段内容还是栈以外的内存部分还是有点懵逼 。。。。'),(111,2,'2020-04-05 00:00:00','[leetcode]460. LFU缓存','http://img.xuhaobo.site/27',4,'*wdnmd太难了,写了个性能极差的算法,以及一个代码层面完全看不懂的实现，我是个菜鸡*\r\n提供个自己或许只能这么写能写出来的java辣眼睛烂代码版本\r\n```java\r\nclass LFUCache {\r\n\r\n    int minKey=-1;\r\n    int minValue=Integer.MAX_VALUE;\r\n    int size;\r\n    TreeMap<Integer,LinkedList<Integer>>m=new TreeMap<>();    //key为使用次数\r\n    Map<Integer,Integer>count=new HashMap<>();           //实际次数\r\n    Map<Integer,Integer>cache=new HashMap<>();           //实际缓存\r\n\r\n    void checkAndchange(int last,int key)                                //根据访问数的修改对TreeMap进行操作\r\n    {\r\n        LinkedList<Integer>list=m.get(last);\r\n        for(int i=0;i<list.size();i++)\r\n        {\r\n            if(list.get(i)==key)\r\n            {\r\n                list.remove(i);\r\n                break;\r\n            }\r\n        }\r\n        int count=last+1;\r\n        if(m.get(count)!=null)              //本身不存在\r\n        {\r\n            m.get(count).add(key);               //这里我试试行不行 \r\n        }else\r\n        {\r\n            list=new LinkedList<Integer>();\r\n            list.add(key);\r\n            m.put(count,list);\r\n        }\r\n    }\r\n\r\n    int getMin()\r\n    {\r\n        Integer firstKey=null;\r\n        for(Integer key:m.keySet())\r\n        {\r\n            if(m.get(key).size()>0)\r\n            {\r\n                firstKey=key;\r\n                break;\r\n            }\r\n        }\r\n        if(firstKey==null)\r\n        {\r\n            return Integer.MIN_VALUE;\r\n        }\r\n        LinkedList<Integer> list=m.get(firstKey);\r\n        int anw=list.getFirst();\r\n        list.removeFirst();\r\n        if(list.size()==0)\r\n        {\r\n            m.remove(firstKey);//删除列表\r\n        }\r\n        return anw;\r\n    }\r\n\r\n    public LFUCache(int capacity) {\r\n        this.size=capacity;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if(cache.get(key)!=null)     //本身存在\r\n        {\r\n            int last=count.get(key);\r\n            count.put(key,last+1);    //查询一次加一一次\r\n            checkAndchange(last,key);\r\n            System.out.println(\"查询\"+key+\"返回\"+cache.get(key));\r\n            return cache.get(key);  \r\n        }else{\r\n            System.out.println(\"返回\"+\"-1\"+\"未找到\"+key);\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if(size==0)\r\n        {\r\n            return;\r\n        }\r\n        if(cache.get(key)!=null)\r\n        {\r\n            cache.put(key,value);\r\n            int last=count.get(key);\r\n            count.put(key,last+1);    //查询一次加一一次\r\n            checkAndchange(last,key);\r\n        }else{\r\n            if(cache.size()==size)\r\n            {\r\n                int num=getMin();\r\n                if(num!=Integer.MIN_VALUE)\r\n                {\r\n                    cache.remove(num);\r\n                }\r\n            }\r\n            cache.put(key,value);\r\n            count.put(key,1);\r\n            LinkedList<Integer> list=m.get(1);\r\n            if(list==null)\r\n            {\r\n                list=new LinkedList<Integer>();\r\n            }\r\n            list.add(key);\r\n            m.put(1,list);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your LFUCache object will be instantiated and called as such:\r\n * LFUCache obj = new LFUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n```',b'1','wdnmd太难了,写了个性能极差的算法,以及一个代码层面完全看不懂的实现，我是个菜鸡\r\n提供个自己或许只能这么写能写出来的java辣眼睛烂代码版本~~~~'),(112,2,'2020-04-06 00:00:00','[leetcode]72. 编辑距离','http://img.xuhaobo.site/28',4,'*今天出去玩了有点累状态不太好,自己动态规划也学得自认为不是很熟悉.....看过题解草草理解就写了一遍.....*\r\n\r\n具体参考文章\r\nhttps://leetcode-cn.com/problems/edit-distance/solution/zi-di-xiang-shang-he-zi-ding-xiang-xia-by-powcai-3/\r\n就这样吧睡了睡了\r\n**题目如下:**\r\n![](http://img.xuhaobo.site/28)\r\n**> 代码如下:**\r\n```java\r\nclass Solution {\r\n    public int minDistance(String word1, String word2) {\r\n        if(word1.length()==0||word2.length()==0)\r\n        {\r\n            return word1.length()==0?word2.length():word1.length();\r\n        }\r\n        int [][]edit=new int[word1.length()+1][word2.length()+1];\r\n        \r\n        for(int i=0;i<=word1.length();i++)\r\n        {\r\n            edit[i][0]=i;\r\n        }\r\n        for(int j=0;j<=word2.length();j++)\r\n        {\r\n            edit[0][j]=j;\r\n        }\r\n\r\n        for(int i=1;i<=word1.length();i++)\r\n        {\r\n            for(int j=1;j<=word2.length();j++)\r\n            {\r\n                    if(word1.charAt(i-1)==word2.charAt(j-1))\r\n                    {\r\n                        edit[i][j]=edit[i-1][j-1];\r\n                    }\r\n                    else{\r\n                        edit[i][j]=Math.min(Math.min(edit[i-1][j-1],edit[i-1][j]),edit[i][j-1])+1;\r\n                    }\r\n            }\r\n        }\r\n        return edit[word1.length()][word2.length()];\r\n    }\r\n}\r\n```',b'1','今天出去玩了有点累状态不太好\r\n自己动态规划也学得自认为不是很熟悉.....\r\n看过题解草草理解就写了一遍.....\r\n具体参考文章\r\nhttps://leetcode-cn.com/problems/edit-distance/solution/zi-di-xiang-shang-he-zi-ding-xiang-xia-by-powcai-3/\r\n就这样吧睡了睡了'),(113,8,'2020-04-07 00:00:00','对于mybatis对于一对多复合对象进行PageHelper分页的解决方案','https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=848859921,2201379319&fm=26&gp=0.jpg',9,'*最近在维护更新这个博客系统的过程中,发现了对于包含时间以及其对应的博客数的时间轴对象的分页查询中,不能够按照\"时间\"进行正确的分页,这里提供下踩过坑之后的解决方案~~~*\r\n\r\n\r\n\r\n```java\r\npublic class TimeLine {\r\n    private Date time;         //哪一天\r\n    private List<Article> articleList;\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"TimeLine{\" +\r\n                \"time=\" + time +\r\n                \", articleList=\" + articleList +\r\n                \'}\';\r\n    }\r\n\r\n    public Date getTime() {\r\n        return time;\r\n    }\r\n\r\n    public void setTime(Date time) {\r\n        this.time = time;\r\n    }\r\n\r\n    public List<Article> getArticleList() {\r\n        return articleList;\r\n    }\r\n\r\n    public void setArticleList(List<Article> articleList) {\r\n        this.articleList = articleList;\r\n    }\r\n}\r\n```\r\n首先这是我们要查询的timeStamp对象,我们的目的是在按照time字段进行分页\r\n\r\n![这是article表的字段信息,我们接下来的查询都基于这张表进行](http://img.xuhaobo.site/29 \"这是article表的字段信息,我们接下来的查询都基于这张表进行\")\r\n\r\n如下是之前进行左连查询最后返回对象的mybatis xml文件\r\n这种查询方式**不能**正确地返回我们想要得到的结果\r\n不能够按照createTime进行分页\r\n\r\n```xml\r\n<resultMap id=\"timeLines\" type=\"com.example.xhbblog.pojo.TimeLine\">\r\n    <result column=\"createTime\" property=\"time\"/>\r\n    <collection property=\"articleList\" ofType=\"com.example.xhbblog.pojo.Article\">\r\n      <id column=\"id\" property=\"id\"/>\r\n      <result column=\"title\" property=\"title\"/>\r\n      <result column=\"content\" property=\"content\"/>\r\n    </collection>\r\n  </resultMap>\r\n\r\n  <select id=\"findTimeLines\" resultMap=\"timeLines\">\r\n    select a1.createTime,a2.id,a2.title,a2.content from article a1\r\n    left join article a2 ON a2.createTime=a1.createTime\r\n    where a1.published=true and a2.published=true\r\n    order by a1.createTime desc\r\n  </select>\r\n```\r\n\r\n百度后看到这种查询目前在mybatis中不能使用左连查询,必须使用子查询实现\r\n同时要使用**DISTINCT**关键字查询时间,不然会查出重复的时间从而重复查询\r\n\r\nxml解决方案如下:\r\n```xml\r\n  <resultMap id=\"timeLines\" type=\"com.example.xhbblog.pojo.TimeLine\">\r\n    <result column=\"createTime\" property=\"time\"/>\r\n    <collection property=\"articleList\" ofType=\"com.example.xhbblog.pojo.Article\" select=\"getArticlesByTime\" javaType=\"java.util.List\" column=\"{createTime=createTime}\">\r\n      <result column=\"id\" property=\"id\"/>\r\n      <result column=\"title\" property=\"title\"/>\r\n    </collection>\r\n  </resultMap>\r\n\r\n  <select id=\"findTimeLines\" resultMap=\"timeLines\" parameterType=\"map\">\r\n    select  DISTINCT createTime from article order by createTime\r\n  </select>\r\n\r\n  <select id=\"getArticlesByTime\" parameterType=\"map\"\r\n          resultType=\"map\">\r\n    select id,title from article a2 where a2.createTime=#{createTime}\r\n  </select>\r\n\r\n```\r\n\r\n\r\n\r\n注解解决方案如下:\r\n```java\r\n  @Select(\"select DISTINCT createTime from article where published=true order by createTime DESC\")\r\n    @Results({\r\n            @Result(property = \"time\",column = \"createTime\"),\r\n            @Result(property = \"articleList\",column = \"createTime\",one=@One(select = \"com.example.xhbblog.mapper.ArticleMapper.selectByCreateTime\"))\r\n    })\r\n    List<TimeLine> findTimeLines();      //时间轴查询\r\n\r\n    @Select(\"select id,title from article where published=true and createTime=#{createTime}\")\r\n    @Results({\r\n            @Result(property = \"id\",column = \"id\"),\r\n            @Result(property = \"title\",column = \"title\")\r\n    })\r\n    List<Article> selectByCreateTime(Date createTime);\r\n```\r\n个人踩坑经历如上~~~',b'1','最近在维护更新这个博客系统的过程中,发现了对于包含时间以及其对应的博客数的时间轴对象的分页查询中,不能够按照\"时间\"进行正确的分页,这里提供下踩过坑之后的解决方案~~'),(114,2,'2020-04-07 00:00:00','[leetcode]面试题 01.07. 旋转矩阵','http://img.xuhaobo.site/31',2,'*今天的每日一题算是放在前几天的**\"劝退三板斧\"**里比较轻松的一道了,如果自己使用额外的内存应该是很容易实现的,现在我们说一下不使用额外内存的方法*\r\n\r\n\t本来自己想了半天想到了一个类似于顺时针旋转的方法但是没有找到规律最后还是取看题解了.......还是太菜惹的祸哈哈哈哈\r\n\r\nleetcode题目如下:\r\n![](http://img.xuhaobo.site/31)\r\n\r\njava实现代码如下\r\n\r\n```java\r\nclass Solution {\r\n    public void rotate(int[][] matrix) {\r\n        if(matrix.length<=1)\r\n        {\r\n            return;\r\n        }\r\n        //将矩阵转置\r\n        for(int i=0;i<matrix.length;i++)\r\n        {\r\n            for(int j=i;j<matrix.length;j++)\r\n            {\r\n                if(i!=j)\r\n                {\r\n                    int tmp=matrix[i][j];\r\n                    matrix[i][j]=matrix[j][i];\r\n                    matrix[j][i]=tmp;\r\n                }\r\n            }\r\n        }\r\n        //将矩阵沿中心线转置\r\n        for(int i=0;i<matrix.length;i++)\r\n        {\r\n            for(int j=0;j<matrix.length/2;j++)\r\n            {\r\n                int tmp=matrix[i][j];\r\n                matrix[i][j]=matrix[i][matrix.length-j-1];\r\n                matrix[i][matrix.length-j-1]=tmp;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n代码比较易懂这里就不讲解了。。。\r\n参考的依然是雪姨的题解.....\r\n果然多简单的题想要做好都是难的\r\n啥时候自己也能这么有思路呢',b'1','今天的每日一题算是放在前几天的\"劝退三板斧\"里比较轻松的一道了,如果自己使用额外的内存应该是很容易实现的,现在我们说一下不使用额外内存的方法'),(115,2,'2020-04-08 00:00:00','[leetcode]面试题13. 机器人的运动范围','http://img.xuhaobo.site/32',2,'*算是我这段时间遇到的每日一题了比较实现简单的了,大体的思路就是深度优先搜索(应该广度也可以),之后用一个集合来去重,根据搜索条件进行筛选,不过测试结果在内存消耗上还可以,运行时间还是一言难尽,路漫漫其修远兮吧哈哈哈哈哈哈哈*\r\n\r\n题目如下:\r\n![](http://img.xuhaobo.site/32)\r\n\r\n代码如下,比较好理解这里不一一讲解了\r\n```java\r\nclass Solution {\r\n    Set<String> visited=new HashSet<>();      //用于判重\r\n    public int sum(int a)\r\n    {\r\n        int sum=0;\r\n        while(a>0)\r\n        {\r\n            sum+=a%10;\r\n            a/=10;\r\n        }\r\n        return sum;\r\n    }\r\n    public boolean overFlow(int x,int y,int m,int n)\r\n    {\r\n        return x>=0&&x<n&&y>=0&&y<m;\r\n    }\r\n    \r\n    public int DFS(int x,int y,int m,int n,int k)\r\n    {\r\n        System.out.println(x+\",\"+y);\r\n        visited.add(x+\",\"+y);\r\n        int sum=1;\r\n        int []a1={0,1,-1,0};\r\n        int []a2={1,0,0,-1};\r\n        for(int i=0;i<4;i++)\r\n        {\r\n            int x1=x+a1[i];\r\n            int y1=y+a2[i];\r\n            if(overFlow(x1,y1,m,n)==true&&sum(x1)+sum(y1)<=k&&!visited.contains(x1+\",\"+y1))\r\n            {\r\n                sum+=DFS(x1,y1,m,n,k);\r\n            }\r\n        }\r\n        return sum;\r\n    }\r\n    public int movingCount(int m, int n, int k) {\r\n        return DFS(0,0,m,n,k);\r\n    }\r\n}\r\n```',b'1','算是我这段时间遇到的每日一题了比较实现简单的了,大体的思路就是深度优先搜索(应该广度也可以),之后用一个集合来去重,根据搜索条件进行筛选,不过测试结果在内存消耗上还可以,运行时间还是一言难尽,路漫漫其修远兮吧哈哈哈哈哈哈哈'),(116,20,'2020-04-08 00:00:00','王爽<<汇编语言>>实验四&&四,五章总结','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',5,'*实验三个人认为没什么难度,所以直接略过去了,下面着重说一下第五章的实验*\r\n\r\n1.比较简单,这里懒惰地略过了,反正和第二问一样~~\r\n2.代码如图:\r\n![](http://img.xuhaobo.site/33)\r\n这里循环体利用了数据为0~63,也就是一直都只占一个子节,所以直接传递bl过去就可以实现\r\n3.自己分析了一段时间,后来发现利用的也是一种\"我们存储的指令也同样可以被视为数据\"这样的思想,所以将ax设为cs寄存器所存储的程序段段地址,由于需要将\r\n**mov ax,4c00h**这条指令之前的指令转移,故我们需要**mov ax,4c00h**以及\r\n**int 21h**两条指令所存储带来的字节数,\r\n我们可以通过上一个程序来求出\r\n![](http://img.xuhaobo.site/34)\r\n可以算出所占子节总数为5\r\n这里有一个小技巧\r\n\"**cx在程序开始时默认存储程序的长度**\"\r\n又因为其他伪指令不被编译为机器码,由编译器执行形成描述信息入口地址,所以我们只需要将cx设置为原始的cx-5即可\r\n具体汇编代码如下:\r\n![](http://img.xuhaobo.site/35)',b'1','实验三个人认为没什么难度,所以直接略过去了,下面着重说一下第五章的实验\r\n\r\n1.比较简单,这里懒惰地略过了,反正和第二问一样~~\r\n2.代码如图:\r\n![](http://q7xlyvqgm.bkt.clouddn.com/33)\r\n这里循环体利用了数据为0~63,也就是一直都只占一个子节,所以直接传递bl过去就可以实现\r\n3.自己分析了一段时间,后来发现利用的也是一种\"我们存储的指令也同样可以被视为数据\"这样的思想,所以将ax设为cs寄存器所存储的程序段段地址,由于需要将\r\nmov ax,4c00h这条指令之前的指令转移,故我们需要mov ax,4c00h以及'),(117,2,'2020-04-09 00:00:00','[leetcode]22. 括号生成','http://img.xuhaobo.site/36',4,'*今天的leetcode每日一题也是比较简单的,貌似有更好的算法,这里提供下自己的思路*\r\n\r\n大概就是简单的DFS回溯,这里用了一下通过判断左括号右括号的个数剪枝,因为我们自身根据题意可以推测出如果此时**左括号数少于右括号数**,那么一定不是**有效**的,而如果**左括号数多于总数的一半**,那么也一定不是有效的\r\n\r\n题目如下:\r\n![](http://img.xuhaobo.site/36)\r\njava实现的代码如下:\r\n```java\r\nclass Solution {\r\n    public void DFS(int n,int leftSize,int rightSize,String str,List<String> anw)\r\n    {\r\n        if(str.length()==2*n)\r\n        {\r\n            if(leftSize==rightSize)\r\n            {\r\n                anw.add(str);\r\n            }\r\n        }else{\r\n            if(leftSize>n)       //通过个数判断剪枝\r\n            {\r\n                return;\r\n            }\r\n            DFS(n,leftSize+1,rightSize,str+\"(\",anw);\r\n            if(leftSize>rightSize)\r\n            {\r\n                DFS(n,leftSize,rightSize+1,str+\")\",anw);\r\n            }            \r\n        }\r\n    }\r\n    public List<String> generateParenthesis(int n) {\r\n        List<String> anw=new ArrayList<>();\r\n        DFS(n,0,0,\"\",anw);        //起始的leftSize和rightSize均为0\r\n        return anw;\r\n    }\r\n}\r\n```\r\n\r\n运行结果:\r\n![](http://img.xuhaobo.site/37)\r\n用时上还可以,好像内存用得有点多',b'1','今天的leetcode每日一题也是比较简单的,貌似有更好的算法,这里提供下自己的思路\r\n大概就是简单的DFS回溯,这里用了一下通过判断左括号右括号的个数剪枝,因为我\r\n们自身根据题意可以推测出如果此时左括号数少于右括号数,那么一定不是\r\n有效的,而如果左括号数多于总数的一半,那么也一定不是有效的'),(118,2,'2020-04-10 00:00:00','[leetcode]151. 翻转字符串里的单词','http://img.xuhaobo.site/38',6,'*今天的leetcode之前刷过,感觉难度不算很大,通过率低应该式边界问题卡得比较厉害导致的，总体就是把边界条件想全,那么问题就不大了,具体题目如下:*\r\n\r\n![](http://img.xuhaobo.site/38)\r\n提供一下之前写的java代码的版本:\r\n```java\r\nclass Solution {\r\n    public String reverseWords(String s) {\r\n        s=s.trim();\r\n        String []strs=s.split(\" \");\r\n        StringBuffer anw=new StringBuffer();\r\n        for(int i=strs.length-1;i>=0;i--)\r\n        {\r\n            if(strs[i].equals(\" \")==false)\r\n            {\r\n            strs[i]=strs[i].trim();\r\n            if(strs[i].length()==0)\r\n            {\r\n                continue;\r\n            }\r\n            anw.append(strs[i]).append(\" \");\r\n            }\r\n        }\r\n        return anw.toString().trim();\r\n    }\r\n}\r\n```\r\n这是原来代码的提交结果:\r\n![](http://img.xuhaobo.site/39)',b'1','今天的leetcode之前刷过,感觉难度不算很大,通过率低应该式边界问题卡得比较厉害导致的，总体就是把边界条件想全,那么问题就不大了,这里提供下java代码的版本,(主要是自己别的现在都不熟了就会写java哈哈哈)'),(119,20,'2020-04-10 00:00:00','王爽<<汇编语言>>实验五','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',1,'*第六章总体内容不多,总体来讲就是对于汇编语言自己给内存划分栈,数据,和指令\r\n的相关内容,下面说一下对实验五的看法以及心得体会*\r\n\r\n（1）,（2）实验:\r\n\r\n大概就是熟悉一下划分段后的相关操作,值得说的地方就是第(2)题的第四问\r\n**如果段中的数据占N个子节,则程序加载后,该段实际占有的空间为多少子节?**\r\n(1)中的栈与数据的划分均为8字16子节,而其段寄存器值也是都相差1\r\n而(2)中的栈和数据均为2个字,也就是4字节,但其段寄存器值也是同样只相差1,因此我们应该可以得到一个普遍规律\r\n程序加载后,该段实际所占空间为**([N/16]+1)*16**个字节(*这里的[]的意义为小于该数的最小整数*)\r\n\r\n(3)实验\r\n前三问和之前一样的套路,没有什么难度\r\n第(4)问主要说的是end指定了程序的执行入口,也就是具体那一段程序被视作指令\r\n如果没有具体指定的话就会使得**cs寄存器段中所有的数据均被视为指令**\r\n**当执行程序的程序(command,debug)将我们定义的数据段也当作指令时就会出现问题**\r\n因此只有(3)中的程序cs段地址与指令地址重合,所以(3)仍然可以正确执行\r\n第五,六问就是做一点编码上的实际练习,注意一下第五问**分配的是字节单元**\r\n而非字单元\r\n第五问代码如下:\r\n![](http://img.xuhaobo.site/40)\r\n\r\n![](http://img.xuhaobo.site/41)\r\n第六问代码如下:\r\n![](http://img.xuhaobo.site/42)\r\n\r\n![](http://img.xuhaobo.site/43)',b'1','第六章总体内容不多,总体来讲就是对于汇编语言自己给内存划分栈,数据,和指令\r\n的相关内容,下面说一下对实验五的看法以及心得体会'),(120,20,'2020-04-11 00:00:00','王爽<<汇编语言>>实验六','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',2,'*第七章大概讲述了几种比较复杂的访存方式(寻址方式)*\r\n\r\n与c语言二维数组或者结构比较学习就可以很快地掌握原理,同时通过这些寻址方式我们可以逐渐把原本看似零散的数据抽象为一个个数据结构,这里也体现了c语言数组访问的一些具体的细节\r\n\r\n用到的一个大小写变换比较有意思的地方:\r\n可以通过位运算\r\nand 设定某一位为0\r\nor  设定某一位为1（**二进制,and,or的数后面要加B**）\r\n之后通过or或者and直接控制ascii码范围从而改变大小写\r\n\r\n(1)这种上机调试自己走一遍就好,不多赘述了\r\n(2)程序代码为:\r\n![](http://img.xuhaobo.site/44)\r\n\r\n![](http://img.xuhaobo.site/45)\r\n\r\n在debug中查看运算结果:\r\n![](http://img.xuhaobo.site/46)',b'1','第七章大概讲述了几种比较复杂的访存方式(寻址方式)\r\n\r\n与c语言二维数组或者结构比较学习就可以很快地掌握原理,同时通过这些寻址方式我们可以逐渐把原本看似零散的数据抽象为一个个数据结构,这里也体现了c语言数组访问的一些具体的细节'),(121,20,'2020-04-11 00:00:00','王爽<<汇编语言>>实验七','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',4,'*实验七应该算是一个小小的总结了吧,大概把之前用到的loop循环,各种访存方式都用了一下*\r\n\r\n\r\n编程思路:\r\n1.通过设置三个寄存器的值控制以及公司所有年份显示数据,被写入表,以及被读入雇员数的下标,之后循环遍历\r\n利用多种寻址方式进行运算,三个寄存器步长\r\n值分别为4，16，2\r\n\r\n**需要注意的点:这里被读入的雇员数一定要根据其基址以两个步长值与前面的年份,\r\n收入等分开,因为前面的数据均为4字节,所以每多遍历一个下标便下一次遍历多跳\r\n过一个雇员数**\r\n\r\n1.不能将平均数\r\n代码如下:\r\n前期数据准备:\r\n![](http://img.xuhaobo.site/47)\r\n\r\n![](http://img.xuhaobo.site/48)\r\n**执行指令**\r\n![](http://img.xuhaobo.site/49)\r\n\r\n![](http://img.xuhaobo.site/50)\r\n\r\n结果如下:![](http://img.xuhaobo.site/51)',b'1','实验七应该算是一个小小的总结了吧,大概把之前用到的loop循环,各种访存方式都用了一下\r\n\r\n\r\n编程思路:\r\n1.通过设置三个寄存器的值控制以及公司所有年份显示数据,被写入表,以及被读入雇员数的下标,之后循环遍历\r\n利用多种寻址方式进行运算,三个寄存器步长\r\n值分别为4，16，2'),(122,20,'2020-04-14 00:00:00','王爽<<汇编语言>>第九章实验8&&实验9','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',11,'*不得不说这个转移指令本身理解上是挺容易的,做题上真的把我给雷到了哈哈哈哈\r\n*\r\n\r\n**基础知识:要注意jmp的关键字对应的转移范围,当转移范围超过所需范围时也会报错**\r\n\r\n## **实验八:**\r\n*本题大概就是理解jmp short指令相对寻址的特性*\r\n\r\n首先我通过debug试图在debug过程中找到规律\r\n![](http://img.xuhaobo.site/52)\r\n这里发现两个相对距离是相同的\r\n\r\n随后发现这里可以理解为,在运行过程中将s2的jmp指令复制到了s上,随后再次\r\n跳转到执行s时会去执行**jmp short s1**指令,而恰好其跳转的位置就是\r\n**mov ax,4cooh**,从而结束了程序的执行\r\n图示如下:\r\n![](http://img.xuhaobo.site/53)\r\n\r\n\r\n## **实验九:**\r\n*实验九算是花了我很长时间。。。。,之前一直试图将内层的两个loop写到一个loop里面,最终失败了...*\r\n\r\n大概的思路就是将我们要写的字符串写入指定的显存的偶数位，而具体的屏幕背景\r\n写入偶数位,中间还相关一个居中于屏幕的计算问题(我怀疑我列算错了)\r\n\r\n这个思路想想还算简单不过确实算是自己目前写的最复杂的汇编程序了\r\n\r\n**代码如下(这个博客系统集成的editor.md插件目前代码高亮显示没有汇编属实不太行)**\r\n\r\n    assume cs:codesg,ds:data,ss:stack\r\n    \r\n    data segment\r\n      db \'welcome to masm!\'\r\n      DB 00000010B,00100100B,01110001B\r\n    data ends\r\n    \r\n    stack segment\r\n     dw 32 dup(0)\r\n    stack ends\r\n    \r\n    codesg segment\r\n     start:MOV AX,0B800h\r\n           MOV ES,AX\r\n           MOV AX,DATA\r\n           MOV DS,AX\r\n           MOV BX,6e0h                          ;中间行\r\n           MOV DI,0\r\n           MOV CX,3\r\n           S:\r\n           PUSH CX\r\n           MOV SI,0\r\n           MOV CX,16\r\n    \t   \r\n               S0:MOV AL,DS:[SI]\r\n                  PUSH SI\r\n                  ADD SI,SI\r\n                  MOV ES:[BX+SI+70],AL          ;计算列\r\n                  POP SI\r\n                  INC SI\r\n                  LOOP S0\r\n    \r\n           MOV SI,1\r\n           MOV CX,16\r\n               S1:MOV AL,DS:[16+DI]\r\n                  MOV ES:[BX+SI+70],AL\r\n                  ADD SI,2\r\n                  LOOP S1\r\n    \r\n           POP CX\r\n           INC DI\r\n           ADD BX,0A0H\r\n           LOOP S\r\n    \r\n           MOV AX,4C00H\r\n           INT 21H\r\n    \r\n    codesg ends\r\n    end start\r\n\r\n程序运行结果如下:\r\n![](http://img.xuhaobo.site/54)',b'1','主要是对于实验的一些自己的代码\r\n不得不说这个转移指令本身理解上是挺容易的,做题上真的把我给雷到了哈哈哈哈\r\n基础知识:要注意jmp的关键字对应的转移范围,当转移范围超过所需范围时也会报错'),(123,2,'2020-04-14 00:00:00','[leetcode]445. 两数相加 II','http://img.xuhaobo.site/80',12,'*这次的每日一题是之前用c++过的,这次用java重构了一下,大体思路有两种,一\r\n种是先将链表反转,另一种是将数值先存入栈中,再倒序输出,进行求和计算,并存储\r\n下一位的进位数,应该所谓的**进阶**方法就是第二种利用栈特性反转*\r\n\r\n题目如下：\r\n![](http://img.xuhaobo.site/80)\r\n\r\n这里给出两种语言的进阶思路\r\n\r\n**c++:**\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\r\n        stack<int>S1;\r\n        stack<int>S2;\r\n        ListNode *p=l1;\r\n        ListNode *q=l2;\r\n        while(p)\r\n        {\r\n            S1.push(p->val);\r\n            p=p->next;\r\n        }\r\n        while(q)\r\n        {\r\n            S2.push(q->val);\r\n            q=q->next;\r\n        }\r\n        ListNode *L=NULL;\r\n        int tmp=0;\r\n        while(S1.size()&&S2.size())\r\n        {\r\n            ListNode *p=new ListNode((S1.top()+S2.top()+tmp)%10);\r\n            tmp=(S1.top()+S2.top()+tmp)/10;\r\n            S1.pop();\r\n            S2.pop();\r\n            p->next=L;\r\n            L=p;\r\n        }\r\n        while(S1.size())\r\n        {\r\n            ListNode *p=new ListNode((S1.top()+tmp)%10);\r\n            tmp=(S1.top()+tmp)/10;\r\n            S1.pop();\r\n            p->next=L;\r\n            L=p;\r\n        }\r\n        while(S2.size())\r\n        {\r\n            ListNode *p=new ListNode((S2.top()+tmp)%10);\r\n            tmp=(S2.top()+tmp)/10;\r\n            S2.pop();\r\n            p->next=L;\r\n            L=p;\r\n        }\r\n        if(tmp)\r\n        {\r\n            ListNode *p=new ListNode(tmp);\r\n            p->next=L;\r\n            L=p;\r\n        }\r\n        return L;\r\n    }\r\n};\r\n```\r\n\r\n**java**\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) { val = x; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\r\n        Stack<Integer> s1=new Stack<>();\r\n        Stack<Integer> s2=new Stack<>();\r\n        while(l1!=null)\r\n        {\r\n            s1.push(l1.val);\r\n            l1=l1.next;\r\n        }\r\n        while(l2!=null)\r\n        {\r\n            s2.push(l2.val);\r\n            l2=l2.next;\r\n        }\r\n        ListNode tmp=null;\r\n        int up=0;   //进位值 \r\n        while(!s2.isEmpty()||!s1.isEmpty())        //两栈都未空时\r\n        {\r\n            ListNode node=new ListNode();\r\n            node.next=tmp;\r\n            node.val=up;\r\n            if(!s1.isEmpty())\r\n            {\r\n                node.val+=s1.pop();\r\n            }\r\n            if(!s2.isEmpty())\r\n            {\r\n                 node.val+=s2.pop();\r\n            }\r\n            up=node.val/10;\r\n            node.val%=10;\r\n            tmp=node;\r\n        }\r\n        if(up!=0)\r\n        {\r\n            ListNode node=new ListNode();\r\n            node.val=up;\r\n            node.next=tmp;\r\n            tmp=node;\r\n        }\r\n        return tmp;\r\n    }\r\n}\r\n```',b'1','这次的每日一题是之前用c++过的,这次用java重构了一下,大体思路有两种,一\r\n种是先将链表反转,另一种是将数值先存入栈中,再倒序输出,进行求和计算,并存储\r\n下一位的进位数,应该所谓的进阶方法就是第二种利用栈特性反转'),(124,20,'2020-04-15 00:00:00','王爽<<汇编语言>>第十章实验:三个子程序','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',24,'*感觉汇编开始难起来了,写程序长起来就莫名有点慌.....还是高级语言好啊,感觉这几个代码写得很不好....先把字先码上吧哈哈哈*\r\n\r\n**大概内容就是写三个函数接口,这三个接口也同时起到让后面的程序调用同时实现代码复用的作用**\r\n\r\n### 1.显示字符串\r\n大概思路:这个差不多就是前面那个实验的一种变式吧,通过总结规律计算出行号,列号所对应的偏移,只是通过接口通用化了(当然了即使这样也花了我一个多小时)\r\n\r\n汇编代码如下:\r\n\r\n    assume cs:code\r\n    data segment\r\n      db \'welcome to masm!\',0\r\n    data ends\r\n    \r\n    code segment\r\n    start:mov dh,8\r\n    \t  mov dl,3\r\n    \t  mov cl,2\r\n    \t  mov ax,data\r\n    \t  mov ds,ax\r\n    \t  mov si,0\r\n    \t  call show_str\r\n    \t  \r\n    \t  mov ax,4c00h\r\n    \t  int 21h\r\n    \t  \r\n    show_str:\r\n    \t  \r\n    \t  mov ch,0\r\n    \t  ;确认输入的显存区域\r\n    \t  mov ax,0B800H\r\n    \t  mov es,ax\r\n    \t  \r\n    \t  ;计算对应的行\r\n    \t  mov bl,0A0h\r\n    \t  mov al,dh\r\n    \t  add al,-1\r\n    \t  mov ah,0\r\n    \t  mul bl\r\n    \t  mov di,ax        ;用di存储开始行以及开始列\r\n    \t  \r\n    \t  ;计算对应的列\r\n    \t  mov al,dl\r\n    \t  mov bx,2\r\n    \t  mul bl\r\n    \t  add al,-2\r\n    \t  mov ah,0\r\n    \t  add di,ax\r\n    \t  \r\n    \t  ;将文字输入\r\n    \t  s:mov ax,cx\r\n    \t\tmov cl,ds:[si]\r\n    \t    mov ch,0\r\n    \t    jcxz ok\r\n    \t\tmov es:[di],cl\r\n    \t\tmov cx,ax\r\n    \t\tmov es:[di+1],cl\r\n    \t    inc si\r\n    \t\tadd di,2\r\n    \t\tjmp s\r\n    \r\n    \t\tok:ret\r\n    \t  \r\n    \t  \r\n    code ends\r\n    end start\t \r\n\r\n测试结果如下:\r\n![测试成功!](http://q7xlyvqgm.bkt.clouddn.com/58 \"测试成功!\")\r\n\r\n### 2.解决除法溢出的问题\r\n大概思路:这个自己想的话难度非常大我觉得,看过公式就是通过写代码把那个公式实现吧(单单实现个公式我也是写得贼慢....)\r\n\r\n\r\n    assume cs:code\r\n    \r\n    code segment\r\n    start:mov ax,4240h\r\n    \t  mov dx,000fh\r\n    \t  mov cx,0ah\r\n    \t  call divdw\r\n    \t  mov ax,4c00h\r\n    \t  int 21h\r\n    \t  \r\n    divdw:\r\n    \t  mov si,ax             ;用si保存低位\r\n    \t  mov ax,dx\r\n    \t  mov dx,0\r\n    \t  div cx\r\n    \t  mov bx,ax         ;除得的商暂时存储到bx寄存器中\r\n    \t  mov dx,dx         ;除得的余数\r\n    \t  \r\n    \t  \r\n    \t  mov ax,si         ;将保存的低位返回\r\n    \t  div cx        ;执行后面的除法,此时高位低位都有了\r\n    \r\n    \t  mov cx,dx\r\n    \t  mov dx,bx\r\n    \t  ret\r\n    \t  \r\n    \t  \r\n    code ends\r\n    end start\r\n    \r\n    \r\n\r\n\r\n### 3.数值显示\r\n大概思路:先把字符串输入到数据段里去(**这里注意下其实算是倒着输入的**),之\r\n后调用前面所给的数据接口将数据段的数据显示\r\n\r\n这里说一下自己详细一点的过程吧(踩的坑有点多),一开始在想把数据段和栈段\r\n放在一起，之后发现了这句话\r\n![](http://img.xuhaobo.site/56)\r\n\r\n之后就自己手动地先把输出字符串长度求了出来,根据长度先写入后面的终止符0\r\n(**这里貌似不写也可以,我debug时发现这一段都是空的**)\r\n之后再进行倒序写入\r\n代码如下:(这里是后期测试的代码,所以加上了之前的接口)\r\n\r\n\r\n    assume cs:code\r\n    \r\n    \r\n    data segment\r\n     db 10 dup(0)\r\n    data ends\r\n    \r\n    code segment\r\n      start:mov ax,65535\r\n    \t\tmov bx,data\r\n    \t\tmov ds,bx\r\n    \t\tmov si,0\r\n    \t\tcall dtoc\r\n    \t\t\r\n    \t\tmov dh,8\r\n    \t\tmov dl,3\r\n    \t\tmov cl,2\r\n    \t\tcall show_str\r\n    \t\tmov ax,4c00h\r\n    \t\tint 21h\r\n      \r\n      \r\n      dtoc:\r\n    \t  mov di,ax\r\n    \t   ;计算字符串长度\r\n    \t   mov bx,0\r\n    \t   \r\n    \t   s1:mov cx,10\r\n    \t\t mov dx,0\r\n    \t     div cx\r\n    \t\t inc bx\r\n    \t\t mov cx,ax\r\n    \t\t jcxz write\r\n    \t\t jmp s1\r\n    \t\r\n    \t   ;开始写入到数据段中\r\n    \t   write:mov ax,di\r\n    \t\t\t mov byte ptr ds:[bx],0 \r\n    \t\t\t mov cx,bx\r\n    \t\t\t mov bx,cx\r\n    \t\t\t add bx,-1\r\n    \t\t\t mov si,10\r\n    \t\t\t s2:\r\n    \t\t\t\tmov dx,0\r\n    \t\t\t\tdiv si\r\n    \t\t\t\tmov dh,0\r\n    \t\t\t\tadd dl,30H\r\n    \t\t\t\tmov ds:[bx],dl\r\n    \t\t\t\tadd bx,-1\r\n    \t\t\t\tloop s2\r\n    \t\t\r\n    \t\tmov si,0\r\n    \t\tret\t\t\r\n    \t\t\r\n      show_str:\r\n    \t  \r\n    \t  mov ch,0\r\n    \t  ;确认输入的显存区域\r\n    \t  mov ax,0B800H\r\n    \t  mov es,ax\r\n    \t  \r\n    \t  ;计算对应的行\r\n    \t  mov bl,0A0h\r\n    \t  mov al,dh\r\n    \t  add al,-1\r\n    \t  mov ah,0\r\n    \t  mul bl\r\n    \t  mov di,ax        ;用di存储开始行以及开始列\r\n    \t  \r\n    \t  ;计算对应的列\r\n    \t  mov al,dl\r\n    \t  mov bx,2\r\n    \t  mul bl\r\n    \t  add al,-2\r\n    \t  mov ah,0\r\n    \t  add di,ax\r\n    \t  \r\n    \t  ;将文字输入\r\n    \t  s:mov ax,cx\r\n    \t\tmov cl,ds:[si]\r\n    \t    mov ch,0\r\n    \t    jcxz ok\r\n    \t\tmov es:[di],cl\r\n    \t\tmov cx,ax\r\n    \t\tmov es:[di+1],cl\r\n    \t    inc si\r\n    \t\tadd di,2\r\n    \t\tjmp s\r\n    \r\n    \t\tok:ret\r\n    \r\n    code ends\r\n    end start\r\n\r\n这里对我输入的数据做了下改变\r\n测试结果如下:\r\n![](http://img.xuhaobo.site/59)',b'1','感觉汇编开始难起来了,写程序长起来就莫名有点慌.....还是高级语言好啊,感觉这几个代码写得很不好....先把字先码上吧哈哈哈，\r\n大概内容就是写三个函数接口,这三个接口也同时起到让后面的程序调用同时实现代码复用的作用'),(125,8,'2020-04-15 00:00:00','mybatis注解实现动态sql拼接','https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1586953045420&di=4d3663a7e9a654f43a24ab1727870a7b&imgtype=0&src=http%3A%2F%2Fimg2.imgtn.bdimg.com%2Fit%2Fu%3D2196685962%2C796489853%26fm%3D214%26gp%3D0.jpg',15,'*今天再次给自己的博客后台系统更新了一波,自己在修改以往博客格式的过程中发现了自己在修改博客后总会返回第一页,就又要重复很多操作才能修改到下一篇我想要的,于是就更改了一下博客修改页,顺遍给博客列表页引入了**根据发布(草稿)状态进行筛选**的功能,在重写dao层mybatis代码时由于自己之前的mapper方法均是以注解的方式开发(对xml总感觉反感:tw-1f436:)于是便引出了今天的问题*\r\n\r\n首先我们看一下我之前想要达到的目标效果:\r\n\r\n直接进入后台系统模块(不做筛选地进行查询):\r\n![](http://img.xuhaobo.site/61)\r\n\r\n显示已发表状态(也就是访客可以看到)\r\n![](http://img.xuhaobo.site/60)\r\n\r\n显示未发表状态(我的草稿)\r\n![](http://img.xuhaobo.site/62)\r\n\r\n**这里表述的只是博客列表的需求,至于基于某标签下的博客或者某搜索结果下的博客道理相近,这里不细说了。**\r\n\r\n按照需求有三种状态:\r\n1.无筛选\r\n2.已发布\r\n3.草稿\r\n\r\n所以我们必须要动态地去拼接sql语句\r\nmybatis本身提供了**<if test=\'\'></if>**标签,本身我只对xml进行动态sq\r\nl有所了解\r\n其实基于注解的解决方案也很简单,只需要将拼接的字符放在\r\n**<script></script>**标签中即可实现\r\n\r\n这里的实际mapper实现如下\r\n```java\r\n    @Select(\"<script>\" +\r\n            \"select * from article\" +\r\n            \"<if test=\'published!=null\'>\"+\r\n            \"where published=#{published} \" +\r\n            \"</if>\"+\r\n            \"order by id desc\" +\r\n            \"</script>\")           //在注解中使用published动态拼接\r\n    @Results({\r\n            @Result(property = \"id\",column = \"id\"),\r\n            @Result(property = \"tid\", column = \"tid\"),\r\n            @Result(property = \"tag\",column = \"tid\",one = @One(select = \"com.example.xhbblog.mapper.TagMapper.selectByPrimaryKey\")),\r\n            @Result(property = \"commentSize\",column = \"id\",one = @One(select = \"com.example.xhbblog.mapper.CommentMapper.countOfArticle\")),\r\n    }\r\n    )\r\n    List<Article> listAll(Boolean published);        //给后台用的\r\n\r\n\r\n    @Select(\"<script>\" +\r\n            \"select * from article where tid=#{tid}\" +\r\n            \"<when test=\'published!=null\'>\"+\r\n            \"and published=#{published}\"+\r\n            \"</when>\"+\r\n            \"order by id desc\" +\r\n            \"</script>\")\r\n    @Results({\r\n            @Result(property = \"id\",column = \"id\"),\r\n            @Result(property = \"tid\", column = \"tid\"),\r\n            @Result(property = \"tag\", column = \"tid\", one = @One(select = \"com.example.xhbblog.mapper.TagMapper.selectByPrimaryKey\")),\r\n            @Result(property = \"commentSize\", column = \"id\", one = @One(select = \"com.example.xhbblog.mapper.CommentMapper.countOfArticle\"))\r\n    })\r\n    List<Article> listByTid(Integer tid,Boolean published);       //用于后台\r\n\r\n\r\n    @Select(\"<script>\" +\r\n            \"select * from article where id IN(select id from article where content like #{string} or title like #{string})\" +\r\n            \"<when test=\'published!=null\'>\"+\r\n            \"and published=#{published}\"+\r\n            \"</when>\"+\r\n            \"order by id desc\"+\r\n            \"</script>\")\r\n    @Results({\r\n            @Result(property = \"id\",column = \"id\"),\r\n            @Result(property = \"tid\", column = \"tid\"),\r\n            @Result(property = \"tag\", column = \"tid\", one = @One(select = \"com.example.xhbblog.mapper.TagMapper.selectByPrimaryKey\")),\r\n            @Result(property = \"commentSize\", column = \"id\", one = @One(select = \"com.example.xhbblog.mapper.CommentMapper.countOfArticle\"))\r\n    })\r\n    List<Article> listArticleLike(String string,Boolean published);         //给后台用\r\n```',b'1','今天再次给自己的博客后台系统更新了一波,\r\n自己在修改以往博客格式的过程中发现了自己在修改博客后总会返回第一页,就又\r\n要重复很多操作才能修改到下一篇我想要的,于是就更改了一下博客修改页,顺遍给\r\n博客列表页引入了根据发布(草稿)状态进行筛选的功能,在重写dao层mybatis代\r\n码时由于自己之前的mapper方法均是以注解的方式开发(对xml总感觉反感)于是便引出了今天的问题'),(126,2,'2020-04-15 00:00:00','[leetcode]542. 01 矩阵','http://img.xuhaobo.site/63',7,'*一道非常常见的(写了感觉很多次)的BFS常见题,之前看还有DP的解法,打算以后再详细看看吧,大体思路就是对方格里每一个点进行广度优先搜索,并存储到一个新数组中*\r\n\r\n题目如下:\r\n![](http://img.xuhaobo.site/63)\r\n\r\n![](http://img.xuhaobo.site/64)\r\n\r\njava代码如下:\r\n```java\r\nclass Solution {\r\n    private Set<String> visited=new HashSet<>();\r\n\r\n    public boolean check(int x,int y,int[][]matrix)\r\n    {\r\n        return y>=0&&y<matrix.length&&x>=0&&x<matrix[y].length;\r\n    }\r\n\r\n    public int get(int x,int y,int [][]matrix)\r\n    {\r\n        if(matrix[y][x]==0)\r\n        {\r\n            return 0;\r\n        }else\r\n        {\r\n            int anw=0;\r\n            int[]ix=new int[]{0,0,1,-1};\r\n            int[]iy=new int[]{1,-1,0,0};\r\n            Queue<int[]>q=new LinkedList<>();\r\n            q.offer(new int[]{x,y});\r\n            visited.add(x+\",\"+y);\r\n            while(!q.isEmpty())\r\n            {\r\n                int length=q.size();\r\n                anw++;\r\n                for(int k=0;k<length;k++)\r\n                {\r\n                    int []arr=q.poll();\r\n                    visited.add(arr[0]+\",\"+arr[1]);\r\n                    for(int i=0;i<4;i++)\r\n                    {\r\n                    if(check(arr[0]+ix[i],arr[1]+iy[i],matrix)==true)\r\n                    {\r\n                        if(matrix[arr[1]+iy[i]][arr[0]+ix[i]]==0)\r\n                        {\r\n                            visited.clear();\r\n                            return anw;\r\n                        }else{\r\n                            q.offer(new int[]{arr[0]+ix[i],arr[1]+iy[i]});      //x,y进队列\r\n                        }\r\n                    }  \r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    public int[][] updateMatrix(int[][] matrix) {\r\n        int [][]anw=new int[matrix.length][matrix[0].length];\r\n        for(int i=0;i<matrix.length;i++)\r\n        {\r\n            for(int j=0;j<matrix[i].length;j++)\r\n            {\r\n                anw[i][j]=get(j,i,matrix);\r\n            }\r\n        }\r\n        return anw;\r\n    }\r\n}\r\n```',b'1','一道非常常见的(写了感觉很多次)的BFS常见题,之前看还有DP的解法,打算以后再\r\n详细看看吧,大体思路就是对方格里每一个点进行广度优先搜索,并存储到一个新数组中'),(127,2,'2020-04-16 00:00:00','[leetcode]56. 合并区间','http://img.xuhaobo.site/87',10,'*总感觉这个是在哪里做过的......具体在哪又忘记了,反正自己当时的代码是挺不好看的,大体思路就是先将数组排一下序,那么接下来是否合并数组就只需要先判定一下是否能合并,之后具体合并只需要改变较大的一侧的值*\r\n**\r\nps:感觉自己改补补java基础语法的课了,lambda排序真香~**\r\n\r\n具体题目如下:\r\n![](http://img.xuhaobo.site/87)\r\n\r\njava实现代码如下:\r\n```java\r\nclass Solution {\r\n    public int[][] merge(int[][] intervals) {\r\n        Arrays.sort(intervals, (v1, v2) -> v1[0] - v2[0]);    //通过lambda排序\r\n        int [][]anw=new int[intervals.length][2];\r\n        int cnt=0; //存储进anw的下标\r\n        int last=Integer.MIN_VALUE;\r\n        for(int []interval:intervals)\r\n        {\r\n            if(interval[0]>last)\r\n            {\r\n                anw[cnt]=interval;//不合并直接复制,返回数组的元素个数加1\r\n                last=anw[cnt++][1]; \r\n            }else{\r\n                anw[cnt-1][1]=Math.max(interval[1],anw[cnt-1][1]);     //两者取最大\r\n                last=anw[cnt-1][1];\r\n            }\r\n        }\r\n        return Arrays.copyOf(anw,cnt);\r\n    }\r\n}\r\n```',b'1','总感觉这个是在哪里做过的......具体在哪又忘记了,反正自己当时的代码是\r\n挺不好看的,大体思路就是先将数组排一下序,那么接下来是否合并数组就只需要\r\n先判定一下是否能合并,之后具体合并只需要改变较大的一侧的值'),(128,2,'2020-04-17 00:00:00','[leetcode]55.跳跃游戏','http://img.xuhaobo.site/66',20,'*一开始轻敌了,直接用DFS结果超时了,之后自己试图对DFS疯狂优化....然并卵最后一气之下换成贪心+递归了,看来做题还是要认真点,少些暴力遍历这样的东西,\r\n多些想法少些套路:tw-1f436::tw-1f436:*:tw-1f436:\r\n\r\n本题leetcode链接:\r\nhttps://leetcode-cn.com/problems/jump-game/\r\n\r\n具体题目描述如下:\r\n![](http://img.xuhaobo.site/66)\r\n**贪心思想概述:局部最优之和==整体最优**\r\n我们的目的是判断自己能否到大**最后一个位置**,且起始点是第一个下标,所以\r\n一定程度上讲,我们只需要将下标**大于或等于最后一个位置即可**\r\n\r\n首先从第零个下标开始搜索,**如果直接下标+跳跃距离可以大于最后的位置,那么\r\n一定可以跳到最后的位置**,此时我们可以直接返回true\r\n\r\n**之后是要重点理解的部分**：\r\n如果没有大于最后的位置,那么我们需要权衡我们**下一步要跳到的点**是哪里\r\n我们需要权衡两点,首先我们要找到能够让我们肯定的**局部能跳范围最大的点**\r\n这个范围可以理解成**下一步的位置能跳的范围**,这个范围可以理解成与终点越\r\n近越好,**与起点距离越大越好**\r\n**\r\n那么下一步能够与起点的距离==下一步位置+下一步跳的范围\r\n所以遍历再取最大值\r\n最终跳到这个位置继续递归搜索....**\r\n\r\njava实现代码如下:\r\n```java\r\nclass Solution {\r\n    public boolean jumpto(int []nums,int index)\r\n    {\r\n        if(index==-1||nums[index]==0)\r\n        {\r\n            return false;\r\n        }\r\n        int maxIdx=-1;      //最合适的那个下标\r\n        int max=Integer.MIN_VALUE;\r\n        for(int i=nums[index];i>=1;i--)\r\n        {\r\n            if(index+i>=nums.length-1)\r\n            {\r\n                return true;\r\n            }else{\r\n                if(nums[index+i]!=0)\r\n                {\r\n                    maxIdx=nums[index+i]+i>max?index+i:maxIdx;\r\n                    max=nums[index+i]+i>max?nums[index+i]+i:max;\r\n                }\r\n            }\r\n        }\r\n        return jumpto(nums,maxIdx);\r\n    }\r\n    public boolean canJump(int[] nums) {\r\n        if(nums.length<=1)\r\n        {\r\n            return true;\r\n        }else\r\n        {\r\n            return jumpto(nums,0);\r\n        }\r\n    }\r\n}\r\n```',b'1','一开始轻敌了,直接用DFS结果超时了,之后自己试图对DFS疯狂优化....然并卵\r\n最后一气之下换成贪心+递归了,看来做题还是要认真点,少些暴力遍历这样的东西,\r\n多些想法少些套路(逃'),(129,2,'2020-04-18 00:00:00','[leetcode]11. 盛最多水的容器','http://img.xuhaobo.site/67',83,'*深夜刷题啊哈哈哈,赶着每日一题刷新直接十分钟刷出来了,直接ac真是畅爽~,这题算是之前刷过的了,六个月前还是在用c++的时候刷过一遍一开始试图想起之前的思路想不起来了,看了眼提示说双指针,自己直接想出来了,整体思路还是简单的*\r\n\r\n**题目如下:**\r\n![](http://img.xuhaobo.site/67)\r\n\r\n**大体思路**\r\n我们盛水的思路就是求矩形面积最大,矩形面积==长*宽\r\n首先设立两个指针(一个指向0,一个指向终点),(此时理论上宽最大)\r\n随后我们要排除长影响面积最大值的情况,那么我们可以通过更新较小的指针来\r\n逐步实现,大体讲一下循环遍历过程:\r\n1.求较小的值所对应指针\r\n2.根据较小的高求面积刷新目前最大值\r\n3.指针变动并判断是否遍历完毕\r\n\r\njava实现如下:\r\n```java\r\nclass Solution {\r\n    public int maxArea(int[] height) {\r\n        int max=0;\r\n        int begin=0;\r\n        int end=height.length-1;\r\n        while(begin<end)\r\n        {\r\n            int square=0;\r\n            if(height[end]<height[begin])\r\n            {\r\n                square=(end-begin)*height[end];\r\n                end--;\r\n            }else\r\n            {\r\n                square=(end-begin)*height[begin];\r\n                begin++;\r\n            }\r\n            max=max>square?max:square;\r\n        }\r\n        return max;\r\n    }\r\n}\r\n```\r\n\r\nc++实现如下:(6个月前)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int maxArea(vector<int>& height) {\r\n        int i=0,j=height.size()-1;\r\n        int max=0;\r\n        while(i<j)\r\n        {\r\n            int k=height[i]>height[j]?height[j]:height[i];\r\n            int s=k*(j-i);\r\n            if(s>max)\r\n            {\r\n                max=s;\r\n            }\r\n            if(k==height[j])\r\n            {\r\n                j--;\r\n            }\r\n            else if(k==height[i])\r\n            {\r\n                i++;\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n};\r\n```\r\n\r\nc语言:\r\n```c\r\nint maxArea(int* height, int heightSize){\r\n    int begin=0;\r\n    int end=heightSize-1;\r\n    int max=0;\r\n    while(begin<end)\r\n    {\r\n        int squ=0;\r\n        if(height[begin]>height[end])\r\n        {\r\n            squ=height[end]*(end-begin);\r\n            end--;\r\n        }else\r\n        {\r\n            squ=height[begin]*(end-begin);\r\n            begin++;\r\n        }\r\n        max=max>squ?max:squ;\r\n    }\r\n    return max;\r\n}\r\n```',b'1','深夜刷题啊哈哈哈,赶着每日一题刷新直接十分钟刷出来了,直接ac真是畅爽~,\r\n这题算是之前刷过的了,六个月前还是在用c++的时候刷过一遍\r\n一开始试图想起之前的思路想不起来了,看了眼提示说双指针,自己直接想出来了,\r\n整体思路还是简单的(又一道我既可以提供java又可以提供c++实现的题了哈哈哈哈'),(130,20,'2020-04-18 00:00:00','王爽<<汇编语言>>第十一章&&十二章总结','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',40,'*第十一章主要讲述了几个条件寄存器cf,pf,zf,sf,of,df的作用以及使用原理,以及相关的cmp以及条件转移指令外加加减法进位指令;这里具体用法逻辑就不细说了，第十二章大概内容讲述了程序的内中断过程,书中逐渐开始介绍中断的概念。*\r\n\r\n这里首先我们要明确一下“**中断**”的定义:这里引用一下csapp里的定义**中断是异步发生的,是来自处理器外部的I/O设备的信号的结果**。\r\n\r\n中断的过程既有软件,又有硬件的参与,其过程如下图所示:\r\n![](http://img.xuhaobo.site/68)\r\n\r\n可以看出,中断的过程是由硬件发去信号(这里就是异常号,比如我们实验中除以0\r\n的异常本质上就是\"零号异常\"),随后控制传递给中断处理程序(位于中断向量表),\r\n\r\n\r\n中断向量表位于内存中一块固定的地址里,存储着中断处理程序的入口地址的cs,ip值,一个表项存放一个中断向量,也就是一个中断处理程序的入口地址,对于8086cpu,这个入口地址包括段地址和偏移地址,以一个表项占两个字,**高地址字存放短地址,低地址字存放偏移地址。**\r\n\r\n我们要做的就是中断过程中中断处理程序这个层面的事情.\r\n\r\n1.首先编写中断处理程序\r\n2.将中断处理程序存入指定的,不会在别的程序运行过程中被覆盖的位置(安装)\r\n3.设置中断向量(将我们中断处理程序所存放的那段入口地址存入中断向量表中),这个过程我个人比较愿意理解为注册,将我们的程序注册进去\r\n\r\n实验代码如下:\r\n    \r\n\tassume cs:code\r\n    code segment\r\n      start:\r\n      mov ax,cs\r\n      mov ds,ax\r\n      mov si,offset do0       ;将所传送的代码段长度设为下标\r\n      \r\n      mov ax,00\r\n      mov es,ax\r\n      mov di,0200h                ;要写入安装的内存位置\r\n      \r\n      mov cx,offset do0_end-offset do0         ;这里偏置的也是字节？\r\n      rep movsb                    ;按字节传送\r\n      \r\n      ;使得该入口地址成为0号中断的中断处理程序\r\n      \r\n      \r\n      mov ax,0\r\n      mov es,ax\r\n      mov di,0\r\n      mov word ptr es:[0*4],200h           ;所传入的中断向量表表项,第一个字为ip,第二个字为Cs\r\n      mov word ptr es:[0*4+2],0\r\n      \r\n      ;测试中断程序\r\n      mov ax,10\r\n      mov bx,0\r\n      div bx\r\n      \r\n      mov ax,4c00h\r\n      int 21h\r\n      \r\n      do0:jmp short show_do0\r\n    \t  db \"divideserror!\"\r\n    \t  ;将字符串写入显存进行表示\r\n      show_do0:mov ax,cs\r\n    \t\t   mov ds,ax\r\n    \t\t   mov si,202h\r\n    \t\t   \r\n    \t\t   mov ax,0b800h\r\n    \t\t   mov es,ax\r\n    \t\t   mov di,12*160+36*2\r\n    \t\t   \r\n    \t\t   mov cx,13\r\n    \t\t   mov bx,0\r\n    \t\t   \r\n    \t\t   s:\r\n    \t\t\tmov al,ds:[si]\r\n    \t\t\tmov es:[di],al\r\n    \t\t\tmov byte ptr es:[di+1],01000010b\r\n    \t\t\tadd di,2\r\n    \t\t\tinc si\r\n    \t\t\tloop s\r\n    \t\t   rep movsw         ;整段传送到显存中\r\n    \t\t   \r\n    \t\t   mov ax,4c00h\r\n    \t\t   int 21h\r\n    \t\t   \r\n      do0_end:nop                    ;用于计算代码段字节数的占位段\r\n    \r\n    code ends\r\n    end start',b'1','第十一章主要讲述了几个条件寄存器cf,pf,zf,sf,of,df的作用以及使用原理以及相关的cmp以及条件转移指令外加加减法进位指令;这里具体用法逻辑就不细说了\r\n第十二章大概内容讲述了程序的内中断过程,这里首先我们要明确一下“中断”的定义:这里引用一下csapp里的定义'),(131,20,'2020-04-20 00:00:00','王爽<<汇编语言>>十三&十四&十五章实验总结','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',131,'*第十三章主要讲了如何使用int指令引发内中断,个人认为难点是用过int实现loop循环的过程,第十四章主要讲了如何通过控制端口实现输入/输出操作,以及向端口的IO操作的原理,第十五章个人认为算是十三,十四的总和,需要我们编写并安装对某端口输入输,出\r\n--》发动外中断的中断例程*\r\n## 第十三章(int指令)实验:\r\n(1)实现较为简单,这里给一下代码实现:\r\n    \r\n\tassume cs:code\r\n    \r\n    code segment\r\n    \r\n    start:mov ax,cs\r\n    \t  mov ds,ax\r\n    \t  mov si,offset show_str\r\n    \t  mov ax,0\r\n    \t  mov es,ax\r\n    \t  mov di,200h\r\n    \t  mov cx,offset show_end-offset show_str\r\n    \t  rep movsb\r\n    \t  \r\n    \t  mov word ptr es:[7ch*4],200h\r\n    \t  mov word ptr es:[7ch*4+2],0\r\n    \t\t\r\n    \t  mov ax,4c00h\r\n    \t  int 21h\r\n    \r\n    \r\n    show_str:\r\n    \t  mov bl,cl\r\n    \t  input:\r\n    \t\t \r\n    \t\tset:;设置光标\r\n    \t\t\tmov ah,2\r\n    \t\t\tmov bh,0;这里写一下是为了传参直观一?\r\n    \t\t\tmov dl,dl\r\n    \t\t\tmov dh,dh\r\n    \t\t\tint 10h\r\n    \t\t\r\n    \t\t\r\n    \t\t  ;输出光?\r\n    \t\t\tmov ch,0\r\n    \t\t\tmov cl,ds:[si]\r\n    \t\t\tjcxz ok;判定字符结束\r\n    \t\r\n    \t\t\t;在光标位置显示字符\r\n    \t\t\tmov ah,9\r\n    \t\t\tmov al,cl\r\n    \t\t\t\r\n    \t\t\tmov bh,0\r\n    \t\t\tmov cx,1\r\n    \t\t\tint 10h\r\n    \t\t\t\r\n    \t\t\tinc dl\r\n    \t\t\tinc si\r\n    \t\t\tjmp input\r\n    \r\n    \t\tok: iret\r\n    \t\t\r\n    show_end:nop\r\n    \r\n    code ends\r\n    end start\r\n\r\n(2)原理:我们可以把通过int发动中断处理程序类似于调用子程序一样理解,之前我们已经将int 7ch的下一句ip与s代码段首地址的ip值的差(**注意此处为负值**),用bx存储了起来,我们只需要在中断例程中修改最终iret指令pop的ip值即可这里一定要明确清楚的地方是iret的内部实现:刷新ip和cs值\r\n\r\n代码如下:\r\n    ;实现loop的中断处理程序安装例程\r\n    assume cs:code\r\n    \r\n    code segment\r\n    \r\n    start:mov ax,cs\r\n    \t  mov ds,ax\r\n    \t  mov si,offset lop_str\r\n    \t  mov ax,0\r\n    \t  mov es,ax\r\n    \t  mov di,200h\r\n    \t  mov cx,offset lop_end-offset lop_str\r\n    \t  rep movsb\r\n    \t  \r\n    \t  mov word ptr es:[7ch*4],200h\r\n    \t  mov word ptr es:[7ch*4+2],0\r\n    \t\t\r\n    \t  mov ax,4c00h\r\n    \t  int 21h\r\n    \r\n    \r\n    lop_str:\r\n    \t\tpush bp\r\n    \t\tmov bp,sp\r\n    \t\tdec cx\r\n    \t\tjcxz ok\r\n    \t\tadd [bp+2],bx\r\n    \t\t\r\n    \t\tok:pop bp\r\n    \t\t\tiret\r\n    \t\t\t\r\n    \t\t\r\n    lop_end:nop\r\n    \r\n    code ends\r\n    end start\r\n\r\n(3)很简单,就是把内存寄存器什么的关系梳理清楚就好了\r\n代码如下:\r\n    \r\n\tassume cs:code\r\n    code segment\r\n    \r\n    s1:db \'good better,best,\',\'$\'\r\n    s2:db \'never give up,\',\'$\'\r\n    s3:db \'fuck up,\',\'$\'\r\n    s4:db \'holly shit,\',\'$\'\r\n    s:dw offset s1,offset s2,offset s3,offset s4\r\n    row:db 2,4,6,8\r\n    \r\n    start:mov ax,cs\r\n    \t  mov ds,ax\r\n    \t  mov bx,offset s\r\n    \t  mov si,offset row\r\n    \t  mov cx,4\r\n    \t  \r\n    \tok:mov bh,0\r\n    \t   mov dh,ds:[si]\r\n    \t   mov dl,0\r\n    \t   mov ah,2\r\n    \t   int 10h\r\n    \t   \r\n    \t   mov dx,ds:[bx]\r\n    \t   mov ah,9\r\n    \t   int 21h\r\n    \t   add bx,2\r\n    \t   inc si\r\n    \t   loop ok\r\n    \t   \r\n    \t   mov ax,4c00h\r\n    \t   int 21h\r\n    \t   \r\n    code ends\r\n    end start\t   \r\n\r\n## 第十四章(端口)实验:\r\n**实验十四感觉它中间那个分隔符当时感觉有点困难\r\n后来想到可以先改写一段初始化的内存里去\r\n再把这段内存写到显存里就好了**\r\n    \r\n    assume cs:code\r\n    data segment\r\n    db 9,8,7,4,2,0\r\n    db \"yy/mm/dd hh:mm:ss\"\r\n    data ends\r\n    \r\n    code segment\r\n    start:\r\n    \tmov ax,data\r\n    \tmov ds,ax\r\n    \tmov cx,6\r\n    \tmov bx,0\r\n    \tmov dx,0\r\n    \r\n    s:\tmov al,ds:[bx]\r\n    \r\n    ;取时间数据\r\n    \tout 70h,al\r\n    \tin al,71h\r\n    \tmov ah,al\r\n    \tmov dl,cl\r\n    \tmov cl,4\r\n    \tshr al,cl\r\n    \tmov cl,dl\r\n    \tand ah,00001111B\r\n    \tadd ah,30h\r\n    \tadd al,30h\r\n    ;写入数据区域\r\n    \r\n    \tmov bp,bx\r\n    \tshl bp,1\r\n    \tadd bp,bx\r\n    \tmov ds:[bp+6],ax\r\n    \t\r\n    \t\r\n    \tadd bx,1            ;刷新bx\r\n    \tloop s\r\n    \r\n    \r\n    ;写入显存中\r\n    mov ax,4c00h\r\n    int 21h\r\n    code ends\r\n    end start\t \r\n\r\n运行结果如下:\r\n![](http://img.xuhaobo.site/70)\r\n\r\n## 第十五章(外中断)实验:\r\n外中断可以简单理解为外部设备发出的中断信号引发的cpu中断\r\n可分为**可屏蔽**中断和不可屏蔽中断(通过IF设置不响应状态时可屏蔽中断会被屏蔽，)\r\n**我们接触到的大部分外设引发的中断都是可屏蔽中断,不可屏蔽中断是系统中有必须处理的紧急情况时发出的中断信号**\r\n代码如下:\r\n    \r\n\tassume cs:code,ss:stack\r\n    \r\n    stack segment\r\n      db 128 dup(0)\r\n    stack ends\r\n    \r\n    code segment\r\n    \r\n    start:mov ax,stack\r\n    \t  mov ss,ax\r\n    \t  mov sp,128\r\n    \t  \r\n    \t  ;安装中断处理程序\r\n    \t  push cs\r\n    \t  pop ds\r\n    \t  mov si,offset fill_A\t\r\n    \t\t\r\n    \t  mov ax,0\r\n    \t  push ax\r\n    \t  pop es\r\n    \t  mov di,204h\r\n    \t  \r\n    \t  mov cx,offset fill_A_end-offset fill_A\r\n    \t  cld\r\n    \t  rep movsb\r\n    \t  \r\n    \t  ;保存原中断处理程序int 9h\r\n    \t  push es:[9*4]\r\n    \t  pop es:[200h]\r\n    \t  push es:[9*4+2]\r\n    \t  pop es:[202h]\r\n    \t  \r\n    \t  cli\r\n    \t  mov word ptr es:[9*4],204h\r\n    \t  mov word ptr es:[9*4+2],0\r\n    \t  sti\r\n    \t  \r\n    \t  mov ax,4c00h\r\n    \t  int 21h\r\n    \t  \r\n    fill_A:push ax\r\n    \t   push bx\r\n    \t   push cx\r\n    \t   push es\r\n    \t   \r\n    \t   in al,60h\r\n    \t   normal:pushf\r\n    \t\t\t  pushf\r\n    \t\t\t  pop bx\r\n    \t\t\t  and bh,11111100b\r\n    \t\t\t  push bx\r\n    \t\t\t  popf\r\n    \t\t\t  call dword ptr cs:[200h]\r\n    \t\t\t  \r\n    \t   cmp al,9eh\r\n    \t   jne ok\r\n    \t   \r\n    \t   ;循环将A输入到屏幕上\r\n    \t\t\t  \r\n    \t\tmov ax,0b800h\r\n    \t\tmov es,ax\r\n    \t\tmov cx,2000\r\n    \t\tmov bx,0\r\n    \t   s:\r\n    \t     mov byte ptr es:[bx],\'A\'\r\n    \t\t add bx,2\r\n    \t\t loop s\t  \r\n    \t\t\r\n    \t\t\t\r\n    \t   ok:\tpop es\t\r\n    \t\t\tpop cx\r\n    \t\t\tpop bx\r\n    \t\t\tpop ax\r\n    \t\tiret\r\n    \t\t\r\n    fill_A_end:nop\r\n    \t\t   \r\n    \r\n    code ends\r\n    end start',b'1','第十三章主要讲了如何使用int指令引发内中断,个人认为难点是用过int实现loop\r\n循环的过程\r\n第十四章主要讲了如何通过控制端口实现输入/输出操作,以及向端口的IO操作的原理\r\n第十五章个人认为算是十三,十四的总和,需要我们编写并安装对某端口输入输出\r\n--》发动外中断的中断例程'),(132,20,'2020-04-21 00:00:00','王爽<<汇编语言>>十六章实验总结','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',48,'*第十六章主要讲了直接定址表的具体实现,具体学习的内容就是通过标号来寻址,并依照这种位置关系进行较为复杂的寻址,个人认为难点主要在于进行复杂寻址的这种编程,这种思路貌似与之前看csapp里switch的机器级实现很像*\r\n\r\n**实验分析:大概内容就是自己实现一个根据参数动态选择功能字程序的中断例程,这里要实现的功能之前在书中已经给了很好的实现,我们主要讲述整个中断过程的逻辑,也算是对于整个中断过程理解的一次复习**\r\n\r\n首先我们要明确在中断处理的过程中的cs,ip值,这里的cs,ip就是之前我们在安\r\n装过程中我们将中断例程代码段放入的地址,按本题分析,cs为零,\r\n**所以当我们在通过参数寻找在table所对应的子功能程序地址,以及根据table所提供的偏移地址寻找代码段时,要记得加上本身程序的偏移量200h**\r\n\r\n需要明确的一点:\r\n我们首先通过参数找到在table下的**存储偏移量的地址**\r\n这里的偏移量,是我们通过table找到的是**函数对应的地址偏移量**\r\n进行了两次寻址的过程\r\n\r\n\r\n自己写的图示如下:\r\n![](http://img.xuhaobo.site/73)\r\n\r\n整体代码如下:\r\n    \r\n\tassume cs:code,ss:stack\r\n    \r\n    stack segment\r\n      db 128 dup(0)\r\n    stack ends\r\n    \r\n    code segment\r\n    \r\n    start:mov ax,stack\r\n    \t  mov ss,ax\r\n    \t  mov ax,cs\r\n    \t  mov ds,ax\r\n    \t  mov si,offset function\r\n    \t  mov ax,0\r\n    \t  mov es,ax\r\n    \t  mov di,200h\r\n    \t  mov cx,offset function_end-offset function\r\n    \t  rep movsb\r\n    \t  \r\n    \t  mov word ptr es:[7ch*4],200h\r\n    \t  mov word ptr es:[7ch*4+2],0\r\n    \t\t\r\n    \t  mov al,1\r\n    \t  mov ah,2\r\n    \t  int 7ch\r\n    \t \r\n    \t  mov ax,4c00h\r\n    \t  int 21h\r\n    \t  \r\n    function:\r\n    \tjmp short begin\r\n    \t;这里table存的是各段函数相对于cs(0)的偏移量(ip)\r\n    \ttable dw offset sub1-offset function+0200h,offset sub2-offset function+0200h,offset sub3-offset function+0200h,offset sub4-offset function+0200h            ;table表记下各功能函数的偏置值\r\n    \t\r\n    \tbegin:push bx\r\n    \t\t  push es\r\n    \t\t  mov bx,0\r\n    \t\t  mov bl,ah\r\n    \t\t  add bl,bl                    ;此时的bx代表的是我要去用第几个函数处理\r\n    \t\t  add bx,offset table-offset function        ;table相对于中断处理程序(function)的偏移量  \r\n    \t\t  call word ptr cs:[bx+200h]                     ;+200h是先cs找到中断处理程序的位置\r\n    \t\t  pop es\r\n    \t\t  pop bx\r\n    \t\t  iret\r\n    \t\r\n    \t\r\n    \tsub1:push bx\r\n    \t\t push cx\r\n    \t\t push es\r\n    \t\t mov ax,0b800h\r\n    \t\t mov es,ax\r\n    \t\t mov bx,0\r\n    \t\t mov cx,2000\r\n    \t\t \r\n    \tsub1_loop:\r\n    \t\t\t  mov byte ptr es:[bx],\' \'\r\n    \t\t\t  add bx,2\r\n    \t\t\t  loop sub1_loop\r\n    \t\t\t  \r\n    \tpop es\r\n    \tpop cx\r\n    \tpop bx\r\n    \tret\r\n    \t\r\n    \tsub2:push bx\r\n    \t\t push cx\r\n    \t\t push es\r\n    \t\t mov ah,0\r\n    \t\t mov al,al           ;设置背景色的参\r\n    \t\t mov di,ax\r\n    \t\t mov ax,0b800h\r\n    \t\t mov es,ax\r\n    \t\t mov ax,di\r\n    \t\t mov bx,1           ;背景色在后三位\r\n    \t\t mov cx,2000\r\n    \t\r\n    \tsub2_loop:and byte ptr es:[bx],11111000b\r\n    \t\t\t  or byte ptr es:[bx],al\r\n    \t\t\t  add bx,2\r\n    \t\t\t  loop sub2_loop\r\n    \tpop es\r\n    \tpop cx\r\n    \tpop bx\r\n    \tret\r\n    \t\t\r\n    \tsub3:push bx\r\n    \t\t push cx\r\n    \t\t push es\r\n    \t\t mov ah,0\r\n    \t\t mov al,al           ;设置背景色的参数\r\n    \t\t mov di,ax\r\n    \t\t mov ax,0b800h\r\n    \t\t mov es,ax\r\n    \t\t mov ax,di\r\n    \t\t mov bx,1           ;背景色在后三位\r\n    \t\t mov cx,2000\r\n    \t\t shl al,1\r\n    \t\t shl al,1\r\n    \t\t shl al,1\r\n    \t\t shl al,1\r\n    \t\r\n    \tsub3_loop:and byte ptr es:[bx],11000111b\r\n    \t\t\t  or byte ptr es:[bx],al\r\n    \t\t\t  add bx,2\r\n    \t\t\t  loop sub3_loop\r\n    \tpop es\r\n    \tpop cx\r\n    \tpop bx\r\n    \tret\t\r\n    \t\r\n    \t;先让前几行移位\r\n    \tsub4:push bx\r\n    \t\t push cx\r\n    \t\t push es\r\n    \t\t push si\r\n    \t\t push ds\r\n    \t\t \r\n    \r\n    \t\t mov ax,0b800h\r\n    \t\t mov es,ax\r\n    \t\t mov ds,ax\r\n    \t\t mov di,0\r\n    \t\t mov si,160\r\n    \t\t cld\r\n    \t\t mov cx,24\r\n    \t\t s:push cx\r\n    \t\t   mov cx,160\r\n    \t\t   rep movsb\r\n    \t\t   pop cx\r\n    \t\t   loop s\r\n    \t\t   \r\n    \t\tmov cx,80\r\n    \t\tmov si,0\r\n    \tc_e:\r\n    \t\tmov byte ptr es:[160*24+si],\' \'\r\n    \t\tadd si,2\r\n    \t\tloop c_e\r\n    \t\t\r\n    \tpop ds\r\n    \tpop si\r\n    \tpop es\r\n    \tpop cx\r\n    \tpop bx\r\n    \tret\r\n    \t\r\n    function_end:nop\r\n    \t\t   \r\n    \r\n    code ends\r\n    end start',b'1','第十六章主要讲了直接定址表的具体实现,具体学习的内容就是通过标号来寻址,并依照这种位置关系进行较为复杂的寻址,个人认为难点主要在于进行复杂寻址的这种编程,这种思路貌似与之前看cs:app里switch的机器级实现很像'),(133,2,'2020-04-21 00:00:00','[leetcode]1248. 统计「优美子数组」','http://img.xuhaobo.site/74',105,'*今天这题乍一看像是有难度的,看了\"双指针\"二字之后我就开始往下标的方向去想,没想到自己推出来了:tw-1f436: :tw-1f436:\r\n*\r\n题目如下:\r\n![](http://img.xuhaobo.site/74)\r\n**我们可以数组以奇数的位置分段,以循环遍历的下标为开始,给奇数计数,通过分段对两侧进行下标的运算进而统计数量。**\r\n自己的大概算法图解如下:\r\n![个人解法如下](http://img.xuhaobo.site/76 \"解法图解\")\r\n向左伸展和向右伸展都可以理解,朝两侧伸展可以理解为两侧相乘\r\n要注意的点就是边界量(第一个指针是第一个奇数,以及第二个指针是最后一个奇数的情况)\r\n**距离记得减一**\r\n\r\n```java\r\nclass Solution {\r\n    public int numberOfSubarrays(int[] nums, int k) {\r\n        List<Integer> odds=new ArrayList<>();\r\n        int sum=0;         //优美子数组的个数\r\n        for(int i=0;i<nums.length;i++)\r\n        {\r\n            if(nums[i]%2!=0)                              //是奇数就记位置\r\n            {\r\n                odds.add(i);\r\n            }\r\n        }\r\n        if(k==0)                //奇数不够,不存在\r\n        {\r\n            return 0;\r\n        }else\r\n        {\r\n            int step=k-1;       //步长值\r\n            int size=odds.size();      //未扫描时的总个数\r\n            for(int i=0;i<odds.size();i++)\r\n            {\r\n                if(size<k)\r\n                {\r\n                    break;              //奇数的数量不足时退出\r\n                }else{\r\n                    sum+=1;     //本身\r\n                    int last=(i==0)?-1:odds.get(i-1);\r\n                    int next=size>k?odds.get(i+k):nums.length;\r\n                    sum+=odds.get(i)-last-1;\r\n                    sum+=next-odds.get(i+k-1)-1;\r\n                    sum+=(odds.get(i)-last-1)*(next-odds.get(i+k-1)-1);\r\n                }\r\n                size--;\r\n            }\r\n        }\r\n        return sum;\r\n    }\r\n}\r\n```',b'1','今天这题乍一看像是有难度的,看了\"双指针\"二字之后我就开始往下标的方向去想,没想到自己推出来了,看来以后遇到双指针的题就多往数组下标去想,大概率是对的方向'),(134,2,'2020-04-22 00:00:00','[leetcode]199. 二叉树的右视图','http://img.xuhaobo.site/77',1,'*这算是四月最简单的题么,比好想的做法就是二叉树BFS(算是学BFS时的标准应用了),取每一层最后一个的值,比起前面的题要用visited剪枝还要更简单一点~~~*\r\n\r\n题目如下:\r\n![](http://img.xuhaobo.site/77)\r\n**我们要确定他是最右边的,最好的方式就是二叉树的BFS(说法就和二叉树的层序遍历是一回事)**\r\nJAVA代码如下:\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode(int x) { val = x; }\r\n * }\r\n */\r\nclass Solution {\r\n    public List<Integer> rightSideView(TreeNode root) {\r\n        List<Integer>anw=new ArrayList<>();\r\n        if(root==null)\r\n        {\r\n            return anw;\r\n        }\r\n        Queue<TreeNode>q=new LinkedList<>();\r\n        q.offer(root);\r\n        while(!q.isEmpty())\r\n        {\r\n            int length=q.size();\r\n            for(int i=0;i<length;i++)\r\n            {\r\n                TreeNode t=q.poll();\r\n                if(i==length-1)  //最后一个结点\r\n                {\r\n                    anw.add(t.val);\r\n                }\r\n                if(t.left!=null)\r\n                {\r\n                    q.offer(t.left);\r\n                }\r\n                if(t.right!=null)\r\n                {\r\n                    q.offer(t.right);\r\n                }\r\n            }\r\n        }\r\n        return anw;            \r\n    }\r\n}\r\n```\r\n\r\nc++代码如下:\r\n```cpp\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    vector<int> rightSideView(TreeNode* root) {\r\n        vector<int>anw;\r\n        if(!root)\r\n        {\r\n            return anw;\r\n        }\r\n        queue<TreeNode*>Q;\r\n        Q.push(root);\r\n        while(Q.size())\r\n        {\r\n            int length=Q.size();\r\n            for(int i=0;i<length;i++)\r\n            {\r\n                TreeNode* T=Q.front();\r\n                Q.pop();\r\n                if(i==length-1)\r\n                {\r\n                    anw.push_back(T->val);\r\n                    printf(\"%d \",T->val);\r\n                }\r\n                if(T->left)\r\n                {\r\n                    Q.push(T->left);\r\n                }\r\n                if(T->right)\r\n                {\r\n                    Q.push(T->right);\r\n                }\r\n            }\r\n        }\r\n        return anw;\r\n    }\r\n};\r\n```',b'1','这算是四月最简单的题么,比好想的做法就是二叉树BFS(算是学BFS时的标准应\r\n用了),取每一层最后一个的值,比起前面的题要用visited剪枝还要更简单一点~~~'),(135,20,'2020-04-22 00:00:00','王爽<<汇编语言>>终章---十七章实验总结','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2317725689,390131353&fm=26&gp=0.jpg',83,'*终于算是把整本书的知识部分学完了....感觉学过之后觉得汇编还是挺值得一学的,它能够一定程度上让人有实际操控底层内存的体验,一定程度上也算是\"打开计算机的黑盒子\"中的一环吧*\r\n\r\n书中的算法如下:\r\n![](http://img.xuhaobo.site/78)\r\n\r\n**最后一个实验比较简单,主要涉及的还是根据它所给的公式进行计算,最终再调用中断处理程序,传入读写磁盘所需的参数,十七章也主要讲述了将一个功能化成几个小功能小程序段的思想,我想这应该算是“面向过程编程”非常好的案例了吧**\r\n\r\n汇编代码如下:\r\n\r\n    assume cs:code,ss:stack\r\n    \r\n    stack segment\r\n      db 128 dup(0)\r\n    stack ends\r\n    \r\n    code segment\r\n    \r\n    start:\r\n    \t  mov ax,stack\r\n    \t  mov ss,ax\r\n    \t  mov sp,128\r\n    \t  mov ax,0b800h\r\n    \t  mov es,ax\r\n    \t  mov bx,0\r\n    \t  \r\n    \t  mov ah,1      ;功能号为1\r\n    \t  mov al,2      ;扇区数为2\r\n    \t  mov dx,1200\r\n    \t  call main_func\r\n    \t  \r\n    \t  mov ax,4c00h\r\n    \t  int 21h\r\n    \r\n    ;取商\r\n    fun_int:mov ax,ax\r\n    \t\tmov dx,0\r\n    \t\tret\r\n    \r\n    ;取余\r\n    fun_rem:mov ax,dx\r\n    \t\tmov dx,0\r\n    \t\tret\r\n    \r\n    ;求面号\r\n    face:push bx\r\n         mov ax,dx\r\n    \t mov bx,1440\r\n    \t mov dx,0\r\n    \t div bx\r\n    \t call fun_int\r\n    \t pop bx\r\n    \t ret\r\n    \r\n    ;求磁道号\r\n    track:\r\n          push bx\r\n    \t  mov ax,dx\r\n    \t  mov bx,1440\r\n    \t  mov dx,0\r\n    \t  div bx\r\n    \t  call fun_rem\r\n    \t  mov bx,18\r\n    \t  mov dx,0\r\n    \t  div bx\r\n    \t  call fun_int\r\n    \t  pop bx\r\n    \t  ret\r\n    \r\n    ;求扇区号\r\n    sector:push bx\r\n    \t   mov ax,dx\r\n    \t   mov bx,1440\r\n    \t   mov dx,0\r\n    \t   div bx\r\n    \t   call fun_rem\r\n    \t   mov bx,18\r\n    \t   mov dx,0\r\n    \t   div bx\r\n    \t   call fun_rem\r\n    \t   inc ax\r\n    \t   pop bx\r\n    \t   ret\r\n    ;主功能\t\t   \r\n    main_func:\r\n    \t\t push ax\r\n    \t\t push dx\r\n    \t\t push bx\r\n    \t\t push es\r\n    \t\t push si\r\n    \t\t \r\n    \t\t push ax\r\n    \t\t \r\n    \t\t mov cx,0\r\n    \t\t \r\n    \t\t push dx\r\n    \t\t call track\r\n    \t\t mov ch,al\r\n             pop dx\r\n    \r\n    \t\t push dx\r\n    \t\t call sector\r\n    \t\t mov cl,al\r\n    \t\t pop dx\r\n    \r\n    \r\n    \t\t call face\r\n    \t\t mov dh,al\t\r\n    \t\t mov dl,0         ;我们这里默认使用软驱A\r\n    \t\t \r\n    \r\n    \t\t \r\n    \t\t \r\n    \t\t pop ax\r\n    \t\t int 13h\r\n    \t\t \r\n    \t\t pop si\r\n    \t\t pop es\r\n    \t\t pop bx\r\n    \t\t pop dx\r\n    \t\t pop ax\r\n    \t\t ret\r\n    code ends\r\n    end start\r\n\r\n检验结果如下:\r\n![](http://img.xuhaobo.site/79),与传入的逻辑地址:1200所建立的对应相同',b'1','终于算是把整本书的知识部分学完了....感觉学过之后觉得汇编还是挺值得一学的,它能够一定程度上让人有实际操控底层内存的体验,一定程度上也算是\"打开计算机的黑盒子\"中的一环吧'),(136,22,'2020-04-24 00:00:00','操作系统第一天---操作系统引导程序','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3621867659,1152751757&fm=26&gp=0.jpg',143,'*今天正式开始学习一直心心念念的操作系统了,没想到引导程序和搭建实验环境竟如当头一棒,路漫漫其修远兮....吾将上下而求索*\r\n\r\n**开机后的操作系统读取细节:**\r\n**1**.读取1号扇区到**0x7c00h**\r\n![](http://img.xuhaobo.site/81)\r\n**2**.进入存储在0x7c00h的bootsect引导扇区程序,并将该程序段移至0x9000段,并通过jmp指令跳到移植后的下一段\r\n![](http://img.xuhaobo.site/83)\r\n**3**.在引导扇区程序中读入load_setup程序段(读入setup段)\r\n![](http://img.xuhaobo.site/84)\r\n**4**.setup程序段读取成功后读入load_setup_ok程序段(这里同时将开机显示字显示到屏幕上),随后读入system程序段(操作系统代码)\r\n![](http://img.xuhaobo.site/85)\r\n**5**.进入setup程序段,载入操作系统相关的参数,将sys放入零地址(前面已经将**引导扇区程序**移动了)，**相关参数例如拓展内存(1M以外的内存)**\r\n![](http://img.xuhaobo.site/86)\r\n**6.**通过一段复杂指令进入保护模式(从此汇编也由16位转变成32位)\r\n\r\n\t**这里着重地说一下保护模式:**\r\n**1.首先我们之前编写汇编程序是一直在实模式下编写的,我们的寻址范围可以理解为cs:ip,那么最多的范围也只有1M,保护模式中cs寄存器所存储的并非段地址而是通过cs查GDT表获得真正的段地址,从而内存的空间由1M变为4G,并且内存完全交由操作系统管理,不需要程序员去考虑**\r\n\r\n**内存空间是如何从1M转变为4G的???**',b'1','今天正式开始学习一直心心念念的操作系统了,没想到引导程序和搭建实验环\r\n境竟如当头一棒,路漫漫其修远兮....吾将上下而求索。'),(139,22,'2020-04-29 00:00:00','<<操作系统导论>>第一天','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3621867659,1152751757&fm=26&gp=0.jpg',106,'*<<操作系统导论>>主要围绕虚拟化,并发以及持久化讲述了操作系统,\"虚拟化\"的第四,五章讲述了操作系统的进程机制,第四章侧重于理论的叙述,第五章讲述了linux的实际进程相关的api以及api为何如此设计的原理*\r\n\r\n\r\n\r\n\r\n首先明确一点:内存实现了cpu的\"虚拟化\",提供了**存在多个虚拟cpu**的假象,使得每一个运行的程序都**分开拥有一整块的内存空间以及寄存器**\r\n\r\n这种运行的程序加上其存储空间的“假象”我们习惯性地称之为**\"进程\"**,多个进程可以一起运行，通过底层机制和高级策略来完成\r\n\r\n进程状态:\r\n1.运行(这个比较常见,就不多赘述了)\r\n\r\n2.就绪:就绪状态:被阻塞后到运行的一种中间态，进程**被调度**-->运行,从运行转移到就绪则为取消调度\r\n--->**已经准备好运行**\r\n\r\n3.阻塞:进程停止运行,直到发生其他事件才继续,可以于操作系统的wait()api相对应,进程在进行wait后只有在回收fork的子进程后才能够继续进行(fork：创建子进程)--->**没有准备好运行**\r\n\r\n**(第四章作业英文太多瓦看不懂......)**\r\n## LINUX相关api补充:\r\n再补充一下linux提供的进程相关的api,大概分为3类,fork(),wait()和exec()\r\n#### fork\r\nfork()是在原地开启一个一样的子进程,可以理解成复制一份完全相同的内存,其变量值与父进程相同,但是互不影响(同时也体现了内存空间的一种虚拟化),**但是写入文件会互相覆盖,毕竟其写入的文件不属于父也不属于子**\r\n\r\n这里fork的原地是指子进程开始进行的位置就是父进程fork的位置\r\n如下图的代码\r\n```c\r\n#nclude<stdio.h>\r\n#include<stdlib.h>\r\n#include<unistd.h>\r\n#include<string.h>\r\n#include<sys/wait.h>\r\n#include<fcntl.h>\r\nint main(int argc,char *argv[])\r\n{\r\n        int rc=fork();\r\n        if(rc<0)\r\n        {\r\n                fprintf(stderr,\"fork failed\\n\");        //fork进程失败\r\n                exit(1);             //退出进程\r\n        }\r\n        else if(rc==0)\r\n        {\r\n                 fprintf(stderr,\"execl failed\\n\");\r\n                 int i=waitpid(rc,NULL,WUNTRACED);         //子进程调用wait\r\n                printf(\"进程%d结束,wait值为%d\",(int)getpid(),i);\r\n                 exit(-1);\r\n        }\r\n        else{\r\n                int i=waitpid(rc,NULL,WUNTRACED);\r\n                printf(\"进程%d结束,wait值为%d\",(int)getpid(),i);\r\n        }\r\n\r\n        return 0;\r\n}\r\n```\r\n这里我\"fork\"的位置在第九行,那么后面的子进程也同样在第九行开始,只是父进程返回的int值为子进程的pid(进程ID)，而子进程返回为-1\r\n\r\n#### wait\r\nwait算是和fork一起使用的api,它比fork好理解很多,大概功能就是等待回收我的子进程(这里补充下进程状态除了就绪,运行和阻塞外,其实还有初始和僵死态),这里我所等待的就是子进程从僵死态被回收\r\n**这里注意我所说的linux api可能均有多种实现接口,这里只是浅显地分一下类**\r\n\r\n#### exec(不可逆的重定向)\r\nexec个人认为算是给我直观感受**\"简单粗暴\"**的api，它的作用就是加载并执行指定的可执行程序,并且直接覆盖掉原有分配的内存空间(堆,栈)等\r\n\r\n我们在shell里面执行程序的过程可以理解成先fork一个子进程,再使用exec执行指定的程序(我们已经通过命令行输入),并在父进程调用wait等待子程序的完成\r\n\r\n**为什么不直接exec开启进程执行程序:将fork与exec分离,给了shell再fork后\r\nexec前一个实现多种功能的空间,(例如将某进程运行结果打印到某一文件)**\r\n\r\n#### 补充说明:write,read,pipe函数(输入输出相关)\r\n这里我认为可以通过问题中的最后一道题来说明:\r\n![](http://img.xuhaobo.site/99)\r\n代码如下:\r\n```c\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<unistd.h>\r\n#include<string.h>\r\n#include<sys/wait.h>\r\n#include<fcntl.h>\r\nint main(int argc,char *argv[])\r\n{\r\n        int fd[2]; //用于创建管道的数组\r\n\r\n        char w[100];\r\n        memset(w,0,sizeof(w));//将w里所有字节设置为0\r\n \r\n        char r[100];\r\n        memset(r,0,sizeof(r));//将r中所有字节设置为0\r\n \r\n \r\n        if(pipe(fd)==-1)\r\n        {\r\n        fprintf(stderr,\"pipe failed\\n\");\r\n        }          //创建管道\r\n\r\n        int rc=fork();\r\n        if(rc<0)\r\n        {\r\n        fprintf(stderr,\"fork failed\\n\");        //fork进程失败\r\n        exit(1);             //退出进程\r\n        }\r\n        else if(rc==0)                        //第一个子进程\r\n        {\r\n            close(fd[0]);\r\n            char w[]=\"250\\n\";\r\n            write(1,w,sizeof(w));                   //字符串写入标准输出\r\n            write(fd[1],w,sizeof(w));      //将父进程所写的全部读入管道中\r\n            close(fd[1]);\r\n            exit(1);\r\n        }else{\r\n           wait(NULL); //等待子进程进行完\r\n           int p2;\r\n           if((p2=fork())==-1)\r\n          {\r\n            fprintf(stderr,\"pipe failed\\n\");\r\n          }else if(p2==0){\r\n            close(fd[1]);                      //第二个子进程\r\n            read(fd[0],r,sizeof(w));\r\n            write(0,r,sizeof(w));           //将缓冲区值读入输入中\r\n            close(fd[0]);\r\n            exit(1);\r\n          }else{\r\n            wait(NULL);                //等待第二个子进程输入完毕\r\n            printf(\"运行结束\");\r\n                }\r\n        }\r\n\r\n        return 0;\r\n}\r\n```\r\n**接下来我将使用伪代码来实现:**\r\nwrite(被写入文件修饰符,缓冲区首地址，字节数)；\r\nread(文件修饰符,被读入缓冲区首地址，\'字节数\')；\r\npipe(int fd[2]):使用两个文件构建一个管道\r\nfd[0]固定被只被读文件\r\nfd[1]固定为只被写文件\r\n\r\n**本题思路实现**\r\n在LINUX中我们同样可以将标准输入输出当作一种文件来看,规定标准输入为0,输出为1,所以可以通过read,write写入写出,先将被写入到文件修饰符1的缓冲区写入到fd[1] (只被写),再通过fd[0] (只被读)接受我们想得到的字节,再通过write到文件修饰符0(标准输入)打在命令行上\r\n如图即为运行结果\r\n![](http://img.xuhaobo.site/100)',b'1','<<操作系统导论>>主要围绕虚拟化,并发以及持久化讲述了操作系统,\"虚拟化\"的第四,五章讲述了操作系统的进程机制,第四章侧重于理论的叙述,第五章讲述了linux的实际进程相关的api以及api为何如此设计的原理'),(140,22,'2020-05-01 00:00:00','<<操作系统导论>>进程机制与策略(1)','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3621867659,1152751757&fm=26&gp=0.jpg',24,'*操作系统对于进程的管理,可以分为底层的机制(受限直接进行)以及上层的策略(进程调度),通过底层机制和上层调度共同完成操作系统的进程切换并保护其数据。*\r\n\r\n##1.机制：受限直接执行\r\n受限直接执行机制,大概应用于两方面,**系统调用**以及**进程的上下文切换**\r\n####系统调用原理\r\n我们平时使用的程序均为用户程序,操作系统为用户程序提供管理,以防止用户程序进行超限访问，IO请求等可能会影响到其他进程的指令,因此操作系统提供了用户\r\n程序通过系统调用完成这些特殊指令的机制\r\n\r\n通俗点的解释:操作系统可以比作家长,用户程序比作孩子,这个“孩子”想要吃饭,但是它自己点火可能会把房子烧了,所以家长把厨房的门锁了起来,孩子如果想要吃饭,那么向家长发出请求,家长帮它去做\r\n\r\n具体实现:用户程序在发出系统调用时,操作系统将寄存器保存到内核栈,陷入到操作系统(此时模式由用户模式转向内核模式),操作系统处理陷阱(特权操作),随后返回程序,根据内核栈回复寄存器，跳到陷阱之后的程序计数器。\r\n\r\n####进程间切换\r\n目前的操作系统采用非协作方式,通过上下文切换的方式进行,通过时钟周期发送中断信号,操作系统定期通过中断处理程序取得cpu的控制权\r\n\r\n具体实现:\r\n1.**时钟周期发送定期中断，通过中断处理程序cpu控制权转向操作系统**\r\n2.**和之前陷入内核模式一样将寄存器保存在内核栈**\r\n3.在内存栈将目前进程寄存器保存在进程结构,将将要转入的进程结构保存在寄存器\r\n4.**从内核栈恢复到寄存器**\r\n\r\n那么操作系统如何选择我们要切换到哪个进程呢?\r\n\r\n##1.策略：进程调度\r\n1.几个概念:\r\n**工作负载**:我们大概可以理解成每个进程的特点\r\n**调度指标**:\r\n周转时间:任务完成时间减去任务到达系统的时间\r\n响应时间:任务到达系统到任务被响应的时间(IO)\r\n**常见算法(这里我们用排队办银行业务来比喻)**\r\n**FIFO**:常见的队列的先进先出\r\n**SJF**:最短时间优先(非抢占)(你几个人一起排的按时间短的先来,后来的接着排着)\r\n**STCF**:最短时间优先(抢占)(有比你快的能把你正办的业务给挤掉)\r\n(STCF适用于获得最好的性能(所有人取钱最快))\r\n\r\n**响应优先:**\r\n**RR**:轮转(你要取1000,先给你一百,你再接着排,给每个人一百,每个人接\r\n着排)\r\n##### 这不急吗?\r\n确实，这么做一定程度上性能是最低的,每个人排,每个人取走他的所有钱的时间都会晚,也就是周转时间最长\r\n但是操作系统不同于取钱的时,很多程度你打开后进行IO操作就是需要立即响应\r\n让你等个10秒等别的干完您再来,您就觉得操蛋了\r\n就像我本来想取1000,我中间闹肚子了想要10块,还是没排到我,你就想我先取10块别的再以后取,\r\n**现实生活中是个奇葩,但是在计算机里这种操作很多,毕竟我们的程序都是有\"交互\"的需求的,我们用鼠标按一下,就是想要有立刻的响应**\r\n\r\n这就体现了所谓“公平”(让每一个进程共同享有资源)和\"性能\"的矛盾\r\n但是,这些都是基于操作系统本身知道每个工作的长度(可以抽象理解成每个进程所需要的时间)的。但是现实中往往是不知道的,银行哪知道你进来要取多少钱呢?所以后续还要有继续的补充',b'1','操作系统对于进程的管理,可以分为底层的机制(受限直接进行)以及上层的策略(进程调度),通过底层机制和上层调度共同完成操作系统的进程切换并保护其数据。'),(141,22,'2020-05-01 00:00:00','<<操作系统导论>>第七章问题解析','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3621867659,1152751757&fm=26&gp=0.jpg',44,'1.2.3题:都基于对于各种调度算法的简单理解,这里不多说了\r\n4.SJF：时间最短优先,所以FIFO要么相等，要么递增(队列自动符合从小的开始)\r\n5.每个进程的时间与时间分片相同,或者总时间小于时间分片(也就没分片)\r\n6.这个题的用意我依然没能理解.....\r\n自己试着写的C代码如下:\r\n```c\r\n#include<stdio.h>\r\n#include<math.h>\r\nint main()\r\n{\r\n\tint time=0;\r\n\tint last=0;\r\n\tint sum=0;\r\n\tfor(int i=1;i<=100;i++)\r\n\t{\r\n\t\tprintf(\"总响应时间为%d\\n\",i+(i+1));\r\n\t}\r\n\treturn 0;\r\n } \r\n```\r\n\r\n7.**RR的最坏情况(重点)**\r\n**也就是最后一个被响应的进程**\r\n我们设时间片为q，因此最坏的情况就是,前几个进程**每一个都占据一个时间分片**，**每次的时间分片只能响应一个进程，取得每一次时间分片的最低效率**\r\n即为:**(N-1)*q前N-1个进程工作每一个都是q**,最好的肯定是第一个进程,直接响应,为0 \r\n那么平均响应时间即为**（N-1)*q/2**',b'1','<<操作系统导论>>第七章问题解析'),(142,22,'2020-05-02 00:00:00','<<操作系统导论>>进程与策略(2)-MLFQ队列调度笔记以及习题解析','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3621867659,1152751757&fm=26&gp=0.jpg',13,'##理论知识\r\n\r\nMLFQ规则:有多级队列,cpu每次都执行最高级的进程,如果最高级有多个进程则使用轮转运行\r\n\r\n**每一个进程刚刚进入队列时都在最高级队列,工作用完整个时间片后,降低优先级,如果工作在时间内主动释放CPU,则优先级不变(此时系统局部判断它在进行IO中断释放cpu，因此属于交互程序)**\r\n\r\n这样使得每一个进程刚刚进入都被是做短进程优先进行,随着时间推移优先度降低\r\n，这样也同时使得短时间进行交互的IO密集型进程能够迅速被响应,随着时间推移操作系统会\"自主\"学习判断该队列是重视长时间计算进行的**计算密集型**,还是重视短时间IO交互的**IO密集型**\r\n\r\n**而加重号的机制一定程度上造成了三种问题:**\r\n1.饥饿问题:IO密集进程始终保持高优先级,使得低优先级计算进程始终难以得到CPU资源\r\n2.愚弄调度程序:一个进程可以每一次在时间片的最后调用一下IO操作,从而主动释放cpu,一直不断保持高优先级\r\n3.进程的变化:一个进程的状态是可以变化的,也就是说如果一个计算密集型某时间内表现为IO密集型进程,它将\"永无出头之日\"\r\n\r\n**我们所给出的解决方案**:\r\n问题1:每间隔一段时间就将系统所有工作全部放入最高优先级队列\r\n这里时间的设置要适度,太短的话会影响IO交互效率,太长的话长工作又会饥饿\r\n问题2,3:不把\"释放cpu\"的操作看作特殊操作,进程到达**队列时间片**后自动下沉,\r\n**（后期实验后的补充:我们可以通过设置IOdump使得之前操作过IO的工作在下一队列第一个被执行）**\r\n\r\n最终优化后的规则如下:![](http://img.xuhaobo.site/101)\r\n\r\n##**习题解析**:\r\n1.根据规则判断即可,主要考察对整个调度过程的熟悉\r\n2.\r\n实例1:![](http://img.xuhaobo.site/102)\r\n\r\n实例2:![](http://img.xuhaobo.site/103)\r\n\r\n实例3：![](http://img.xuhaobo.site/104)\r\n3.暂时还不太理解.......个人认为只要同时进入,且各队列时间分片相同即可\r\n4.大体思路:每99分钟发起一次1分钟的IO,时间分片为100分钟,发起IO时放弃cpu会给低优先级进程1分钟的时间进行,IO结束后由于机制的原因不会降低优先级,愚弄进程重新\"掌控大权\",因此为99%\r\n![](http://img.xuhaobo.site/105)\r\n5.-B 200(10/0.05)\r\n6.两者直观比较为:\r\n1.**未使用IO dump**：\r\n![](http://img.xuhaobo.site/106)\r\n进程下沉后按顺序在低级队列排队\r\n使用IO dump\r\n![](http://img.xuhaobo.site/107)\r\n进程0完成IO后在下沉后进行\"插队\"',b'1','MLFQ队列解决了前面说的\"既要优化周转时间,又要给用户很好的交互体验\",以及\"在时间片不可知的情况下进行短队列\"的问题'),(143,22,'2020-05-05 00:00:00','<<操作系统导论>>进程与策略(3)调度:比例份额','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3621867659,1152751757&fm=26&gp=0.jpg',31,'## 1.彩票调度\r\n>基本想法:在分配进程中给每个进程分配一些彩票份额(每个进程的彩票数不同),随后进程产生一个彩票的随机数,随机数对应哪张彩票哪个进程就被调度,由此可见,哪个进程彩票多,那么运行的机会也就大,但是具体的彩票如何分配目前尚没有太好的解决方案\r\n\r\n缺陷:在运行时间很短的情况下,不容易产生正常的比例\r\n## 2.步长调度\r\n根据进程的票数求出自己的步长值(进程票数越多步长越小)初始化每一个进程行程值为0,可以理解成所有的进程一起行走\r\n每一个选择\"走得最少\"的进程,那么步长小(**票数多的**)的走得最慢,也就一直被选择调度,\r\n好处:比彩票调度更精准\r\n缺陷:要记录全局状态以免新进入的进程(行程值为0),直接占有整个cpu',b'1','比例份额算法基于一个简单的想法:确保每个工作获得一定比例的cpu时间,而不是优化周转时间和响应时间'),(144,22,'2020-05-06 00:00:00','<<操作系统导论>>虚拟内存(1)','https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3621867659,1152751757&fm=26&gp=0.jpg',62,'*前几章一直在介绍cpu的虚拟化(让进程认为自己独有一个cpu),这次开始讲述内存的虚拟化(使每个进程认为自己独自拥有一段内存)*\r\n\r\n## 1.虚拟内存的目的:\r\n1. 使内存\"透明化\",程序员在编写程序的过程中不用关心自己使用具体的内存地址\r\n1. 提高内存的使用效率,原始的cpu只能使用32位内存\r\n1. 提高对进程数据的保护,各自进程间内存互不干扰\r\n\r\n## 2.内存操作API:\r\n这个算是老朋友了,早在学习c语言的时候已经见过面了,这里不细说了\r\n\r\n## 3.内存的地址转换机制(保证大部分时候由指令直接访问硬件,关键时刻操作系统介入):\r\n#### 1.原始的动态重定位:\r\n通过在创建进程时将内存基址以及界限寄存器存入指定值(内存基址以及界限寄存器由硬件实现)\r\n在之后取值执行访问内存时通过基址+虚拟地址重定向实现,超过界限寄存器以及使用内核指令则会引起操作系统介入,调用相关的异常处理程序\r\n\r\n**该转换机制的缺陷很明显,每一次分配指定的基址的同时会为该进程分配一大块空间,会造成很大的内存浪费**\r\n\r\n#### 1.分段(将进程中的各内存空间解耦):\r\n首先明确一些进程中的内存空间:\r\n代码段:我们所编写的代码部分,用于取址执行\r\n栈:用于临时分配的变量(如int a=1),**存储方向为地址由大向小存储**\r\n堆:用于动态请求的内存块，**存储方向为地址由小向大存储**\r\n![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588789492427&di=7e5af1dd22a2c33e938424281c32e450&imgtype=0&src=http%3A%2F%2Fimg4.imgtn.bdimg.com%2Fit%2Fu%3D3388502434%2C3629963514%26fm%3D214%26gp%3D0.jpg)\r\n以之前说的三段代码段举例,我们把原本的进程内存空间切成一段一段的,每一段按照类似于原始的基址寄存器的方式存储,需要多组的基址寄存器\r\n**支持共享**:在段寄存器上添加保护位,设置代码以及部分数据为只读段,可以由其他进程共用而无法被修改,**类似于公共场所的公用电梯,你可以使用它但是不能把它的电缆给偷走**\r\n**引出\"段错误\"**:程序访问的虚拟内存超过了给定的分段内存的段以外的位置\r\n优势:我们将内存细分为一段一段的形式,使用时再动态地分配段,一定程序上避免了浪费\r\n\r\n缺点:外部碎片现象,我们分配的段中依然会有空余空间,分裂的段中空余空间会很多,每一个空余空间假如是1k,我们现在要使用一块10k的内存,本来有十个段都剩1k,这种时候却不能顺利地使用',b'1','前几章一直在介绍cpu的虚拟化(让进程认为自己独有一个cpu),这次开始讲述内存的虚拟化(使每个进程认为自己独自拥有一段内存)');

#
# Structure for table "user"
#

DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  `role` varchar(5) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`),
  UNIQUE KEY `email` (`email`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;

#
# Data for table "user"
#

INSERT INTO `user` VALUES (2,'徐浩博','c1d649d9112fd39916999c35272ca0fe','admin','511928849@qq.com'),(6,'西瓜酸奶','94e7d712742adbbb7a73a1d52a7cc1a9','user','yuanyi2000@aliyun.com');

#
# Structure for table "comment"
#

DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `aid` int(11) NOT NULL,
  `content` text,
  `createTime` datetime DEFAULT NULL,
  `parentID` int(11) DEFAULT NULL,
  `uid` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `fk_comment_article` (`aid`),
  KEY `comment_parentComment` (`parentID`),
  KEY `comment_user` (`uid`),
  CONSTRAINT `comment_parentComment` FOREIGN KEY (`parentID`) REFERENCES `comment` (`id`),
  CONSTRAINT `comment_user` FOREIGN KEY (`uid`) REFERENCES `user` (`id`),
  CONSTRAINT `fk_comment_article` FOREIGN KEY (`aid`) REFERENCES `article` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=196 DEFAULT CHARSET=utf8mb4;

#
# Data for table "comment"
#

INSERT INTO `comment` VALUES (151,134,'老递归了','2020-04-29 00:00:00',NULL,2),(156,136,'富强民主文明和谐','2020-04-29 00:00:00',NULL,6),(166,118,',','2020-05-01 00:00:00',NULL,2),(172,142,'2222','2020-05-08 08:33:20',NULL,2),(173,142,'22222222','2020-05-08 08:33:24',172,2),(174,142,'dddd','2020-05-08 08:34:43',173,2),(175,143,'测试测试测试','2020-05-08 09:35:48',NULL,2),(184,142,',,,','2020-05-16 20:57:17',172,2),(190,144,'22222222','2020-05-18 20:23:46',NULL,2),(191,144,'d','2020-05-18 20:24:25',190,2),(192,144,'dddd','2020-05-18 20:26:44',NULL,2),(193,144,'ddd','2020-05-18 20:28:34',NULL,2),(194,139,'顶顶顶顶','2020-05-18 20:41:00',NULL,2),(195,139,'等待','2020-05-18 20:41:47',194,2);
